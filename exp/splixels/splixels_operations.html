<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>image -> splixels -operations-> splixels</title>
    <meta name="keywords" content="iterative,algorithms,guide,tutorial,learning">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.results {
    font-family: sans-serif;
    font-size: 14pt;
    width: 505pt;
    text-align: left;
}

.formula {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: italic;
    width: 505pt;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

table.footer {
    padding: 64pt 0pt 32pt 0pt;
    background-color: transparent;
    width: 505pt;
}

td.footer {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: normal;
    padding: 0;
    margin: 0;
    border: 0;
}

li {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
    padding-bottom: 6pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
}

input[type="text"] {
    width: 48pt;
    height: 22pt;
    font-size: 16pt;
    text-align: center;
}

input[type="radio"] {
    height: 16pt;
    width: 16pt;
    font-size: 16pt;
}

input[type="checkbox"] {
    height: 16pt;
    width: 16pt;
    font-size: 16pt;
    margin-bottom: 16pt;
}

button {
    width: 128pt;
    height: 26pt;
    font-size: 16pt;
    text-align: center;
}

textarea {
    width: 600pt;
    font-size: 12pt;
    font-family: monospace;
}

.comment {
    font-size: 12pt;
    text-align:center;
    font-family: sans-serif;
    padding-bottom: 24pt;
}
    </style>
    <script language="JavaScript">

// client
var w = 1024.0;
var h = 1024.0;

// algorithm
var threshold = 0.5;

// pixels
var pixels = [];
var pixel_size;

function reset_pixels(w, h) {
    pixels = [];
    for(var i = 0; i < h; ++i) {
        pixelsi = []
        for(var j = 0; j < w; ++j)
            pixelsi.push(0);
        pixels.push(pixelsi);
    }
}

var points_and_tangents = [];
var splines = [];

// splixels
const splixel = {
    to_margin: 1, // -1 = outside; 1 = inside; 0 = margin
    xy_shift: [0.0, 0.0], // shift from a splixel center point (which is pixel's upper-left)
    xy_normal: [0.0, 0.0], // unnormalized normal vector in the shifted point.
    // neighbors
    right: false,
    left: false, 
    top: false,
    bottom: false
};

const the_default_splixel = Object.create(splixel);

function new_splixels(w, h) {
    var splixels = [];
    for(var i = 0; i < h; ++i) {
        splixelsi = []
        for(var j = 0; j < w; ++j)
            splixelsi.push(Object.create(splixel));
        splixels.push(splixelsi);
    }
    return splixels;
}

// solver specific to [0..1] parametrized splines
function spline_for(p1, p1d, p2, p2d) {
//     A = [
//         [1, 0, 0, 0],
//         [0, 1, 0, 0],
//         [1, 1, 1, 1],
//         [0, 1, 2, 3]];
//     B = [p1, p1d, p2, p2d]
    return [
        p1,
        p1d,
        3 * p2 - p2d - 3*p1 - 2*p1d,
        p2d + p1d - 2*p2 + 2*p1
    ];
}

// polynomial
function polynomial_in_x(A, x){
    var y = 0.0;
    for(var i = 0; i < A.length; ++i){
        y += A[i] * Math.pow(x, i);
    }
    return y;
}

// pixel value with out of bounds compenstaions
function pixel_in(pixels, i, j) {
    if(i >= pixels.length)
        return pixel_in(pixels, pixels.length-1, j);
    if(i < 0) 
        return pixel_in(pixels, 0, j);
    if(j >= pixels[0].length)
        return pixel_in(pixels, i, pixels[0].length-1);
    if(j < 0)
        return pixel_in(pixels, i, 0);
    if(!pixels[i])
        alert(i);
    return pixels[i][j];
}

// linear interpolation
function value_in(pixels, x, y) {
    var j = Math.floor(x - 0.5);
    var tj = x - 0.5 - j;
    var i = Math.floor(y - 0.5);
    var ti = y - 0.5 - i;
    return pixel_in(pixels, i, j) * (1 - ti) * (1 - tj)
         + pixel_in(pixels, i, j+1) * (1 - ti) * (tj)
         + pixel_in(pixels, i+1, j+1) * (ti) * (tj)
         + pixel_in(pixels, i+1, j) * (ti) * (1 - tj);
}

// gradient
function gradient(pixels, x, y) {
    const epsilon = 1e-5;
    return [(value_in(pixels, x + epsilon, y) - value_in(pixels, x, y)) / epsilon,
            (value_in(pixels, x, y + epsilon) - value_in(pixels, x, y)) / epsilon];
}

// how far should you shift the point to meet the isoline 
// if value_in were a distance function
function gradient_shift(pixels, threshold, x, y) {
    var g = gradient(pixels, x, y);
    var g_norm = Math.sqrt(g[0]*g[0] + g[1]*g[1]);
    var d = threshold - value_in(pixels, x, y);
    return [g[0] * d / g_norm / g_norm, g[1] * d / g_norm / g_norm];
}

// brings a point closer to the threshold isoline
function fit_point_better(pixels, threshold, point) {
    const small_enough_error = 1/255;
    if(Math.abs(value_in(pixels, point[0], point[1]) - threshold) < small_enough_error)
        return point;
    var gs = gradient_shift(pixels, threshold, point[0], point[1]);
    return fit_point_better(pixels, threshold, [point[0] + gs[0], point[1] + gs[1]]);
}

// the algorithm itself
function turn_pixels_into_points_and_tangents(pixels, threshold) {
    var points = [];
    var tangents = [];

    // "horizontal" pieces    
    for(var i = 0; i <= pixels.length; i += 1) {
        var old_point = [];
        var old_tangent = [];
        for(var j = 0; j <= pixels[0].length; j += 1) {
            // if right, left, top, and bottom pixels have a sign change, there should be a spline there
            var sign_change_on_the_right  = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_left   = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) < 0;
            var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_top    = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) < 0;
            if(sign_change_on_the_right || sign_change_on_the_left) {
                // fits the point on a threshold isoline
                var point = fit_point_better(pixels, threshold, [j, i]);
                var g = gradient(pixels, point[0], point[1]);
                
                // we want our tangent to be X-positive for horizontal pieces
                var tangent = g[1] >= 0 ? [g[1], -g[0]] : [-g[1], g[0]];
                
                // this is an T or X junction, the tangent is ambiguous
                if(sign_change_on_the_left + sign_change_on_the_right + sign_change_on_the_top + sign_change_on_the_bottom > 2)
                    tangent = [0., 0.];
                    
                // store the point+tangent and the previous point+tangent if there is one
                if(sign_change_on_the_left && old_point) {                    
                    points.push([old_point, point]);
                    tangents.push([old_tangent, tangent]);
                }
                
                // save the point+tangent for later
                if(sign_change_on_the_right) {
                    old_point = point;
                    old_tangent = tangent;
                }   
            }      
        }
    }

    // "vertical" pieces
    for(var j = 0; j <= pixels[0].length; j += 1) {
        var old_point = [];
        var old_tangent = [];
        for(var i = 0; i <= pixels.length; i += 1) {
            var sign_change_on_the_right  = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_left   = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) < 0;
            var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_top    = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) < 0;
            if(sign_change_on_the_bottom || sign_change_on_the_top) {
                var point = fit_point_better(pixels, threshold, [j, i]);
                var g = gradient(pixels, point[0], point[1]);             
                var tangent = g[0] < 0 ? [g[1], -g[0]] : [-g[1], g[0]];
                if(sign_change_on_the_left + sign_change_on_the_right + sign_change_on_the_top + sign_change_on_the_bottom > 2)
                    tangent = [0., 0.];
                if(sign_change_on_the_top && old_point) {
                    points.push([old_point, point]);
                    tangents.push([old_tangent, tangent]);
                }
                if(sign_change_on_the_bottom) {
                    old_point = point;
                    old_tangent = tangent;
                }   
            }      
        }
    }
    return [points, tangents];
}

function turn_points_and_tangents_into_splines(points_and_tangents) {
    var splines = [];
    var points = points_and_tangents[0];
    var tangents = points_and_tangents[1];
    for(var i = 0; i < points.length; ++i) {
        var Px = spline_for(points[i][0][0], tangents[i][0][0], points[i][1][0], tangents[i][1][0]);
        var Py = spline_for(points[i][0][1], tangents[i][0][1], points[i][1][1], tangents[i][1][1]);
        splines.push([Px, Py]);
    }
    return splines
}

function turn_pixels_into_splixels(pixels, threshold) {
    var splixels = new_splixels(pixels[0].length + 1, pixels.length + 1);
    for(var i = 0; i <= pixels.length; i += 1) {
        for(var j = 0; j <= pixels[0].length; j += 1) {
            // value in splixel
            var value = value_in(pixels, i-0.5, j+0.5) - threshold;
            
            // if right, left, top, and bottom pixels have a sign change, there should be a spline there
            var sign_change_on_the_right  = (pixel_in(pixels, i-1, j+0) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_left   = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i+0, j-1) - threshold) < 0;
            var sign_change_on_the_bottom = (pixel_in(pixels, i+0, j-1) - threshold) * (pixel_in(pixels, i+0, j+0) - threshold) < 0;
            var sign_change_on_the_top    = (pixel_in(pixels, i-1, j-1) - threshold) * (pixel_in(pixels, i-1, j+0) - threshold) < 0;

            if(sign_change_on_the_right || sign_change_on_the_left || sign_change_on_the_bottom || sign_change_on_the_top) {
                // fits the point on a threshold isoline
                var point = fit_point_better(pixels, threshold, [j, i]);
            
                // get the gradient
                var g = gradient(pixels, point[0], point[1]);
            
                splixels[i][j].to_margin = 0;
                splixels[i][j].xy_shift = [point[0] - j, point[1] - i];
                splixels[i][j].xy_normal = g;
                splixels[i][j].right = sign_change_on_the_right;
                splixels[i][j].left = sign_change_on_the_left;
                splixels[i][j].top = sign_change_on_the_top;
                splixels[i][j].bottom = sign_change_on_the_bottom;
            } else {
                splixels[i][j].to_margin = Math.sign(value);
            }
        }
    }
    return splixels;
}

function turn_splixels_into_points_and_tangents(splixels, threshold) {
    var points = [];
    var tangents = [];

    // "horizontal" pieces    
    for(var i = 0; i <= pixels.length; i += 1) {
        var old_point = [];
        var old_tangent = [];
        for(var j = 0; j <= pixels[0].length; j += 1) {
            var sign_change_on_the_right  = splixels[i][j].right;
            var sign_change_on_the_left   = splixels[i][j].left;
            var sign_change_on_the_top    = splixels[i][j].top;
            var sign_change_on_the_bottom = splixels[i][j].bottom;
            if(sign_change_on_the_right || sign_change_on_the_left) {
                var point = [j + splixels[i][j].xy_shift[0], i + splixels[i][j].xy_shift[1]];
                var g = splixels[i][j].xy_normal;
                var tangent = g[1] >= 0 ? [g[1], -g[0]] : [-g[1], g[0]];
                if(sign_change_on_the_left + sign_change_on_the_right + sign_change_on_the_top + sign_change_on_the_bottom > 2)
                    tangent = [0., 0.];
                if(sign_change_on_the_left && old_point) {                    
                    points.push([old_point, point]);
                    tangents.push([old_tangent, tangent]);
                }
                if(sign_change_on_the_right) {
                    old_point = point;
                    old_tangent = tangent;
                }   
            }      
        }
    }

    // "vertical" pieces
    for(var j = 0; j <= pixels[0].length; j += 1) {
        var old_point = [];
        var old_tangent = [];
        for(var i = 0; i <= pixels.length; i += 1) {
            var sign_change_on_the_right  = splixels[i][j].right;
            var sign_change_on_the_left   = splixels[i][j].left;
            var sign_change_on_the_top    = splixels[i][j].top;
            var sign_change_on_the_bottom = splixels[i][j].bottom;
            if(sign_change_on_the_bottom || sign_change_on_the_top) {
                var point = [j + splixels[i][j].xy_shift[0], i + splixels[i][j].xy_shift[1]];
                var g = splixels[i][j].xy_normal;            
                var tangent = g[0] < 0 ? [g[1], -g[0]] : [-g[1], g[0]];
                if(sign_change_on_the_left + sign_change_on_the_right + sign_change_on_the_top + sign_change_on_the_bottom > 2)
                    tangent = [0., 0.];
                if(sign_change_on_the_top && old_point) {
                    points.push([old_point, point]);
                    tangents.push([old_tangent, tangent]);
                }
                if(sign_change_on_the_bottom) {
                    old_point = point;
                    old_tangent = tangent;
                }   
            }      
        }
    }
    return [points, tangents];
}

function draw_splines(context, splines) {
    context.beginPath();
    for(var i = 0; i < splines.length; ++i) {
        for(var k = 0; k < pixel_size; k += 1) {
            var t1 = (k) / pixel_size;
            var t2 = (k + 1) / pixel_size;
            var x1 = polynomial_in_x(splines[i][0], t1) * pixel_size;
            var y1 = polynomial_in_x(splines[i][1], t1) * pixel_size;
            var x2 = polynomial_in_x(splines[i][0], t2) * pixel_size;
            var y2 = polynomial_in_x(splines[i][1], t2) * pixel_size;
            context.moveTo(x1, y1);
            context.lineTo(x2, y2);
        }
    }
    context.stroke();
    context.closePath();    
}

function draw_splixels(context, splixels) {
    var splines = 
        turn_points_and_tangents_into_splines(
            turn_splixels_into_points_and_tangents(splixels, threshold)); 
    draw_splines(context, splines);
}

var cur_point_indexes = [];
var cur_point_in_pair_indexes = [];
var cur_tangent_index = -1;
var cur_tangent_in_pair_index = -1;
function init_canvas(){
    var canvas = document.getElementById("canvas");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        var x = e.clientX - canvas_rect.left;
        var y = e.clientY - canvas_rect.top;
        if(document.getElementById("tool_2").checked) { // points
            cur_point_indexes = [];
            cur_point_in_pair_indexes = [];
            var points = points_and_tangents[0];
            var min_d2 = (w+h)*(w+h);
            for(var i = 0; i < points.length; ++i) {
                for(var j = 0; j < 2; ++ j) {
                    var px = pixel_size * points[i][j][0];
                    var py = pixel_size * points[i][j][1];
                    var d2 = (px - x)*(px - x) + (py - y)*(py - y);
                    if(cur_point_indexes.length == 0 || d2 < min_d2) {
                        cur_point_indexes = [i];
                        cur_point_in_pair_indexes = [j];
                        min_d2 = d2;
                    }else if(d2 == min_d2) {
                        cur_point_indexes.push(i);
                        cur_point_in_pair_indexes.push(j);
                    }
                }
            }
        } else if(document.getElementById("tool_3").checked) { // tangents
            cur_tangent_index = -1;
            cur_tangent_in_pair_index = -1;
            var points = points_and_tangents[0];
            var tangents = points_and_tangents[1];
            var min_d2 = (w+h)*(w+h);
            for(var i = 0; i < points.length; ++i) {
                for(var j = 0; j < 2; ++ j) {
                    var px = pixel_size * (points[i][j][0] + tangents[i][j][0]);
                    var py = pixel_size * (points[i][j][1] + tangents[i][j][1]);
                    var d2 = (px - x)*(px - x) + (py - y)*(py - y);
                    if(cur_tangent_index == -1 || d2 < min_d2) {
                        cur_tangent_index = i;
                        cur_tangent_in_pair_index = j;
                        min_d2 = d2;
                    }
                }
            }
        }
        
    }, false);
     
    canvas.addEventListener('mousemove', function(e){
        if(e.buttons == 1){
            canvas_rect = canvas.getBoundingClientRect();
            var x = e.clientX - canvas_rect.left;
            var y = e.clientY - canvas_rect.top;
            if(document.getElementById("tool_2").checked) { // points
                var points = points_and_tangents[0];
                for(var i = 0; i < cur_point_indexes.length; ++i) {
                    points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][0] = x / pixel_size;
                    points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][1] = y / pixel_size;
                }               
            } else if(document.getElementById("tool_3").checked) { // tangents
                var points = points_and_tangents[0];
                var tangents = points_and_tangents[1];
                tangents[cur_tangent_index][cur_tangent_in_pair_index][0] = x / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][0];
                tangents[cur_tangent_index][cur_tangent_in_pair_index][1] = y / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][1];
                splines = turn_points_and_tangents_into_splines(points_and_tangents);  
            }
            splines = turn_points_and_tangents_into_splines(points_and_tangents);
            draw_canvas(splines, []);
        }
    }, false);
    
    canvas.addEventListener('mouseup', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        var x = e.clientX - canvas_rect.left;
        var y = e.clientY - canvas_rect.top;
        if(document.getElementById("tool_1").checked) {
            var in_pixels_i = Math.floor(y / pixel_size);
            var in_pixels_j = Math.floor(x / pixel_size);
            pixels[in_pixels_i][in_pixels_j] *= 7;
            if(e.shiftKey)       
                pixels[in_pixels_i][in_pixels_j] += 7;
            else
                pixels[in_pixels_i][in_pixels_j] += 1;
            pixels[in_pixels_i][in_pixels_j] = Math.floor(pixels[in_pixels_i][in_pixels_j]) % 8;
            pixels[in_pixels_i][in_pixels_j] /= 7;
            points_and_tangents = turn_pixels_into_points_and_tangents(pixels, threshold);
            splines = turn_points_and_tangents_into_splines(points_and_tangents);
        } else if(document.getElementById("tool_2").checked) { // points
            var points = points_and_tangents[0];
            for(var i = 0; i < cur_point_indexes.length; ++i) {
                points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][0] = x / pixel_size;
                points[cur_point_indexes[i]][cur_point_in_pair_indexes[i]][1] = y / pixel_size;
            }
            splines = turn_points_and_tangents_into_splines(points_and_tangents);  
        } else if(document.getElementById("tool_3").checked) { // tangents
            var points = points_and_tangents[0];
            var tangents = points_and_tangents[1];
            tangents[cur_tangent_index][cur_tangent_in_pair_index][0] = x / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][0];
            tangents[cur_tangent_index][cur_tangent_in_pair_index][1] = y / pixel_size - points[cur_tangent_index][cur_tangent_in_pair_index][1];
            splines = turn_points_and_tangents_into_splines(points_and_tangents);  
        }
        draw_canvas(splines, []);
    }, false);
    
    draw_canvas(splines, []);
}


function draw_canvas(splines, splixels){
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    var do_background = document.getElementById("show_background").checked;

    if(splines.length > 0 && do_background) {
        // pixels
        var pixel_field = context.createImageData(w, h);
        for (var i = 0; i < pixel_field.data.length; i += 4) {
            var on_canvas_i = Math.floor(Math.floor(i / 4) / w);
            var on_canvas_j = Math.floor(i / 4) % w;
            var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
            var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
            var pixel_value = Math.max(Math.min(pixels[in_pixels_i][in_pixels_j], 1.0), 0.0);
            pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
            pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
            pixel_field.data[i + 2] = 0xFF;
            pixel_field.data[i + 3] = 0xFF;
        }
        context.putImageData(pixel_field, -0.5, -0.5);
        
        // pixel grid
        context.beginPath();
        for(var i = pixel_size; i <= h; i += pixel_size) {
            context.moveTo(0.0, i);
            context.lineTo(w, i);
        }
        for(var j = pixel_size; j <= w; j += pixel_size) {
            context.moveTo(j, 0.0);
            context.lineTo(j, h);
        }
        context.strokeStyle="#AAAAAA";
        context.lineWidth=1;
        context.setLineDash([4, 4]);
        context.stroke();
        context.setLineDash([]);
        context.closePath();
    } else if(splixels.length > 0 && do_background) {
        // splixels
        var pixel_field = context.createImageData(w, h);
        for (var i = 0; i < pixel_field.data.length; i += 4) {
            var on_canvas_i = Math.floor(Math.floor(i / 4) / w)  + pixel_size / 2;
            var on_canvas_j = Math.floor(i / 4) % w  + pixel_size / 2;
            var in_pixels_i = Math.floor(on_canvas_i / pixel_size);
            var in_pixels_j = Math.floor(on_canvas_j / pixel_size);
            var splixel = splixel_in(splixels, in_pixels_i, in_pixels_j);
            var pixel_value = (splixel.to_margin == 1) ? 1 : ((splixel.to_margin == 0) ? 0.5 : 0.0);
            pixel_field.data[i + 0] = 0xAA + (0xFF - 0xAA) * pixel_value;
            pixel_field.data[i + 1] = 0xAA + (0xFF - 0xAA) * pixel_value;
            pixel_field.data[i + 2] = 0xFF;
            pixel_field.data[i + 3] = 0xFF;
        }
        context.putImageData(pixel_field, -0.5, -0.5);
    
        // splixel grid
        context.beginPath();
        for(var i = pixel_size / 2; i <= h; i += pixel_size) {
            context.moveTo(0.0, i);
            context.lineTo(w, i);
        }
        for(var j = pixel_size / 2; j <= w; j += pixel_size) {
            context.moveTo(j, 0.0);
            context.lineTo(j, h);
        }
        context.strokeStyle="#AAAAAA";
        context.lineWidth=1;
        context.setLineDash([4, 4]);
        context.stroke();
        context.setLineDash([]);
        context.closePath();    
    }
    
    // contour
    context.lineWidth = 3;
    if(splines.length > 0) {
        context.strokeStyle="#AA3366";
        draw_splines(context, splines);
    } else if(splixels.length > 0) {
        context.strokeStyle="#3366AA";
        draw_splixels(context, splixels);
    }

    if(splines.length > 0) {
        // points if needed
        if(document.getElementById("tool_2").checked) {
            var points = points_and_tangents[0];
            for(var i = 0; i < points.length; ++i) {
                for(var j = 0; j < 2; ++j) {
                    context.beginPath();
                    context.arc(pixel_size * points[i][j][0], pixel_size * points[i][j][1], 3, 0, 2*Math.PI);
                    context.fillStyle="#6633AA";
                    context.fill();
                    context.closePath();        
                }
            }
        }
        
        // tangents if needed
        if(document.getElementById("tool_3").checked) {
            var points = points_and_tangents[0];
            var tangents = points_and_tangents[1];
            for(var i = 0; i < points.length; ++i) {
                for(var j = 0; j < 2; ++j) {
                    context.beginPath();
                    context.arc(pixel_size * points[i][j][0], pixel_size * points[i][j][1], 3, 0, 2*Math.PI);
                    context.fillStyle="#AA3366";
                    context.fill();
                    context.closePath();
                    
                    context.beginPath();
                    context.lineWidth=1;
                    context.moveTo(pixel_size * points[i][j][0], pixel_size * points[i][j][1]);
                    context.lineTo(pixel_size * (points[i][j][0] + tangents[i][j][0]), pixel_size * (points[i][j][1] + tangents[i][j][1]));
                    context.strokeStyle="#6633AA";
                    context.setLineDash([2, 2]);
                    context.stroke();
                    context.setLineDash([]);
                    context.closePath();
                    
                    context.beginPath();
                    context.arc(
                        pixel_size * (points[i][j][0] + tangents[i][j][0]), 
                        pixel_size * (points[i][j][1] + tangents[i][j][1]), 3, 0, 2*Math.PI);
                    context.fillStyle="#6633AA";
                    context.fill();
                    context.closePath();        
                }
            }
        }
    }
}

function draw_arrow(context, x1, y1, x2, y2, color) {
    const length = 8;
    const width = 3;
    var d = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.moveTo(x2 - (y2 - y1) * width / d - (x2 - x1) * length / d, y2 - (y2 - y1) * length / d + (x2 - x1) * width / d);
    context.lineTo(x2, y2);
    context.moveTo(x2 + (y2 - y1) * width / d - (x2 - x1) * length / d, y2 - (y2 - y1) * length / d - (x2 - x1) * width / d);    
    context.lineTo(x2, y2);    
    context.strokeStyle = color;
    context.stroke();
    context.closePath();    
}

// import from PGM
function reimport_image() {
    space_divided = function(text) {
        var new_text = text.replace('\r', ' ');
        new_text = new_text.replace('\n', ' ');
        new_text = new_text.replace('\t', ' ');
        while(true) {
            new_new_text = new_text.replace('  ', ' ');
            if(new_new_text.length == new_text.length)
                return new_text;
            new_text = new_new_text;    
        }
    }
    var text = document.getElementById("import_PGM").value;
    document.getElementById("import_status").innerHTML = "";
    var lines = text.split("\n");
    var no_comments = []
    for(var i = 0; i < lines.length; ++i) {
        var new_line = lines[i].trim();
        if (new_line == "" || new_line[0] == '#')
            continue;
        no_comments.push(new_line);
    }
    var numbers = space_divided(no_comments.join(' ')).split(' ');
    if(numbers[0] != "P2") {
        document.getElementById("import_status").innerHTML = "Sorry, I can only import grayscale Netpbm (*.pgm = 'P2...')";
        return;
    }
    try {
        var new_w = parseInt(numbers[1]);
        var new_h = parseInt(numbers[2]);
        var new_depth = parseInt(numbers[3]);
        if(numbers.length > new_w * new_h + 4) {
            document.getElementById("import_status").innerHTML = "Sorry, there's some extra data I couldn't parse.";
            return;
        }
        if(numbers.length < new_w * new_h + 4) {
            document.getElementById("import_status").innerHTML = "Sorry, not enough data to form an image.";
            return;
        }
        h = 1024.0 * new_h / new_w;
        document.getElementById("canvas").height = h;
        pixel_size = w / new_w;
        reset_pixels(new_w, new_h);
        for(var i = 0; i < new_h; ++i)
            for(var j = 0; j < new_w; ++j)
                pixels[i][j] = parseInt(numbers[4 + i*new_w + j]) / new_depth;
        points_and_tangents = turn_pixels_into_points_and_tangents(pixels, threshold);
        splines = turn_points_and_tangents_into_splines(points_and_tangents);
    } catch (error) {
        document.getElementById("import_status").innerHTML = "Sorry, couldn't parse that. " + error.message;
    }
    draw_canvas(splines, []);  
}


// export to SVG
function export_splines() {
    const printable = function(x) {
        return Math.floor(x * 100);
    };
    var svg = "<?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n";
    svg += "<svg width=\"" + printable(pixels[0].length) + "\" height=\"" + printable(pixels.length);
    svg += "\" viewBox=\"0 0 " + printable(pixels[0].length) + " " + printable(pixels.length) + "\" xmlns=\"http://www.w3.org/2000/svg\">\n";
    for(var i = 0; i < points_and_tangents[0].length; ++i) {
        var p1 = points_and_tangents[0][i][0];
        var p2 = points_and_tangents[0][i][1];
        var p1_n = points_and_tangents[1][i][0];
        var p2_n = points_and_tangents[1][i][1];
        svg += "<path fill=\"none\" stroke=\"rgb(0,0,0)\" d=\"M " + printable(p1[0]) + "," + printable(p1[1]) + " ";
        svg += "C " + printable(p1[0] + p1_n[0] / 3.) + "," + printable(p1[1] + p1_n[1] / 3.); 
        svg += " " +  printable(p2[0] - p2_n[0] / 3.) + "," + printable(p2[1] - p2_n[1] / 3.) + " " + printable(p2[0]) + "," + printable(p2[1]) + "\"/>\n";
    }
    svg += "</svg>\n";
    document.getElementById("export_SVG").value = svg;
}

// ui
function reset_threshold() {
    threshold = parseFloat(document.getElementById("threshold").value);
}

// splixel algorithms
function splixel_in(splixels, i, j) {
    if(i < 0 || i >= splixels.length)
        return the_default_splixel
    if(j < 0 || j >= splixels[0].length)
        return the_default_splixel        
    return splixels[i][j];
}

function show_splixels() {
    var splixels = turn_pixels_into_splixels(pixels, threshold);
    draw_canvas([], splixels);
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
    
    var do_shifts = document.getElementById("show_shifts").checked;
    var do_normals = document.getElementById("show_normals").checked;
 
    context.lineWidth = 1;
    for(var i = 0; i < splixels.length; ++i)    
        for(var j = 0; j < splixels[0].length; ++j) {
            if(splixel_in(splixels, i, j).to_margin != 0)
                continue;
            var xy_shift = splixel_in(splixels, i, j).xy_shift;
            var xy_normal = splixel_in(splixels, i, j).xy_normal;
            if(do_shifts)
                draw_arrow(context, pixel_size * j, pixel_size * i, 
                    pixel_size * (j + xy_shift[0]), pixel_size * (i + xy_shift[1]), "#933");
            if(do_normals)
                draw_arrow(context, pixel_size * (j + xy_shift[0]), pixel_size * (i + xy_shift[1]),
                    pixel_size * (j + xy_shift[0] - xy_normal[0]), pixel_size * (i + xy_shift[1] - xy_normal[1]), "#339");
        }
}

function morph_splixels(morph_how) {
    var splixels = turn_pixels_into_splixels(pixels, threshold);
    
    // copy + morph
    var sw = splixels[0].length;
    var sh = splixels.length;
    var morphed_splixels = new_splixels(sh, sw);
    for(var i = 0; i < sh; ++i) {
        for(var j = 0; j < sw; ++j) {
            morphed_splixels[i][j].xy_shift = [0., 0.];   // initial value
            morphed_splixels[i][j].xy_normal = [0., 0.];  // initial value    
            var on_margin = 0;
            var in_margin = 0;
            var out_margin = 0;

            for(var ni = Math.max(0, i - 1); ni <= Math.min(sh - 1, i + 1); ++ni)
                for(var nj = Math.max(0, j - 1); nj <= Math.min(sw - 1, j + 1); ++nj)
                    if(i != ni || j != nj) {
                        if(splixels[ni][nj].to_margin == 0)
                            on_margin ++;
                        if(splixels[ni][nj].to_margin > 0)
                            in_margin ++;
                        if(splixels[ni][nj].to_margin < 0)
                            out_margin ++;
                    }
            if(morph_how == 'dilate') {
                if(splixels[i][j].to_margin == -1 && on_margin > 0)
                    morphed_splixels[i][j].to_margin = 0;
                else if(splixels[i][j].to_margin == 0)
                    morphed_splixels[i][j].to_margin = 1;
                else 
                    morphed_splixels[i][j].to_margin = splixels[i][j].to_margin;
            } else if(morph_how == 'erode') {
                if(splixels[i][j].to_margin == 1 && on_margin > 0)
                    morphed_splixels[i][j].to_margin = 0;
                else if(splixels[i][j].to_margin == 0)
                    morphed_splixels[i][j].to_margin = -1;
                else 
                    morphed_splixels[i][j].to_margin = splixels[i][j].to_margin;
            }
        }
    }
                    
    // reset neighbors
    for(var i = 1; i < sh; ++i) {
        for(var j = 1; j < sw; ++j) {
            if(morphed_splixels[i-1][j].to_margin == 0 && morphed_splixels[i][j].to_margin == 0 
              && (splixel_in(morphed_splixels, i, j-1).to_margin == 1 
                || splixel_in(morphed_splixels, i, j+1).to_margin == 1 
                || splixel_in(morphed_splixels, i-1, j-1).to_margin == 1 
                || splixel_in(morphed_splixels, i-1, j+1).to_margin == 1 )){
                morphed_splixels[i][j].top = true;
                morphed_splixels[i-1][j].bottom = true;
            }
            if(morphed_splixels[i][j-1].to_margin == 0 && morphed_splixels[i][j].to_margin == 0
              && (splixel_in(morphed_splixels, i-1, j).to_margin == 1 
                || splixel_in(morphed_splixels, i+1, j).to_margin == 1 
                || splixel_in(morphed_splixels, i-1, j-1).to_margin == 1 
                || splixel_in(morphed_splixels, i+1, j-1).to_margin == 1 )){
                morphed_splixels[i][j-1].right = true;
                morphed_splixels[i][j].left = true;
            }

        }        
    }
    
    function d2(xy) {
        return xy[0]*xy[0] + xy[1]*xy[1];
    }
    
    function normalized(xy) {
        const d = Math.sqrt(d2(xy));
        return [xy[0]/d, xy[1]/d];
    }
    var splines = 
        turn_points_and_tangents_into_splines(
            turn_splixels_into_points_and_tangents(splixels, threshold)); 
    const detail = 10; // probes per spline
    const dt = 0.001;
    for(var i = 0; i < splines.length; ++i) {
        for(var k = 0; k < detail; k += 1) {
            var t = (k) / detail;
            var x = polynomial_in_x(splines[i][0], t);
            var y = polynomial_in_x(splines[i][1], t);
            var dx = (polynomial_in_x(splines[i][0], t + dt) - x) / dt;
            var dy = (polynomial_in_x(splines[i][1], t + dt) - y) / dt;            
            var n1 = normalized([dy, -dx]);
            for(var offset = -1; offset <= 1; offset += 2) {
                var sx1 = [x + n1[0] * offset, y + n1[1] * offset];
                var bi = Math.floor(sx1[1]);
                var bj = Math.floor(sx1[0]);
                for(var di = -1; di <= 1; ++di) {
                    for(var dj = -1; dj <= 1; ++dj) {
                        if(Math.sign(di) == Math.sign(n1[1] * Math.sign(offset)) && Math.sign(dj) == Math.sign(n1[0] * Math.sign(offset)))
                            continue;
                        var i1 = bi + di;
                        var j1 = bj + dj;
                        if(i1 >= 0 && i1 < sh && j1 >= 0 && j1 < sw) {
                            var dx1 = sx1[0] - j1;
                            var dy1 = sx1[1] - i1;
                            if((morphed_splixels[i1][j1].xy_shift[0] == 0. && morphed_splixels[i1][j1].xy_shift[1] == 0.) 
                                    || d2(morphed_splixels[i1][j1].xy_shift) > d2([dx1, dy1])) {
                                morphed_splixels[i1][j1].xy_shift = [dx1, dy1];
                                morphed_splixels[i1][j1].xy_normal = [n1[0] * Math.sign(offset), n1[1] * Math.sign(offset)];
                            }
                        }
                    }
                }
            }
        }
    }
    
    // hack for when offset comes in between splixels (todo: reconsider as too narrow)
    for(var i = 1; i < sh; ++i) {
        for(var j = 1; j < sw; ++j) {
            if(morphed_splixels[i][j].to_margin == 0 && d2(morphed_splixels[i][j].xy_shift) == 0.) {                
                if(i > 0 && j > 0 && morphed_splixels[i-1][j-1].to_margin == -1 && d2(morphed_splixels[i-1][j-1].xy_shift) != 0.) {
                    morphed_splixels[i][j].xy_shift[0] = morphed_splixels[i-1][j-1].xy_shift[0] - 1.;
                    morphed_splixels[i][j].xy_shift[1] = morphed_splixels[i-1][j-1].xy_shift[1] - 1.;
                } else
                if(i > 0 && j < sw-1 && morphed_splixels[i-1][j+1].to_margin == -1 && d2(morphed_splixels[i-1][j+1].xy_shift) != 0.) {
                    morphed_splixels[i][j].xy_shift[0] = morphed_splixels[i-1][j+1].xy_shift[0] + 1.;
                    morphed_splixels[i][j].xy_shift[1] = morphed_splixels[i-1][j+1].xy_shift[1] - 1.;
                } else
                if(i < sh-1 && j < sw-1 && morphed_splixels[i+1][j+1].to_margin == -1 && d2(morphed_splixels[i+1][j+1].xy_shift) != 0.) {
                    morphed_splixels[i][j].xy_shift[0] = morphed_splixels[i+1][j+1].xy_shift[0] + 1.;
                    morphed_splixels[i][j].xy_shift[1] = morphed_splixels[i+1][j+1].xy_shift[1] + 1.;
                } else
                if(i < sh-1 && j > 0 && morphed_splixels[i+1][j-1].to_margin == -1 && d2(morphed_splixels[i+1][j-1].xy_shift) != 0.) {
                    morphed_splixels[i][j].xy_shift[0] = morphed_splixels[i+1][j-1].xy_shift[0] - 1.;
                    morphed_splixels[i][j].xy_shift[1] = morphed_splixels[i+1][j-1].xy_shift[1] + 1.;
                }
            }
        }
    }
                

    draw_canvas([], morphed_splixels);

    var do_shifts = document.getElementById("show_shifts").checked;
    var do_normals = document.getElementById("show_normals").checked;
    
    var canvas = document.getElementById("canvas");
    var context = canvas.getContext("2d");
    context.lineWidth = 1;
    for(var i = 0; i < morphed_splixels.length; ++i)    
        for(var j = 0; j < morphed_splixels[0].length; ++j) {
            /*if(splixel_in(morphed_splixels, i, j).to_margin != 0)
                continue;*/
            var xy_shift = splixel_in(morphed_splixels, i, j).xy_shift;
            var xy_normal = splixel_in(morphed_splixels, i, j).xy_normal;
            if(do_shifts)
                draw_arrow(context, pixel_size * j, pixel_size * i, 
                    pixel_size * (j + xy_shift[0]), pixel_size * (i + xy_shift[1]), "#933");
            if(do_normals)
                draw_arrow(context, pixel_size * (j + xy_shift[0]), pixel_size * (i + xy_shift[1]),
                    pixel_size * (j + xy_shift[0] - xy_normal[0]), pixel_size * (i + xy_shift[1] - xy_normal[1]), "#339");
        }
}

function cut_splixels() {
    var splixels = turn_pixels_into_splixels(pixels, threshold);
    
    // copy + morph
    var sw = splixels[0].length;
    var sh = splixels.length;
    var y_x = function(x){
        return (sh / 3. + (x / sw) * sh * 0.3);
    }
    var f = function (x, y) { return y > y_x(x);}
    var t = function (x, y) { return !f(x, y);}
    var cut_splixels = new_splixels(sh, sw);
    for(var i = 0; i < sh; ++i) {
        for(var j = 0; j < sw; ++j) {
            if(f(j - 0.5, i - 0.5) && f(j + 0.5, i - 0.5) && f(j - 0.5, i + 0.5) && f(j + 0.5, i + 0.5)) {
                cut_splixels[i][j].to_margin = splixels[i][j].to_margin;
                cut_splixels[i][j].xy_shift = splixels[i][j].xy_shift.slice();
                cut_splixels[i][j].xy_normal = splixels[i][j].xy_normal.slice();
                cut_splixels[i][j].right = splixels[i][j].right;
                cut_splixels[i][j].left = splixels[i][j].left;
                cut_splixels[i][j].top = splixels[i][j].top;
                cut_splixels[i][j].bottom = splixels[i][j].bottom;
            } else if(t(j - 0.5, i - 0.5) && t(j + 0.5, i - 0.5) && t(j - 0.5, i + 0.5) && t(j + 0.5, i + 0.5)) {
                cut_splixels[i][j].to_margin = -1;
                cut_splixels[i][j].xy_shift = [0, 0];
                cut_splixels[i][j].xy_normal = [0, 0];
            } else {
                if(splixels[i][j].to_margin == -1) {
                    cut_splixels[i][j].to_margin = -1;
                    cut_splixels[i][j].xy_shift = [0, 0];
                    cut_splixels[i][j].xy_normal = [0, 0];
                } else if(splixels[i][j].to_margin == 1){
                    cut_splixels[i][j].to_margin = 0;
                    cut_splixels[i][j].xy_shift = [0, y_x(j) - i];
                    cut_splixels[i][j].xy_normal = [0, 0];                    
                } else if(splixels[i][j].to_margin == 0){
                    cut_splixels[i][j].to_margin = 0;
                    cut_splixels[i][j].xy_shift = [0, y_x(j) - i];
                    cut_splixels[i][j].xy_normal = [0, 0];                    
                }
            }
        }
    }

    // reset neighbors
    for(var i = 1; i < sh; ++i) {
        for(var j = 1; j < sw; ++j) {
            if(cut_splixels[i-1][j].to_margin == 0 && cut_splixels[i][j].to_margin == 0 
              && (splixel_in(cut_splixels, i, j-1).to_margin == 1 
                || splixel_in(cut_splixels, i, j+1).to_margin == 1 
                || splixel_in(cut_splixels, i-1, j-1).to_margin == 1 
                || splixel_in(cut_splixels, i-1, j+1).to_margin == 1 )){
                cut_splixels[i][j].top = true;
                cut_splixels[i-1][j].bottom = true;
            }
            if(cut_splixels[i][j-1].to_margin == 0 && cut_splixels[i][j].to_margin == 0
              && (splixel_in(cut_splixels, i-1, j).to_margin == 1 
                || splixel_in(cut_splixels, i+1, j).to_margin == 1 
                || splixel_in(cut_splixels, i-1, j-1).to_margin == 1 
                || splixel_in(cut_splixels, i+1, j-1).to_margin == 1 )){
                cut_splixels[i][j-1].right = true;
                cut_splixels[i][j].left = true;
            }

        }        
    }
    
    draw_canvas([], cut_splixels);
}
  </script>
  </head>
  <body>
    <center>
    <h1>
image -> splixels -operations-> splixels
    </h1>
    <h2>
Import PGM    
    </h2>
    <textarea id="import_PGM" rows=20>
P2
# CREATOR: GIMP PNM Filter Version 1.1
16 16
255
0   0   0   0   0   0   1   2   2   1   0   0   0   0   0   0   
0   0   0   0   0   22  42  52  52  42  22  0   0   0   0   0   
0   0   0   10  52  96  122 140 140 122 96  52  10  0   0   0   
0   0   10  66  121 170 193 202 202 193 170 121 66  10  0   0   
0   0   52  121 181 211 222 226 226 222 211 181 121 52  0   0   
0   22  96  170 211 226 231 234 234 231 226 211 170 96  22  0   
1   42  122 193 222 231 235 237 237 235 231 222 193 122 42  1   
2   52  140 202 226 234 237 238 238 237 234 226 202 140 52  2   
2   52  140 202 226 234 237 238 238 237 234 226 202 140 52  2   
1   42  122 193 222 231 235 237 237 235 231 222 193 122 42  1   
0   22  96  170 211 226 231 234 234 231 226 211 170 96  22  0   
0   0   52  121 181 211 222 226 226 222 211 181 121 52  0   0   
0   0   10  66  121 170 193 202 202 193 170 121 66  10  0   0   
0   0   0   10  52  96  122 140 140 122 96  52  10  0   0   0   
0   0   0   0   0   22  42  52  52  42  22  0   0   0   0   0   
0   0   0   0   0   0   1   2   2   1   0   0   0   0   0   0   
    </textarea>
    <form>
        Grey value threshold: <input type="text" id="threshold" value="0.5">
        <button type="button" style="width: 200pt;" onclick="reset_threshold(); reimport_image()">Reimport the PGM</button> 
    </form>
    <p id="import_status" class="comment">
    </p>
    <br>
    <h2>
Splixels
    </h2>
    <canvas id="canvas" width=1024 height=1024></canvas>
    <form>
    <div style="visibility: hidden;">
        Click to change: 
        <input type="radio" name="tool" id="tool_1" value="image" checked=true onclick="draw_canvas(splines, [])"><label for="tool_1">image; </label>
        <input type="radio" name="tool" id="tool_2" value="points" onclick="draw_canvas(splines, [])"><label for="tool_2">points; </label>
        <input type="radio" name="tool" id="tool_3" value="tangents" onclick="draw_canvas(splines, [])"><label for="tool_3">tangents; </label>
        <br> 
    </div>
    <button type="button" style="width: 200pt;" onclick="show_splixels();">Show the splixels</button>
    <br>
    <button type="button" style="width: 200pt;" onclick="morph_splixels('dilate');">Dilate the splixels</button>
    <button type="button" style="width: 200pt;" onclick="morph_splixels('erode');">Erode the splixels</button>
    <button type="button" style="width: 200pt;" onclick="cut_splixels();">Cut the splixels</button>
    <br>
    <input type="checkbox" id="show_shifts"/><label for="show_shifts">show shifts</label> 
    <input type="checkbox" id="show_normals"/><label for="show_normals">show normals</label> 
    <input type="checkbox" id="show_background" checked="true"/><label for="show_background">show background</label> 
    <br>
    </form>

    <script language="JavaScript">
    reimport_image();    
    show_splixels();
    </script>

    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
    <tr>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
        <a href="index.html">&nbsp;&larr; back to index.</a>
    </td>
    </tr>
    </table>

    
    </center>
  </body>
</html>
