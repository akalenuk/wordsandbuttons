<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SWInE: simplicial weight interpolation and extrapolation</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body {
    margin: 0 0 0 0;
}

a {
    text-decoration: none;
}

h1 {
    padding-top: 36pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 20pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    line-height: 1.42;
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.formula {
    font-family: sans-serif;
    font-size: 15pt;
    font-style: italic;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

table.footer {
    padding: 64pt 0pt 32pt 0pt;
    background-color: transparent;
    width: 505pt;
}

td.footer {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: normal;
    padding: 0;
    margin: 0;
    border: 0;
}

li {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
    padding-bottom: 6pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
}

.hpok {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #99ee99;
    display: none;
}

.score {
    font-size: 48pt;
    padding-top: 12pt;
    padding-bottom: 12pt;
    text-align: center;
}

input[type="text"] {
    width: 32pt;
    height: 22pt;
    font-size: 16pt;
    text-align: center;
}

button {
    width: 32pt;
    height: 26pt;
    font-size: 16pt;
    text-align: center;
}
    </style>
    <script language="JavaScript">
// client
const w = 640.0;
const h = 640.0;

//// 2d
// visible region (these are purely cosmetic, the real numbers are client)
var x2d_min = -1.0;
var y2d_min = -1.0;
var x2d_max = 4.0;
var y2d_max = 4.0;

var client_x2d_center = w*(0-x2d_min)/(x2d_max-x2d_min);
var client_x2d_step = (w/(x2d_max-x2d_min));

var client_y2d_center = h - h*(0-y2d_min)/(y2d_max-y2d_min);
var client_y2d_step = (h/(y2d_max-y2d_min));

function draw_grid_on(context){
    // grid
    context.font = "16px sans-serif";
    context.beginPath();
    context.moveTo(0, client_y2d_center);
    context.lineTo(w, client_y2d_center);
    context.lineTo(w - 12, client_y2d_center - 5);
    context.moveTo(w, client_y2d_center);
    context.lineTo(w - 12, client_y2d_center + 5);
    context.moveTo(client_x2d_center, h);
    context.lineTo(client_x2d_center, 0);
    context.lineTo(client_x2d_center - 5, 12);
    context.moveTo(client_x2d_center, 0);
    context.lineTo(client_x2d_center + 5, 12);
    context.fillStyle="#000000";
    for(var i = x2d_min + 1; i <= x2d_max - 1; i++){
        if(i != 0) {
            context.moveTo(client_x2d_center + i*client_x2d_step, client_y2d_center);
            context.lineTo(client_x2d_center + i*client_x2d_step, client_y2d_center - 5);
            context.fillText(i, client_x2d_center + i*client_x2d_step + 4, client_y2d_center + 16);
        }
    }
    for(var i = y2d_min + 1; i <= y2d_max - 1; i++){
        if(i != 0) {
            context.moveTo(client_x2d_center, client_y2d_center - i*client_y2d_step);
            context.lineTo(client_x2d_center + 5, client_y2d_center - i*client_y2d_step);
        }
        context.fillText(i, client_x2d_center + 5, client_y2d_center - i*client_y2d_step + 16);
    }
    context.strokeStyle = "#000000";
    context.stroke();
    context.closePath();
}

function closest_point_starting_from(x, y, xs, ys, i) {
    for(var j = i + 1; j < xs.length; ++j)
        if(d2(x, y, xs[j], ys[j]) < d2(x, y, xs[i], ys[i]))
            return closest_point_starting_from(x, y, xs, ys, j);
    return i;
}

// finds a closest point from xs, ys to x, y
function closest_point(x, y, xs, ys){
    return closest_point_starting_from(x, y, xs, ys, 0);
}



// weights
var weight2d1 = 2;
const wf2d1 = function(x) {return 1./Math.pow(x, weight2d1);}
var weight2d2 = 2;
const wf2d2 = function(x) {return 1./Math.pow(x, weight2d2);}

// interpolation/extrapolation with no basis functions
function ie_no_basis(x, xs, ys) {
    if(x < xs[0])
        return ys[0];
    if(x > xs[xs.length- 1])
        return ys[xs.length - 1];

    var i = 0;
    for(var j = 0; j < xs.length; ++j)
        if(x > xs[j])
            i = j;
    return (ys[i] * wf2d1(x - xs[i]) + ys[i+1] * wf2d1(xs[i+1] - x))
        / (wf2d1(x - xs[i]) + wf2d1(xs[i+1] - x));
}

// interpolation/extrapolation with basis functions
function ie_basis(x, xs, bs) {
    if(x < xs[0])
        return bs[0](x);
    if(x > xs[xs.length- 1])
        return bs[xs.length - 1](x);

    var i = 0;
    for(var j = 0; j < xs.length; ++j)
        if(x > xs[j])
            i = j;
    return (bs[i](x) * wf2d2(x - xs[i]) + bs[i+1](x) * wf2d2(xs[i+1] - x))
        / (wf2d2(x - xs[i]) + wf2d2(xs[i+1] - x));
}

// returns [a, b] for ax+b basis function
function linear_basis(x1, y1, x2, y2) {
    /*
    x1, y1, x2, y2, a, b = symbols('x1 y1 x2 y2 a b')
    print(solve([
        a * x1 + b - y1,
        a * x2 + b - y2
        ], (a, b)))
    */
    const ab = [(y1 - y2)/(x1 - x2), (x1*y2 - x2*y1)/(x1 - x2)];
    // constant degeneration check
    if(Math.abs(ab[0]) < 1e-2) {
        document.getElementById('hpok5').style.display = "block";
        count_score();
    }
    return ab
}

// fits linear functon to go trough the point (retaining the slope)
function fit_linear_to(basis, x, y) {
    const delta_b = y - (basis[0] * x + basis[1]);
    return [basis[0], basis[1] + delta_b];
}

// returns [a, b, c] for a*x*x + b*x + c
function quadratic_basis(x1, y1, x2, y2, x3, y3) {
    /*
    x1, y1, x2, y2, x3, y3, a, b, c = symbols('x1 y1 x2 y2 x3 y3 a b c')

    print(solve([
        a * x1 * x1 + b * x1 + c - y1,
        a * x2 * x2 + b * x2 + c - y2,
        a * x3 * x3 + b * x3 + c - y3,
        ], (a, b, c)))
    */
    const abc = [
        (y1*(x2 - x3) - y2*(x1 - x3) + y3*(x1 - x2))/(x1*x1*x2 - x1*x1*x3 - x1*x2*x2 + x1*x3*x3 + x2*x2*x3 - x2*x3*x3),
        (-y1*(x2*x2 - x3*x3) + y2*(x1*x1 - x3*x3) - y3*(x1*x1 - x2*x2))/(x1*x1*x2 - x1*x1*x3 - x1*x2*x2 + x1*x3*x3 + x2*x2*x3 - x2*x3*x3),
        (x1*x2*y3*(x1 - x2) - x1*x3*y2*(x1 - x3) + x2*x3*y1*(x2 - x3))/(x1*x1*x2 - x1*x1*x3 - x1*x2*x2 + x1*x3*x3 + x2*x2*x3 - x2*x3*x3)
    ];
    // constant degeneration check
    if(Math.abs(abc[0]) < 1e-2 && Math.abs(abc[1]) < 1e-2) {
        document.getElementById('hpok5').style.display = "block";
        count_score();
    }
    return abc;
}

var x2s1 = [128*2, 128*4];
var y2s1 = [128*3, 128*1];

var x2s2 = [128*1, 128*2, 128*3, 128*4];
var y2s2 = [128*2, 128*1, 128*2.5, 128*3];

function order_points_s1() {
    if(x2s1[0] > x2s1[1]) {
        x = x2s1[0];
        y = y2s1[0];
        x2s1[0] = x2s1[1];
        y2s1[0] = y2s1[1];
        x2s1[1] = x;
        y2s1[1] = y;
    }
}

function init_canvas2d1() {
    var canvas = document.getElementById("canvas2d1");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        const point_i = closest_point(x, y, x2s1, y2s1);
        x2s1[point_i] = x;
        y2s1[point_i] = y;
        order_points_s1();
        draw_canvas2d1(0, 0, false);
    }, false);

    canvas.addEventListener('mousemove', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        if(e.buttons == 1){
            const point_i = closest_point(x, y, x2s1, y2s1);
            x2s1[point_i] = x;
            y2s1[point_i] = y;
            order_points_s1();
            draw_canvas2d1(0, 0, false);
        } else {
            draw_canvas2d1(x, y, true);
        }
    }, false);

    canvas.addEventListener('mouseup', function(e){
        order_points_s1();
        draw_canvas2d1(0, 0, false);
    }, false);

    canvas.addEventListener('mouseleave', function(e){
        draw_canvas2d1(0, 0, false);
    }, false);

    draw_canvas2d1();
}

function draw_canvas2d1(client_x, client_y, do_guides){
    var canvas = document.getElementById("canvas2d1");
    var context = canvas.getContext("2d");

    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    const do_interpolation = document.getElementById("i").checked || document.getElementById("ie").checked;
    const do_extrapolation = document.getElementById("e").checked || document.getElementById("ie").checked;
    // interpolation/extrapolation
    context.strokeStyle="#888888";
    context.lineWidth = 3;
    context.beginPath()
    for(var i = 0; i < w; ++i) {
        var do_segment =  ((i < x2s1[0]-1 || i > x2s1[x2s1.length - 1]) && do_extrapolation)
                       || ((i >= x2s1[0]-1 && i <= x2s1[x2s1.length - 1]) && do_interpolation);
        if(do_segment) {
            const y1 = ie_no_basis(i, x2s1, y2s1);
            const y2 = ie_no_basis(i+1, x2s1, y2s1);
            if((Math.abs(i + 1 - x2s1[0]) <= 0.5 || Math.abs(i - x2s1[1]) <= 0.5) && Math.abs(y1 - y2) > 4)
                continue; // ironic, since this is the function's discontinuity
            context.moveTo(i, y1);
            context.lineTo(i+1, y2);
        }
    }
    context.stroke();
    context.closePath();
    context.lineWidth = 1;

    // grid
    draw_grid_on(context);

    // dots
    context.strokeStyle="#f71134";
    for(var i = 0; i <= x2s1.length; ++i){
        context.beginPath();
        context.arc(x2s1[i], y2s1[i], 4, 0, 2*Math.PI);
        context.stroke();
        context.closePath();
    }

    // guides
    if(do_guides){
        const point_i = closest_point(client_x, client_y, x2s1, y2s1);
        draw_arrow(context, x2s1[point_i], y2s1[point_i], client_x, client_y);
    }
}

var basis2d = [];
function recalculate_basis2d() {
    /*
    cccc onstant-constant-constant-constant
    cllc constant-linear-linear-constant
    llll linear-linear-linear-linear
    cqqc constant-quadratic-quadratic-constant
    lqql linear-quadratic-quadratic-linear
    qqqq quadratic-quadratic-quadratic-quadratic
    */
    if(document.getElementById("cccc").checked) {
        basis2d[0] = function(x) {return y2s2[0];};
        basis2d[1] = function(x) {return y2s2[1];};
        basis2d[2] = function(x) {return y2s2[2];};
        basis2d[3] = function(x) {return y2s2[3];};
    } else if(document.getElementById("cllc").checked) {
        const b1 = fit_linear_to(linear_basis(x2s2[0], y2s2[0], x2s2[2], y2s2[2]), x2s2[1], y2s2[1]);
        const b2 = fit_linear_to(linear_basis(x2s2[1], y2s2[1], x2s2[3], y2s2[3]), x2s2[2], y2s2[2]);
        basis2d[0] = function(x) {return y2s2[0];};
        basis2d[1] = function(x) {return b1[0]*x + b1[1];};
        basis2d[2] = function(x) {return b2[0]*x + b2[1];};
        basis2d[3] = function(x) {return y2s2[3];};
    } else if(document.getElementById("llll").checked) {
        const b0 = linear_basis(x2s2[0], y2s2[0], x2s2[1], y2s2[1]);
        const b1 = fit_linear_to(linear_basis(x2s2[0], y2s2[0], x2s2[2], y2s2[2]), x2s2[1], y2s2[1]);
        const b2 = fit_linear_to(linear_basis(x2s2[1], y2s2[1], x2s2[3], y2s2[3]), x2s2[2], y2s2[2]);
        const b3 = linear_basis(x2s2[2], y2s2[2], x2s2[3], y2s2[3]);
        basis2d[0] = function(x) {return b0[0]*x + b0[1];};
        basis2d[1] = function(x) {return b1[0]*x + b1[1];};
        basis2d[2] = function(x) {return b2[0]*x + b2[1];};
        basis2d[3] = function(x) {return b3[0]*x + b3[1];};
    } else if(document.getElementById("cqqc").checked) {
        const b1 = quadratic_basis(x2s2[0], y2s2[0], x2s2[1], y2s2[1], x2s2[2], y2s2[2]);
        const b2 = quadratic_basis(x2s2[1], y2s2[1], x2s2[2], y2s2[2], x2s2[3], y2s2[3]);
        basis2d[0] = function(x) {return y2s2[0];};
        basis2d[1] = function(x) {return b1[0]*x*x + b1[1]*x + b1[2];};
        basis2d[2] = function(x) {return b2[0]*x*x + b2[1]*x + b2[2];};
        basis2d[3] = function(x) {return y2s2[3];};
    } else if(document.getElementById("lqql").checked) {
        const b0 = linear_basis(x2s2[0], y2s2[0], x2s2[1], y2s2[1]);
        const b1 = quadratic_basis(x2s2[0], y2s2[0], x2s2[1], y2s2[1], x2s2[2], y2s2[2]);
        const b2 = quadratic_basis(x2s2[1], y2s2[1], x2s2[2], y2s2[2], x2s2[3], y2s2[3]);
        const b3 = linear_basis(x2s2[2], y2s2[2], x2s2[3], y2s2[3]);
        basis2d[0] = function(x) {return b0[0]*x + b0[1];};
        basis2d[1] = function(x) {return b1[0]*x*x + b1[1]*x + b1[2];};
        basis2d[2] = function(x) {return b2[0]*x*x + b2[1]*x + b2[2];};
        basis2d[3] = function(x) {return b3[0]*x + b3[1];};
    } else if(document.getElementById("qqqq").checked) {
        const b1 = quadratic_basis(x2s2[0], y2s2[0], x2s2[1], y2s2[1], x2s2[2], y2s2[2]);
        const b2 = quadratic_basis(x2s2[1], y2s2[1], x2s2[2], y2s2[2], x2s2[3], y2s2[3]);
        basis2d[0] = function(x) {return b1[0]*x*x + b1[1]*x + b1[2];};
        basis2d[1] = function(x) {return b1[0]*x*x + b1[1]*x + b1[2];};
        basis2d[2] = function(x) {return b2[0]*x*x + b2[1]*x + b2[2];};
        basis2d[3] = function(x) {return b2[0]*x*x + b2[1]*x + b2[2];};
    }
    // x-order post-check
    for(var i = 1; i < x2s2.length; ++i)
        if(x2s2[i-1] >= x2s2[i]) {
            document.getElementById('hpok4').style.display = "block";
            count_score();
        }
}

function init_canvas2d2(){
    var canvas = document.getElementById("canvas2d2");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        const point_i = closest_point(x, y, x2s2, y2s2);
        x2s2[point_i] = x;
        y2s2[point_i] = y;
        recalculate_basis2d();
        draw_canvas2d2(0, 0, false);
    }, false);

    canvas.addEventListener('mousemove', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        if(e.buttons == 1){
            const point_i = closest_point(x, y, x2s2, y2s2);
            x2s2[point_i] = x;
            y2s2[point_i] = y;
            recalculate_basis2d();
            draw_canvas2d2(0, 0, false);
        } else {
            draw_canvas2d2(x, y, true);
        }
    }, false);

    canvas.addEventListener('mouseup', function(e){
        draw_canvas2d2(0, 0, false);
    }, false);

    canvas.addEventListener('mouseleave', function(e){
        draw_canvas2d2(0, 0, false);
    }, false);

    recalculate_basis2d();
    draw_canvas2d2();
}

function draw_canvas2d2(client_x, client_y, do_guides){
    var canvas = document.getElementById("canvas2d2");
    var context = canvas.getContext("2d");

    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // interpolation/extrapolation
    context.strokeStyle="#888888";
    context.lineWidth = 3;
    context.beginPath()
    for(var i = 0; i < w; ++i) {
        const y1 = ie_basis(i, x2s2, basis2d);
        const y2 = ie_basis(i+1, x2s2, basis2d);
        context.moveTo(i, y1);
        context.lineTo(i+1, y2);
    }
    context.stroke();
    context.closePath();
    context.lineWidth = 1;

    // basis
    context.strokeStyle="#f71134";
    for(var j = 0; j < x2s2.length; ++j) {
        context.beginPath()
        for(var i = 0; i < w; ++i) {
            if(Math.abs(i - x2s2[j]) < 64) {
                const y1 = basis2d[j](i);
                const y2 = basis2d[j](i+1);
                context.moveTo(i, y1);
                context.lineTo(i+1, y2);
            }
        }
        context.stroke();
        context.closePath();
    }

    // grid
    draw_grid_on(context);

    // dots
    context.strokeStyle="#f71134";
    for(var i = 0; i <= x2s2.length; ++i){
        context.beginPath();
        context.arc(x2s2[i], y2s2[i], 4, 0, 2*Math.PI);
        context.stroke();
        context.closePath();
    }

    // guides
    if(do_guides){
        const point_i = closest_point(client_x, client_y, x2s2, y2s2);
        draw_arrow(context, x2s2[point_i], y2s2[point_i], client_x, client_y);
    }
}


//// 3d
// points
const a = 256;
var x3s = [-1, 320   , 320 - a/2, 320 + a/2, 320 + a, 320 + a/2, 320 - a/2, 320 - a];
var y3s = [-1, 320   , 320 - a  , 320 - a  , 320    , 320 + a  , 320 + a  , 320    ];
var z3s = [-1, 8*4+4 , 8*16+4   , 8*28+4   , 8*12+4 , 8*20+4   , 8*24+4   , 8*8+4  ];
// triangles' points are ordered clockwise
var tris = [[2, 3, 1], [3, 4, 1], [4, 5, 1], [5, 6, 1], [6, 7, 1], [7, 2, 1]];

// weight funtion
var weight3d = 2;
const wf = function(x) {return 1./Math.pow(x, weight3d);}


// finds a closest point from x3s, y3s to x, y
function closest_3d_point(x, y){
    return closest_point_starting_from(x, y, x3s, y3s, 1);
}

// point belongs to a triangle
function in_tri(px, py, x1, y1, x2, y2, x3, y3) {
    /* shove it into sympy to get solution
    px, py, x1, y1, x2, y2, x3, y3, a, b = symbols('px py x1 y1 x2 y2 x3 y3 a b')
    solve([
    x1 + a * (x2-x1) + b * (x3-x1) - px,
    y1 + a * (y2-y1) + b * (y3-y1) - py
    ], (a, b))
    */
    var d = 1.0 / ((x1 - x2)*(y1 - y3) - (x1 - x3)*(y1 - y2));
    var a = (-(px - x1)*(y1 - y3) + (py - y1)*(x1 - x3)) * d;
    var b = ((px - x1)*(y1 - y2) - (py - y1)*(x1 - x2)) * d;
    return (a >= 0 && b >= 0 && a + b <= 1.);
}

// point projection belongs to an edge
function in_edge(px, py, x1, y1, x2, y2) {
    if((px-x1)*(y2-y1)-(py-y1)*(x2-x1) < 0) // border should be ordered for that
        return false;
    /*
    px, py, x1, y1, x2, y2, a = symbols('px py x1 y1 x2 y2 a')
    solve([(x1 + (x2 - x1) * a - px) * (x2 - x1) + (y1 + (y2 - y1) * a - py) * (y2 - y1)], (a))
    */
    var a = (-px*x1 + px*x2 - py*y1 + py*y2 + x1*x1 - x1*x2 + y1*y1 - y1*y2)/(x1*x1 - 2*x1*x2 + x2*x2 + y1*y1 - 2*y1*y2 + y2*y2);
    return (a > 0 && a < 1);
}

// distance squared from (x1, y1) to (x2, y2)
function d2(x1, y1, x2, y2) {
    return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);
}

// project point on edge
function projected_on_edge(px, py, x1, y1, x2, y2) {
     /*
    px, py, x1, y1, x2, y2, a = symbols('px py x1 y1 x2 y2 a')
    solve([(x1 + (x2 - x1) * a - px) * (x2 - x1) + (y1 + (y2 - y1) * a - py) * (y2 - y1)], (a))
    */
    var a = (-px*x1 + px*x2 - py*y1 + py*y2 + x1*x1 - x1*x2 + y1*y1 - y1*y2)/(x1*x1 - 2*x1*x2 + x2*x2 + y1*y1 - 2*y1*y2 + y2*y2);
    return [x1 + (x2 - x1) * a, y1 + (y2 - y1) * a];
}

// distance from (x1, y1) to (x2, y2)
function d(x1, y1, x2, y2) {
    return Math.sqrt(d2(x1, y1, x2, y2));
}

// distance from (x, y) to edge [(x1, y1), (x2, y2)]
function d_e(x, y, x1, y1, x2, y2) {
    const dxe = x2-x1;
    const dye = y2-y1;
    const dx = x-x1;
    const dy = y-y1;
    const area = Math.abs(dxe*dy - dye*dx);
    return area / d(x1, y1, x2, y2);
}

const d_min = 1e-5; // too close

// interpolation on the edge
function z_in_edge(px, py, x1, y1, z1, x2, y2, z2) {
    const pp = projected_on_edge(px, py, x1, y1, x2, y2);
    const d1 = d(pp[0], pp[1], x1, y1);
    const d2 = d(pp[0], pp[1], x2, y2);
    if(d1 < d_min)
        return z1;
    if(d2 < d_min)
        return z2;
    return (z1 * wf(d1) + z2 * wf(d2)) / (wf(d1) + wf(d2));
}

function z_in_edge_by_basis(px, py, x1, y1, b1, x2, y2, b2) {
    const pp = projected_on_edge(px, py, x1, y1, x2, y2);
    const d1 = d(pp[0], pp[1], x1, y1);
    const d2 = d(pp[0], pp[1], x2, y2);
    if(d1 < d_min)
        return b1(x1, y1);
    if(d2 < d_min)
        return b2(x2, y2);
    return (b1(px, py) * wf(d1) + b2(px, py) * wf(d2)) / (wf(d1) + wf(d2));
}

// interpolation in tri
function z_in_tri(px, py, x1, y1, z1, x2, y2, z2, x3, y3, z3) {
    const d1 = d_e(px, py, x1, y1, x2, y2);
    const d2 = d_e(px, py, x2, y2, x3, y3);
    const d3 = d_e(px, py, x3, y3, x1, y1);
    if(d1 < d_min)
        return z_in_edge(px, py, x1, y1, z1, x2, y2, z2);
    if(d2 < d_min)
        return z_in_edge(px, py, x2, y2, z2, x3, y3, z3);
    if(d3 < d_min)
        return z_in_edge(px, py, x3, y3, z3, x1, y1, z1);
    return (z_in_edge(px, py, x1, y1, z1, x2, y2, z2) * wf(d1)
          + z_in_edge(px, py, x2, y2, z2, x3, y3, z3) * wf(d2)
          + z_in_edge(px, py, x3, y3, z3, x1, y1, z1) * wf(d3))
        / (wf(d1) + wf(d2) + wf(d3));
}

function z_in_tri_by_basis(px, py, x1, y1, b1, x2, y2, b2, x3, y3, b3) {
    const d1 = d_e(px, py, x1, y1, x2, y2);
    const d2 = d_e(px, py, x2, y2, x3, y3);
    const d3 = d_e(px, py, x3, y3, x1, y1);
    if(d1 < d_min)
        return z_in_edge_by_basis(px, py, x1, y1, b1, x2, y2, b2);
    if(d2 < d_min)
        return z_in_edge_by_basis(px, py, x2, y2, b2, x3, y3, b3);
    if(d3 < d_min)
        return z_in_edge_by_basis(px, py, x3, y3, b3, x1, y1, b1);
    return (z_in_edge_by_basis(px, py, x1, y1, b1, x2, y2, b2) * wf(d1)
          + z_in_edge_by_basis(px, py, x2, y2, b2, x3, y3, b3) * wf(d2)
          + z_in_edge_by_basis(px, py, x3, y3, b3, x1, y1, b1) * wf(d3))
        / (wf(d1) + wf(d2) + wf(d3));
}

// approximator (used to build a linear basis)
function solved_linear(A, B, n){
    function underflow_padded(x){
        function sign_0_positive(x){ // Math.sign like with no 0 option
            if(x >= 0)
                return 1.0;
            return -1.0;
        }
        if(Math.abs(x) < 1.e-5) // pixel-size input error is ok, so we don't want much precision anyway
            return 1.e-5 * sign_0_positive(x);
        return x;
    }
    var X = [];
    for (var i = 0; i < n; ++i)
        X.push(0.0);

    // triangulize
    for (var i = 0; i < n-1; ++i)
        for (var j = 0; j < i+1; ++j) {
            r = A[i+1][j] / underflow_padded(A[j][j]);
            A[i+1][j] = 0.;
            for (var b_j = j+1; b_j < n; ++b_j){
                A[i+1][b_j] -= A[j][b_j]*r;
            }
            B[i+1] -= B[j]*r;
        }

    // calculate xs
    X[n-1] = B[n-1] / underflow_padded(A[n-1][n-1]);
    for (var i = n-2; i >= 0; --i){
        var s = 0.0;
        for (var j = i; j < n; ++j){
            s = s + A[i][j]*X[j];
        }
        X[i] = (B[i] - s) / underflow_padded(A[i][i]);
    }
    return X;
}

function approximation_polynomial_coefficients_for(points, n) {
    const N = points.length;
    var A = [];
    var B = [];

    for (var i = 0; i < n; ++i){
        var Ai = []
        for (var j = 0; j < n; ++j){
            Ai.push(0);
            for(var k = 0; k < N; ++k){
                Ai[j] += Math.pow(points[k][0], i + j);
            }
        }
        A.push(Ai);
        B.push(0);
        for(var k = 0; k < N; ++k){
            B[i] += points[k][1] * Math.pow(points[k][0], i);
        }
    }
    return solved_linear(A, B, n);
}

function init_canvas3d(){
    var canvas = document.getElementById("canvas3d");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        const point_i = closest_3d_point(x, y);
        x3s[point_i] = x;
        y3s[point_i] = y;
        compute_edges_and_z_field();
        draw_canvas3d(0, 0, false);
    }, false);

    canvas.addEventListener('mousemove', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        if(e.buttons == 1){
            const point_i = closest_3d_point(x, y);
            x3s[point_i] = x;
            y3s[point_i] = y;
            compute_edges_and_z_field();
            draw_canvas3d(0, 0, false);
        } else {
            draw_canvas3d(x, y, true);
        }
    }, false);

    canvas.addEventListener('mouseup', function(e){
        draw_canvas3d(0, 0, false);
    }, false);

    canvas.addEventListener('mouseleave', function(e){
        draw_canvas3d(0, 0, false);
    }, false);

    compute_edges_and_z_field();
    draw_canvas3d();
}

function draw_arrow(context, x1, y1, x2, y2) {
    var d = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.moveTo(x2 - (y2 - y1) * 6 / d - (x2 - x1) * 16 / d, y2 - (y2 - y1) * 16 / d + (x2 - x1) * 6 / d);
    context.lineTo(x2, y2);
    context.moveTo(x2 + (y2 - y1) * 6 / d - (x2 - x1) * 16 / d, y2 - (y2 - y1) * 16 / d - (x2 - x1) * 6 / d);
    context.lineTo(x2, y2);
    context.stroke();
    context.closePath();
}

// these hacks are here to store edges in sets
function edge_as_number(edge) {
    return edge[0] * 10000 + edge[1];
}

function number_as_edge(number) {
    return [Math.floor(number / 10000), number % 10000];
}

var edges = [];
var basis_3d = [];
var z_field = [];
const Z_NOT_DETERMINED = Number.NEGATIVE_INFINITY;
const Z_NOT_APLICABLE = Number.POSITIVE_INFINITY;
function compute_edges_and_z_field() {
    // compute all edges
    var all_edges = new Set();
    var inner_edges = new Set();
    for(var i = 0; i < tris.length; ++i) {
        for(var j = 0; j < 3; ++j) {
            const i1 = tris[i][j % 3];
            const i2 = tris[i][(j+1) % 3];
            const ordered_edge = i1 < i2 ? [i1, i2] : [i2, i1];
            if(all_edges.has(edge_as_number(ordered_edge)))
                inner_edges.add(edge_as_number(ordered_edge));
            all_edges.add(edge_as_number(ordered_edge))
        }
    }
    edges = Array.from(all_edges.values()).map(number_as_edge);

    // compute outer edges
    var outer_edges = [];
    for(var i = 0; i < tris.length; ++i) {
        for(var j = 0; j < 3; ++j) {
            const edge = [tris[i][j % 3], tris[i][(j+1) % 3]];
            const egde = [tris[i][(j+1) % 3], tris[i][j % 3]];
            if(!(inner_edges.has(edge_as_number(edge)) || inner_edges.has(edge_as_number(egde))))
                outer_edges.push(edge);
        }
    }

    const do_interpolation = document.getElementById("i3d").checked || document.getElementById("ie3d").checked;
    const do_extrapolation = document.getElementById("e3d").checked || document.getElementById("ie3d").checked;
    const do_linear_basis = document.getElementById("basis3d_linear").checked;
    if(do_linear_basis) {
        basis_3d = [[]]; // starts with 1 (0 is empty)

        for(var i = 1; i < x3s.length; ++i) {
            var points_i = [i];
            // find neighbors
            for(var j = 0; j < edges.length; ++j) {
                if(edges[j][0] == i)
                    points_i.push(edges[j][1]);
                if(edges[j][1] == i)
                    points_i.push(edges[j][0]);
            }
            var x_points = [];
            var y_points = [];
            for(var j = 0; j < points_i.length; ++j) {
                x_points.push([x3s[points_i[j]],z3s[points_i[j]]]);
                y_points.push([y3s[points_i[j]],z3s[points_i[j]]]);
            }
            const x_line = approximation_polynomial_coefficients_for(x_points, 2);
            const y_line = approximation_polynomial_coefficients_for(y_points, 2);
            const oa = x_line[1];
            const ob = y_line[1];
            const oc = z3s[i] - (oa*x3s[i] + ob*y3s[i]);
            basis_3d.push(function(x, y) {return oa * x + ob * y + oc;});
        }

        // compute z-field with linear basis
        z_field = [];
        for (var i = 0; i < w*h; i += 1) {
            var y = Math.floor(i / w);
            var x = i % w;
            var z = Z_NOT_DETERMINED;
            for(var j = 0; j < tris.length; ++j)
                if(in_tri(x, y, x3s[tris[j][0]], y3s[tris[j][0]], x3s[tris[j][1]], y3s[tris[j][1]], x3s[tris[j][2]], y3s[tris[j][2]])) {
                    if(do_interpolation)
                        z = z_in_tri_by_basis(x, y,
                            x3s[tris[j][0]], y3s[tris[j][0]], basis_3d[tris[j][0]],
                            x3s[tris[j][1]], y3s[tris[j][1]], basis_3d[tris[j][1]],
                            x3s[tris[j][2]], y3s[tris[j][2]], basis_3d[tris[j][2]]);
                    else
                        z = Z_NOT_APLICABLE;
                    break;
                }
            if(do_extrapolation && z == Z_NOT_DETERMINED) {
                for(var j = 0; j < outer_edges.length; ++j) {
                    if(in_edge(x, y, x3s[outer_edges[j][0]], y3s[outer_edges[j][0]], x3s[outer_edges[j][1]], y3s[outer_edges[j][1]])) {
                        if(z != Z_NOT_DETERMINED && z != Z_NOT_APLICABLE) {
                            document.getElementById('hpok6').style.display = "block";
                            count_score();
                            break
                        }
                        z = z_in_edge_by_basis(x, y, x3s[outer_edges[j][0]], y3s[outer_edges[j][0]], basis_3d[outer_edges[j][0]], x3s[outer_edges[j][1]], y3s[outer_edges[j][1]], basis_3d[outer_edges[j][1]]);
                    }
                }
            }
            if(do_extrapolation && z == Z_NOT_DETERMINED)
                z = basis_3d[closest_3d_point(x, y)](x, y);
            z_field.push(z);
        }
    } else {
        // compute z-field with constant values instead of basis
        z_field = [];
        for (var i = 0; i < w*h; i += 1) {
            var y = Math.floor(i / w);
            var x = i % w;
            var z = Z_NOT_DETERMINED;

            for(var j = 0; j < tris.length; ++j)
                if(in_tri(x, y, x3s[tris[j][0]], y3s[tris[j][0]], x3s[tris[j][1]], y3s[tris[j][1]], x3s[tris[j][2]], y3s[tris[j][2]])) {
                    if(do_interpolation)
                        z = z_in_tri(x, y,
                            x3s[tris[j][0]], y3s[tris[j][0]], z3s[tris[j][0]],
                            x3s[tris[j][1]], y3s[tris[j][1]], z3s[tris[j][1]],
                            x3s[tris[j][2]], y3s[tris[j][2]], z3s[tris[j][2]]);
                    else
                        z = Z_NOT_APLICABLE;
                    break;
                }
            if(do_extrapolation && z == Z_NOT_DETERMINED) {
                for(var j = 0; j < outer_edges.length; ++j) {
                    if(in_edge(x, y, x3s[outer_edges[j][0]], y3s[outer_edges[j][0]], x3s[outer_edges[j][1]], y3s[outer_edges[j][1]])) {
                        if(z != Z_NOT_DETERMINED && z != Z_NOT_APLICABLE) {
                            document.getElementById('hpok6').style.display = "block";
                            count_score();
                            break
                        }
                        z = z_in_edge(x, y, x3s[outer_edges[j][0]], y3s[outer_edges[j][0]], z3s[outer_edges[j][0]], x3s[outer_edges[j][1]], y3s[outer_edges[j][1]], z3s[outer_edges[j][1]]);
                    }
                }
            }
            if(do_extrapolation && z == Z_NOT_DETERMINED)
                z = z3s[closest_3d_point(x, y)];
            z_field.push(z);
        }
    }
}

function draw_canvas3d(client_x, client_y, do_guides){
    var canvas = document.getElementById("canvas3d");
    var context = canvas.getContext("2d");

    // draw z-field
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        if(z_field[Math.floor(i/4)] == Z_NOT_APLICABLE || z_field[Math.floor(i/4)] == Z_NOT_DETERMINED) {
            pixel_field.data[i + 0] = 0x00;
            pixel_field.data[i + 1] = 0x00;
            pixel_field.data[i + 2] = 0x00;
            pixel_field.data[i + 3] = 0x00;
        } else {
            const color = Math.trunc(z_field[Math.floor(i/4)] / 8) * 8;
            pixel_field.data[i + 0] = color;
            pixel_field.data[i + 1] = color;
            pixel_field.data[i + 2] = color;
            pixel_field.data[i + 3] = 0xFF;
        }
    }
    context.putImageData(pixel_field, -0.5, -0.5);

    // dots
    context.strokeStyle="#f71134";
    for(var i = 1; i <= x3s.length; ++i){
        context.beginPath();
        context.arc(x3s[i], y3s[i], 4, 0, 2*Math.PI);
        context.stroke();
        context.closePath();
    }

    // guides
    if(do_guides){
        const point_i = closest_3d_point(client_x, client_y);
        draw_arrow(context, x3s[point_i], y3s[point_i], client_x, client_y);
    }

    // complex
    context.setLineDash([4, 4]);
    for(var i = 0; i < edges.length; ++i) {
     context.beginPath();
        context.moveTo(x3s[edges[i][0]], y3s[edges[i][0]]);
        context.lineTo(x3s[edges[i][1]], y3s[edges[i][1]]);
        context.stroke();
        context.closePath();
    }
    context.setLineDash([]);
}

// UI
function inc(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) + 1;
    eval('change_' + counter_name + '()');
}

function dec(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) - 1;
    eval('change_' + counter_name + '()');
}

function change_weight2d1() {
    weight2d1 = document.getElementById('weight2d1').value;
    draw_canvas2d1();
    // hpoks
    if(weight2d1 == 0.) {
        document.getElementById('hpok1').style.display = "block";
        count_score();
    } else if(weight2d1 < 0.) {
        document.getElementById('hpok2').style.display = "block";
        count_score();
    } else if(weight2d1 != Math.floor(weight2d1)) {
        document.getElementById('hpok3').style.display = "block";
        count_score();
    }
}

function change_weight2d2() {
    weight2d2 = document.getElementById('weight2d2').value;
    draw_canvas2d2();
}

function change_weight3d() {
    weight3d = document.getElementById('weight3d').value;
    compute_edges_and_z_field();
    draw_canvas3d();
}

function count_score() {
    const score 
      = (document.getElementById('hpok1').style.display == "block" ? 1 : 0)
      + (document.getElementById('hpok2').style.display == "block" ? 1 : 0)
      + (document.getElementById('hpok3').style.display == "block" ? 1 : 0)
      + (document.getElementById('hpok4').style.display == "block" ? 1 : 0)
      + (document.getElementById('hpok5').style.display == "block" ? 1 : 0)
      + (document.getElementById('hpok6').style.display == "block" ? 1 : 0);
   if(score == 1) {
       document.getElementById('score').innerHTML = "<p class='score'>1 / 6</p><p>There are 6 hidden pieces of knowledge. Find them all to win!</p>";
   } else if(score == 2) {
       document.getElementById('score').innerHTML = "<p class='score'>2/6</p><p>There are 6 hidden pieces of knowledge. Find them all to win!</p>";
   } else if(score == 3) {
       document.getElementById('score').innerHTML = "<p class='score'>3/6</p><p>There are 6 hidden pieces of knowledge. Find them all to win!</p>";
   } else if(score == 4) {
       document.getElementById('score').innerHTML = "<p class='score'>4/6</p><p>There are 6 hidden pieces of knowledge. Find them all to win!</p>";
   } else if(score == 5) {
       document.getElementById('score').innerHTML = "<p class='score'>5/6</p><p>There are 6 hidden pieces of knowledge. You've almost found them all!</p>";
   } else if(score == 6) {
       document.getElementById('score').innerHTML = "<p class='score'>6/6</p><p>Congratulations! You won the hidden knowledge game!</p>";
   }
}
    </script>
  </head>
  <body>
    <center>
    <h1>
SWInE: simplicial weight interpolation and extrapolation
    </h1>
    <p>
I've been procrastinating on this for more than ten years. This particular algorithm is kind of my brainchild. While working on my thesis, I stole exactly three ideas from other people, made them work together, and gave that compilation a funny name. This counts as authorship, right?
    </p>
    <p>
I had my fun playing with the concept but the conclusion I had to put into my thesis was: SWInE is rather promising. In academic tongue, this means useless. Almost everything you can do with SWInE, you can do with splines better. And this brings the dilemma. On one hand, I can share a unique piece of knowledge very few people in the world are familiar with; on the other hand, this piece of knowledge is worthless.
    </p>
    <p>
Finally, I came up with this argument. The three ideas behind the algorithm are prominent. And if an algorihtm helps show them in action, then maybe this is what makes the algorithm worthy.
    </p>
    <h2>
Idea 1: inverse weights
    </h2>
    <p>
Let's say we have two points <i>(x<sub>1</sub>, y<sub>1</sub>)</i> and <i>(x<sub>2</sub>, y<sub>2</sub>)</i>. There is a function <i>F(x)</i> that fits these points. Fits means this:
    </p>
    <p class="formula">
F(x<sub>1</sub>) = y<sub>1</sub>
<br>
F(x<sub>2</sub>) = y<sub>2</sub>
    </p>
    <p>
When we want to determine this function in between points, it is called <b>interpolation</b>. When we want to determine it on the left and on the right of the points — <b>extrapolation</b>.
    </p>
    <p>
The <b>inverse weights</b> is the way to build the interpolating function everywhere apart the points themselves.
    </p>
    <table class="formula">
    <tr>
    <td rowspan=2>
    F(x) = &nbsp;
    </td>
    <td style="border-bottom: 1px solid black">
    y<sub>i</sub> * k(x - x<sub>i</sub>) + y<sub>i+1</sub> * k(x<sub>i+1</sub> - x)
    </td>
    </tr>
    <tr>
    <td>
    k(x - x<sub>i</sub>) + k(x<sub>i+1</sub> - x)
    </td>
    </tr>
    </table>
    <table class="formula">
    <tr>
    <td rowspan=2>
    k(x) = &nbsp;
    </td>
    <td style="border-bottom: 1px solid black">
    1
    </td>
    </tr>
    <tr>
    <td>
    x<sup>n</sup>
    </td>
    </tr>
    </table>
    <p>
Yes, there is a zero division in <i>x<sub>i</sub></i>. It is odd that the function that should be interpolating the points isn't defined in the points themselves. But the magic of limits makes it work. The function becomes infinitely close to the points in their respected proximities, so this undefined points problem can be simply patched by this:
    </p>
    <p class="formula">
F(x<sub>i</sub>) = y<sub>i</sub>
    </p>
    <p>
The function outside the points can be defined as the first point on the left, and as the last point on the right. This will work as a primitive extrapolation.
    </p>
    <p>
The n-coefficient in the weight function affects the way the function looks. You can try it out on the following interative plot:
    </p>
    <p class="hpok" id="hpok1">
<b>Hidden piece of knowledge #1.</b> The function becomes discontinuous when the weight coefficient = 0.
    </p>
    <p class="hpok" id="hpok2">
<b>Hidden piece of knowledge #2.</b> Negative values for the weight coefficient are useless for interpolation.
    </p>
    <p class="hpok" id="hpok3">
<b>Hidden piece of knowledge #3.</b> But non-integer values for the weight coefficient are useful! They give you more freedom over the function with no additional changes in the algorithm. Cudos for finding that!
    </p>     
    <canvas id="canvas2d1" width=640 height=640></canvas>
    <form>
    Do:
    <input type="radio" name="ie" id="i" value="i" onclick="draw_canvas2d1(0, 0, false);"><label for="i">interpolation</label>,
    <input type="radio" name="ie" id="e" value="e" onclick="draw_canvas2d1(0, 0, false);"><label for="e">extrapolation</label>,
    <input type="radio" name="ie" id="ie" value="ie" checked="true" onclick="draw_canvas2d1(0, 0, false);"><label for="ie">both</label>;
    <br>
    <br>
    with the weight coefficient:
    <button type="button" onclick="dec('weight2d1')">-</button>
    <input type="text" style="width: 32pt;" id="weight2d1" value="2" oninput="change_weight2d1();">
    <button type="button" onclick="inc('weight2d1')">+</button>
    </form>
    <p>
Mathematically, the inverse weights are simple. Of course, real computation brings more challenges. There is no such thing as a limit in floating point computation so the function should be technically discontinuous. You have to define the interpolating function as its basis values not only in <i>x<sub>i</sub></i> points but in some proximity too.
    </p>
    <p>
Then again, every computation on floating point numbers is discrete so pragmatically this is just one more “quess an epsilon” problem.
    </p>
    <h2>
Idea 2: basis functions
    </h2>
    <p>
Ok, so we can now interpolate values to get new values between them. But with inverse weights, we see that the interpolating function makes a platoe near the <i>x<sub>i</sub></i> points. Perhaps, we would like something else.
    </p>
    <p>
The idea of <b>basis functions</b> is: we can interpolate functions instead of points.
    </p>
    <table class="formula">
    <tr>
    <td rowspan=2>
    F(x) = &nbsp;
    </td>
    <td style="border-bottom: 1px solid black">
    f<sub>i</sub>(x) * k(x - x<sub>i</sub>) + f<sub>i+1</sub>(x) * k(x<sub>i+1</sub> - x)
    </td>
    </tr>
    <tr>
    <td>
    k(x - x<sub>i</sub>) + k(x<sub>i+1</sub> - x)
    </td>
    </tr>
    </table>
    <p>
Technically, every function <i>f(x)</i> such as <i>f(x<sub>i</sub>) = y<sub>i</sub></i> can be a basis function. There are numerous ways to compute such functions, there are numerous types of them. Let's try things out with a few types of polynomial functions: the constant (it's a 0-polynomial in a way), the linear function, and the quadratic function.
    </p>
    <table class="formula">
    <tr>
    <td style="padding-bottom: 18pt;">
    f<sub>i</sub>(x) = y<sub>i</sub>
    </td>
    </tr>
    <tr>
    <td style="padding-bottom: 18pt;">
    f<sub>i</sub>(x) = ax + b<span style="color: #777">; ax<sub>i</sub> + b = y<sub>i</sub></span>
    </td>
    </tr>
    <tr>
    <td>
    f<sub>i</sub>(x) = ax<sup>2</sup> + bx + c<span style="color: #777">; ax<sub>i</sub><sup>2</sup> + bx<sub>i</sub> + c = y<sub>i</sub></span>
    </td>
    </tr>
    </table>
    <p>
The magic of inverse weights is in their indifference. They can work with any basis functions and it's easy to mix them up in a single formula to get something you want.
    </p>
    <p>
On this interactive plot, you can see how different types of basis functions work together in different configurations:
    </p>
    <p class="hpok" id="hpok4">
<b>Hidden piece of knowledge #4.</b> In order for this interpolation to work, the points should be x-ordered.
    </p>
    <canvas id="canvas2d2" width=640 height=640></canvas>
    <p class="hpok" id="hpok5">
<b>Hidden piece of knowledge #5.</b> Polynomial basis functions may reduce themselves into constants if the input suggests that.
    </p>       
    <form>
    <span style="line-height: 1.42;">
    Please select one of the following configurations:
    <br>
    <input type="radio" name="basis" id="cccc" value="cccc" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="cccc">constant-constant-constant-constant</label>;
    <br>
    <input type="radio" name="basis" id="cllc" value="cllc" checked="true" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="cllc">constant-linear-linear-constant</label>;
    <br>
    <input type="radio" name="basis" id="llll" value="llll" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="llll">linear-linear-linear-linear</label>;
    <br>
    <input type="radio" name="basis" id="cqqc" value="cqqc" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="cqqc">constant-quadratic-quadratic-constant</label>;
    <br>
    <input type="radio" name="basis" id="lqql" value="lqql" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="lqql">linear-quadratic-quadratic-linear</label>;
    <br>
    <input type="radio" name="basis" id="qqqq" value="qqqq" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="qqqq">quadratic-quadratic-quadratic-quadratic</label>.
    </span>
    <br><br>
    And the weight coefficient:
    <button type="button" onclick="dec('weight2d2')">-</button>
    <input type="text" style="width: 32pt;" id="weight2d2" value="2" oninput="change_weight2d2();">
    <button type="button" onclick="inc('weight2d2')">+</button>
    </form>
    <p>
With inverse weights and basis functions, we have almost too much freedom. We can have our function smooth on some interval, and then have a sharp dent. We can make it lay on a platoe near some point, and then fit some curvature on a range.
    </p>
    <p>
But so far it only concerns functions of a single variable. Or two-dimensional parametric curves. If we want to generalize weight interpolation to n-dimensional case, we have to use an n-dimentional structure.
    </p>
    <h2>
Idea 3: self-referencial n-simplex data structure
    </h2>
    <p>
A point is a 0-simplex. A line segment, a piece of line between two points, is a 1-simplex. A triangle, a region on a plane inside three line segments, is a 2-simplex. A tetrahedron is a 3-simplex. And if you can imagine how tetrahedron becomes a point while traveling through the 4-th dimention, that would be a 4-simplex. I hope you see a pattern here.
    </p>
    <p>
An <b>n-simplex</b> is the space between n+1 (n-1)-simplices.
    </p>
    <p>
This makes it self-referencial. If we want to define an interpolating function on a line, on atriangle, and on a tetrahedron, we only have to define it once on an n-simplex.
    </p>
    <p>
With basis functions weight interpolation, you already have your interpolating function defined in the basis points.
    <p>

    <table class="formula">
    <tr>
    <td colspan=2 style="padding-bottom: 18pt;">
        F(<b>x</b>) = F<sub>n</sub>(<b>x</b>)
    </td>
    </tr>
    <tr>
    <td colspan=2 style="padding-bottom: 18pt;">
        <b>x</b> = <b>x<sub>i</sub></b> &rArr; F<sub>n</sub>(x) = f<sub>i</sub>(<b>x</b>)
    </td>
    </tr>
    </table>
    <p>
Consequently, this defines <i>F<sub>0</sub></i>. For all the other <i>n</i>, the self-referencial formula looks like this.
    </p>

    <table class="formula">
    <td rowspan=2>
        <b>x</b> &ne; <b>x<sub>i</sub></b> &rArr; F<sub>n</sub>(<b>x</b>) = &nbsp;
    </td>
    <td style="border-bottom: 1px solid black">
        <table border=0 colspan=0 rowspan=0><tr><td style="font-size: 10pt;">n+1</td><td rowspan=3>k(|<b>x<sub>j</sub></b> - <b>x</b>|) F<sub>n-1</sub>(<b>x<sub>j</sub></b>)</font></td></tr><tr><td style="font-size: 28pt;">&Sigma;</td></tr><tr><td style="font-size: 10pt;">j=1</td></tr></table>
    </td>
    </tr>
    <tr>
    <td>
        <table border=0 colspan=0 rowspan=0><tr><td style="font-size: 10pt;">n+1</td><td rowspan=3>k(|<b>x<sub>j</sub></b> - <b>x</b>|) </font></td></tr><tr><td style="font-size: 28pt;">&Sigma;</td></tr><tr><td style="font-size: 10pt;">j=1</td></tr></table>
    </td>
    </tr>
    </table>
    <p>
    </p>
    <p>
The formula looks almost like the one with the basis functions except now all the variables in bold type are vectors: <i><b>x</b></i>, <i><b>x<sub>i</sub></b></i>, <i><b>x<sub>j</sub></b></i>.
    </p>
    <p>
Speaking of which, since we want to interpolate basis functions in an n-simplex, we should compute our basis functions out of distances to (n-1)-simplices. The <i><b>x</b><sub>j</sub></i> is the projection of <i><b>x</b></i> onto the j-th (n-1)-simplex. The <i>|<b>x<sub>j</sub></b> - <b>x</b>|</i> is then the distance from a point to its projection.
    </p>
    <p>
The rest is all like before. Weight functions, basis functions, and now the (n-1)-simplex projections. This is enough to define an interpolation function on a triangle or a tertrahedron. But what about more complex shapes?
    </p>
    <p>
When we have a bunch of simplices that touch each other but never overlap, this is a simplicial complex. If you're ok with some representation error, you can cover any shape with a simplicial complex. 
    </p>
    <p>
But we can find a function even for the domain that is not covered by the complext. We need spatical interpolation for that. 
    </p>
    <p>
With weight and basis functions, you can mix your interpolating function in n-simplices with interpolating functions on (n-1)-simplices. Now if a point isn't in an n-simplex but has a projection on an (n-1)-simplex, then computing the weights on this projection and applying them to the basis functions will make an extrapolation that will seamlessly merge with the interpolation.
    </p>
    <p>
The same goes to (n-2)-simplices, (n-3) or (n-k) ones. Let's device an algorithm by dividing interpolation and extrapolation into 3 cases.
    </p>
    <p>
If a point is in a triangle, then the <i>F<sub>2</sub></i> applies; if a point has a projection on the complex border line segments, then the <i>F<sub>1</sub></i> works instead; if a point doesn't have the projection, then the basis function of a nearest point <i>f<sub>i</sub></i> is the extrapolator.
    </p>    
    <p>
Here is an interactive plot that has 6 triangles combined in a complex. Every point has its own shade of gray and the rest of the picture is the result of interpolation. The points are moveable, but the relations between triangles are hard-coded.
    </p>
    
    <p class="hpok" id="hpok6">
<b>Hidden piece of knowledge #6.</b> Ah! Yes, this algorithm doesn't work with concave shapes. Technically, we can turn any concave simplicial complex into a convex one by adding more simplices but that makes the algorithm more complex.
    </p>    
    <canvas id="canvas3d" width=640 height=640></canvas>
    <form>
Do:
    <input type="radio" name="ie3d" id="i3d" onclick="compute_edges_and_z_field();draw_canvas3d(0, 0, false);"><label for="i3d">interpolation</label>,
    <input type="radio" name="ie3d" id="e3d" onclick="compute_edges_and_z_field();draw_canvas3d(0, 0, false);"><label for="e3d">extrapolation</label>,
    <input type="radio" name="ie3d" id="ie3d" checked="true" onclick="compute_edges_and_z_field();draw_canvas3d(0, 0, false);"><label for="ie3d">both</label>.
    <br>
    <br>
With basis function:
    <input type="radio" name="basis3d" id="basis3d_constant" value="basis3d_constant" onclick="change_weight3d();"><label for="basis3d_constant">constant</label>;
    <input type="radio" name="basis3d" checked="true" id="basis3d_linear" value="basis3d_linear" onclick="change_weight3d();"><label for="basis3d_linear">linear</label>.
    <br>
    <br>
And the weight coefficient:
    <button type="button" onclick="dec('weight3d')">-</button>
    <input type="text" style="width: 32pt;" id="weight3d" value="2" oninput="change_weight3d();">
    <button type="button" onclick="inc('weight3d')">+</button>
    </form>

    <p>
And that's how we got from a pair of points to Simplicial Weight Interpolation and Extrapolation. Just as promised in the title.
    </p>
    <h2>
The score
    </h2>
    <div id="score">
    <p>
If you just scrolled the page to the bottom, you might have not noticed that it's also a game. There are hidden pieces of knowledge kept in the interactive plots. Find them all to win.
    </p>
    </div>
    <h2>
P. S.
    </h2>
    <p>
You can see the code for all the plots on GitHub:
    </p>
    <ul>
    <li>inverse weights;</li>
    <li>basis functions;</li>
    <li>simplicial interpolation and extrapolation.</li>
    </ul>    
    </div>
    <script language="JavaScript">
    init_canvas2d1();
    init_canvas2d2();
    init_canvas3d();
    </script>
    


    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
    <tr>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
        <a href="index.html"><img src="favicon.ico"></a>
    </td>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
        &nbsp;&larr; there's more.
    </td>
    <td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
        +
        <a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
        <a href="https://twitter.com/wordsandbuttons">Twitter</a> &
        <a href="https://news.ycombinator.com/from?site=wordsandbuttons.online">Hacker News</a>
    </td>
    </tr>
    </table>    
    </center>
  </body>
</html>
