Applied Geometry for Programmers
Oleksandr Kaleniuk

1. Tell us about yourself. 
I have a Candidate of Sciences degree in Applied Geometry and Engineering Graphics. The Candidate of Sciences is essentially a Ph. D., but I got mine in Ukraine so it has a funny name.

I have fifteen years of experience as a software engineer. I started in game development, then worked at a research institution for two years, and since 2015, I am working for Materialise. It’s a market leader in 3D printing and specialized CAD software. I work for the central research and technology unit, specifically, I am a member of Materialise Software Development Kit team. I devise new geometric algorithms, fix and speed up the old ones. At this position, I had been recognized not only as an algorithmist, but as a mentor, and a lecturer.

For the last ten years, writing tutorials on applied geometry was my hobby. I started writing in Ukrainian and Russian for local sites, tried publishing on Medium since 2015, and although some of my pieces were quite successful, in 2017 I started my own website called Words and Buttons Online. It’s a growing collection of interactive tutorials, demos, and quizzes. In 3.5 years, I published more than 50 pieces, of which more than half are dedicated to math and computation. The rest is about programming languages and how to make programs run faster.

To sum things up, I have an academic background, engineering experience, and chronic graphomania.

I don’t think that I have any unique characteristics in any of these. But I think that I have the right proportion of the three to write this book in particular.


2. Tell us about the book’s topic. 
Applied geometry is the math behind game engines, CAD libraries, and VR frameworks. Everything that concerns computer graphics or modeling both 2D and 3D.

It has always been important, but for some time we were able to pretend that it’s not. For instance, typical GDI+ users are not expected to know about homogeneous coordinates and projective geometry in general. Instead, they have a function called Drawing2D.Matrix.TransformPoints to, well, transform points. The function does its job, but it’s built on top of a layer on top of another layer of abstraction and instead of single matrix multiplication, it does conversions, it does marshaling, it does construction, and only then the transformation itself. It is slow. It is obscenely slow. But since it’s for the graphical user interface, who cares? It’s usually just a few points and users will not even notice if their operation takes a few more microseconds.

However today, the focus of the industry shifts from desktop development to cloud development. We have more data now, we have more complicated models, and we have drastically more computational power at our hands, but! We also get to pay for this power. And suddenly, all these layers of abstraction become a burden. It costs you money to use, and it doesn’t provide any value in return. If you know your projective geometry, you can substitute the whole abstraction cake below the TransformPoints function with just 4 multiplications and 6 additions. It works hundreds of times faster, and it’s only two lines of code.

To be competitive in the cloud, you have to be very efficient with your code. If you’re good with your math, you can only pay for the computation you really need and not layers.

The alternative would be using the tools you’re given without proper understanding, usually ineffectively, and often in panic mode.


3. Tell us about the book you plan to write.
After reading this book, the reader will feel confident working with geometry-related code. This concerns any graphics or modeling libraries, frameworks, and SDKs since the math behind them is exactly the same.
The reader will be able to:
    • Use geometric libraries, toolkits, and frameworks in the most efficient manner.
    • Debug and maintain these tools, given that the reader is already comfortable with programming in the target environment.
    • Come up with custom solutions for specific problems including creating custom geometric transformations, curves, and surfaces.

The book is designed to teach applied geometry to practicing programmers. 

I think it falls into the Math for Programmers pattern, although I’m not sure if it’s yet a series. It should be anyway.

The unique trait of this book is that it’s a math book, but it will avoid math notation whenever possible. Instead, there will be a lot of programmatically generated plots and illustrations, since it’s about geometry, and snippets of Python code instead of formulas, since it’s for programmers.


4. Q&A
The three most commonly asked questions about applied geometry in programming context are:
    • How do transformation matrices work?
    • What are splines?
    • How does dual contouring compare to marching cubes?


5. Tell us about your readers.
The reader is expected to be a practicing programmer who wants to learn applied geometry to become better in their work. 

The specific expectations are:
    • General knowledge of school-level geometry.
    • The ability to read small snippets of Python code. 
    • Intermediate programming skills in any language.
    • Some familiarity with calculus or vector algebra is welcome but not necessary.

The typical job roles for the primary reader are:
    • A junior-level game engine or CAD framework developer.
    • An intermediate-level game or application developer who uses graphic or modeling middleware.

The reader should be motivated by the prospect of becoming a better developer but also by the implicit promise of lowering anxiety levels. I see this often among junior developers. They are stalling in their work not because they lack knowledge or skills, but because they lack confidence. The book should be very approachable not to create additional stress but also have enough explanatory power to give the reader the confidence they desire.


6. Tell us about the competition and the ecosystem.

Books
The closest competitor content-wise is Applied Geometry for Computer Graphics and CAD by Duncan Marsh. It is, however, written for undergraduate math students and not programmers. It doesn’t concern computational aspects such as memory consumption, or code performance. Most importantly, it expects the reader to be a mathematician in the future, and not a programmer currently so it uses the established language of math to explain more math.

Not particularly a book on geometry, Mathematics for Computer Science by Eric Lehman and Tom Leighton is an excellent example of approachable mathematical writing for non-mathematicians. It explains important mathematical concepts with relatable examples. It's even entertaining as far as a math book can be. If there were a book exactly like this but about applied geometry, I wouldn’t even enter the competition. 

Another good example of math for programmers kind of books is A Brief Course in Modern Math for Programmers by Vlad Partyshev. It's concise, it doesn't have theorems and proofs, but instead, it focuses on important concepts from the realm of logic, algebra, and category theory. It doesn't cover geometry explicitly, although some of the ideas are of course universal through the whole body of applied mathematics.

A more fitting example in terms of content would be Foundations of Game Engine Development by Eric Lengyel. It is a concise practical book filled with C++ code examples. But it’s just too concise. The author introduces some really deep concepts from advanced algebra, but he doesn’t really explain them, he just puts them down for the reader to remember. The book has code, but it’s still essentially a math book, not a programmer’s book. 

The proposed book should be much more approachable. It will explain geometric concepts to programmers using plots, diagrams, and code. Ideally, all the formulas should be put in a form of SymPy snippets, so the reader could read them with no previous exposure to the higher math. There will be mnemonics to help them remember the material. There will be examples from real-world practice. There will be didactic stories.

I want my book to be more like Geometrie et Mecanique des Arts et Metiers et des Beaux-Arts by Charles Dupin. It's a book of explanations and practical examples. It doesn't have a single large formula in it, but it's packed with illustrations. It was initially published in Paris in 1825, and my copy is printed in 2010 in Ternopil, Ukraine. That’s quite a shelf life for a technical book. 

Videos
I don’t know much about videos on the topic. There are some outstanding courses on applied geometry available but they are purely academic. Youtube channels like 3Blue1Brown or Numberphile do have some approachable videos on geometry, but they’re not focused on applied geometry, they are popularizing math in general.

Keenan Crane has his Youtube channel, and he is focused, but he is focused on discrete differential geometry which is a small part of applied geometry.

Websites
As for the sites, as a founder of an interactive tutorial site, I’m mostly interested in interactive education as well. These sites all have great tutorials on geometry, but only among other topics:

https://betterexplained.com/ A site of sometimes interactive explanations. Their geometry section is not particularly rich, but they do have one.

https://www.redblobgames.com/ Interactive visual explanations of math and algorithms, with motivating examples from computer games. 

https://mathigon.org/courses Interactive courses on geometry and other topics.

And, well, it is important for me anyway: https://wordsandbuttons.online/ A growing collection of interactive tutorials, demos, and quizzes.

Live events
In Kyiv, the two most active event organizers in the domain of non-academic applied geometry are Kyiv Algo Club, and Materialise. Also, the former hasn’t been very active lately. So the local audience gathers mostly at our meetups and conferences.

Other sources
There are also multiple course notes on the subject but they are, of course, targeted towards the more advanced reader.

A good example I keep recommending to my peers is Discrete Differential Geometry an Applied Introduction by Keenan Crane. It is beautifully written and packed with applicable and de facto applied geometrical ideas. It is, of course, covers only a small part of applied geometry but it does it perfectly.

Another example is Geometric Algebra for Computer Graphics by Charles G. Gunn, Ph. D. brings a new perspective on the applicability of geometric algebra, but it has little to do with the current reality of geometric applications.


7. Book size and illustrations
I did the estimates projecting from already published tutorials, but since most of their explaining power came from interactive experience and not verbal explanations, the numbers for a static book may appear inaccurate.
    • The approximate number of published pages: 250.
    • The approximate number of diagrams and other graphics: 125.
    • The approximate number of code listings: 250.

I’m not familiar with your development process, but if it’s applicable, most of the diagrams and plots could be generated programmatically. 

The code listings are not actual listings, they will be mostly but not exclusively formulas in the form of SymPy code snippets.


8. Contact information
Oleksandr Kaleniuk
Tolstogo st., 6, Radomyshl, Ukraine, 12200
akalenuk@gmail.com
+380 63-021-45-89
https://wordsandbuttons.online


9. Schedule
Given that I still have my contract obligations with Materialise, I can only confidently commit to 4-8 weeks per chapter.

    • Before we begin: 1 week.
    • Part 1: 4 weeks.
    • Part 2: 4 weeks.
    • Part 3: 8 weeks.
    • Part 4: 6 weeks.
    • Part 5: 8 weeks.

In terms of parts, I see it like this:
    • 1/3 manuscript: 9 weeks.
    • 2/3 manuscript: 10 weeks.
    • 3/3 manuscript: 12 weeks.

There are no critical deadlines and no direct competition as far as I’m aware. 


10. Table of Contents
Before we start. Meet SymPy, it will do your math for you

Part 1 Basics
1.1. Points, vertices, triangles, and simplices
1.2. Numbers, vectors, and covectors
	1.2.1. Dot and cross vector products
	1.2.2. Practical example: does a point belong to a triangle?
1.3. Functions, curves, surfaces, and manifolds
	1.3.1. Derivative and the tangent vector
	1.3.2. Second derivative and the curvature
1.3.3. Parametric curve
	1.3.4. Surface parameterization
1.4. Matrices, tensors, and transformations
1.5. Lines, planes, hyperplanes, and linear systems
	1.5.1. Underspecified and overspecified systems
	1.5.2. A visual example of an interactive linear solver
	1.5.3. Direct solver: Gaussian elimination and decomposition
	1.5.4. What solver fits my problem the best?
1.6. Summary

Part 2. Projective geometric transformations
2.1. Translation and scale
2.2. Rotation
	2.2.1. Sine and cosine, and how not to mistake them for each other
2.3. Linear transformation
	2.3.1. Why is it symmetrical?
	2.3.2. Practical example: composing your own transformation from points
2.4. Affine transformations
	2.4.1. Bundling rotation, scale, and translation together
	2.4.2. Practical example: does a point belong to the triangle? But now faster
2.5. Projective transformations
	2.5.1. Projection
	2.5.2. Types of projections
2.6. Bringing all transformations to a single matrix
	2.6.1. Homogeneous coordinates
	2.6.2. Transformation matrix
	2.6.3. Practical example: setting a frustum
	2.6.4. Practical example: picking cards from a table
	2.6.5. Practical example: scanning with a phone	
2.7. Summary

Part 3. Polynomials and splines
3.1. Polynomials
	3.1.1. Axis intersections and polynomial equation roots
	3.1.2. Symmetric and antisymmetric polynomials
	3.1.3. Polynomial derivatives
	3.1.4. Maclaurin and Taylor series
3.2. Polynomial approximation
	3.2.1. Least squares method
3.3. Polynomial interpolation
	3.3.1. Vandermonde matrix
	3.3.2. Runge's phenomenon
	3.3.3. Chebyshev nodes
	3.3.4. Bundling polynomial approximation and interpolation together
3.4. Polynomial synthesis
	3.4.1. Technically, not a Vandermonde matrix
	3.4.2. Practical example: crafting a sine approximation
	3.4.3. Bezier curves
	3.4.4. Bezier splines
	3.4.5. Practical example: crafting a quadratic spline
3.5. Lagrange interpolation
3.6. NURBS
	3.6.1. Non-uniform
	3.6.2. Rational
	3.6.3. Basis splines
	3.6.4. De Boor's algorithm
3.7 Summary

Part 4. Non-projective geometric transformations
4.1. Complex numbers and conformal transformations
	4.1.1. Quaternions and rotations
4.2. Polynomial transformations
	4.2.1. Practical example: unbending the page from a picture
4.3. Polyfiber and dual polypoint transformations
4.5. Making a deformation field with spatial interpolation
	4.5.1. Shepard's method
	4.5.2. Radial basis functions
4.6. Summary

Part 5. Common representations of geometric models
5.1. Signed distance function
	5.1.1. Practical example: offset
	5.1.2. Practical example: Boolean intersection, subtraction, and union
5.2. Surface mesh and volume mesh
	5.2.1. Practical example: reduction
	5.2.2. Practical example: smoothing
	5.2.3. Practical example: marching cubes and dual contouring
5.3. 2D images and 3D image stack
	5.3.1. Practical example: vectorization
	5.3.2. Practical example: thresholding
5.4. Image mask and voxels
	5.4.1. Practical example: erosion and dilation
	5.4.2. Practical example: cavity fill
5.5. Boundary representation
	5.5.1. Practical example: triangulation
	5.5.2. Practical example: Bezier contouring
5.6. Summary


Before we start. In this chapter, the reader will learn how to use SymPy to do primitive computations both numeric and symbolic. Normally, this would have been an appendix, but since the whole book is supposed to use SymPy notation for formulas, this should really go before anything else. Moreover, this chapter should also contain the motivation for using code instead of the math notation. It is more of a “welcome” chapter than an actual SymPy tutorial.

Still, since it has nothing to do with geometry per se, it is deliberately separated from the content chapters.

Part 1. In this chapter, the reader will learn or recap the basic language of applied geometry. The chapter also covers elements of linear algebra but only as much as it is needed to understand later chapters.

Part 2. In this chapter, the reader will learn how the most common geometric transformations such as rotation, scale, and translation, are both generalized and extended by the projective transformation. The reader will also learn the concept of homogeneous coordinates and how adding a single number to a vector allows us to combine all the possible projective transformations in single matrix multiplication.

Part 3. In this chapter, the reader will learn how to make custom functions, curves, and surfaces out of polynomials and polynomial splines. They will also learn what is NURBS, how it works, how to compute one, and what can it be used for.

Part 4. In this chapter, the reader will learn a few alternative ways to introduce geometric transformations. In the end, the reader will be able to pick a method and generate a fitting transformation for most of the practical tasks imaginable.

Part 5. In this chapter, the reader will learn several geometric model types used in game development, image processing, CAD design, etc. Each representation is supplied with a few most typical practical examples of its application or conversion. Contrary to the “practical example” prefix, the examples were picked for their didactic value and not necessary practicality. But they do nevertheless illustrate how geometric concepts work in practice, and in this regard, the naming is fair.




