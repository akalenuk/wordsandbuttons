Applied Geometry for Programmers
Oleksandr Kaleniuk

1. Tell us about yourself. 
I have a Candidate of Sciences degree in Applied Geometry and Engineering Graphics. Candidate of Scienses is basically a Ph. D., but I got mine in Ukraine so it has a funny name.
I have 15 years of software engineering experience. I started in game development by fixing bugs in a huge 3D game engine. I then wrote a few simple 2D games on several different platforms and in different frameworks. Apparently, if you know your math, they arpeear not all that differnet. Since 2015, I an working for Materialise. It’s a market leader in 3D printing and specialised CAD software. I work for the central research and technology unit, specifically I am a member of Materialise Software Development Kit team. I devise new geometric algorithms, and fix and speed up the old ones. I have been recognized at his position as both an algorithmist ()...
For the last ten years, writing tutorials on applied geometry was my hobby. I started writing in Russian and Ukrainian, tried writing on Medium in 2015, and although some of my pieces were quite successful, in 2017 I started my own website called Words and Buttons Online. It’s a growing collection of interactive tutorials, demos, and quizzes. In 3.5 years, I published  more than 50 pieces, of which more than a half are dedicated to math and computation. The rest is about programming langauges and how to make programs run faster.
To sum things up, I have the academic background, the engineering experience, and a chronic graphomania.

I don’t think that I have any unique characteristics in any of these. But I think that I have the right proportion of the three for this book specifically.

2. Tell us about the book’s topic. 
I’m writing about the geometry behind game engines, CAD libraries, and VR frameworks. Basically everything that concerns computer graphics or modelling both 2D and 3D.
It has always been important, but before now we were able to pretend that it’s not. E. g., typical GDI+ users are not expected to know about  homogeneous coordinates and projective geometry in general. Instead, they have a function called Drawing2D.Matrix.TransformPoints to, well, transform points. The function does its job, but it’s build on a layer on top on a layer on top of another layer of abstraction and instead of a single matrix multiplication, it does conversion, it does marshalling, it does construction, and only then the transformation itself. It is slow. It is obscenely slow. But since it’s for the graphical user interface, who cares? It’s usually just a few points and users will not even notice if their operation takes a few more microseconds.
However today, the very focus of the industry shifts from desktop development to cloud development. We have more data now, we have more complicated and more expenssive models, we have drastically more computaional power at our hands but! We also get to pay for this power. And suddenly, all these layers of abstraction become a dead weight. It literally costs you money to use, and it doesn’t provide any good value in return. If you know your projective geometry, you can substitute the whole transformation with a simple matrix multiplication. It will work the same only hundreds times faster.
To be competetive in the cloud, you have to be very efficient with your code. If you’re good with your math, you can strip it down to the very essentials and only pay for the computation you need, and not layers.
The alternative would be using the tools you’re given without proper understanding, usually ineffectively, and often in panic mode.


3. Tell us about the book you plan to write.
After reading this book, the reader will feel confident working with the geometry related code. This concerns any graphics or modelling libraries, frameworks and SDKs since the math behind them is exactly the same.
The reader will be able to:
    • Use geometric tools in the most efficient manner.
    • Debug and mantain these tools, given that the reader is already comfortable with programming in the target environment.
    • Come up with custom solutions for specific problems including creating custom geometric transformations, curves, and surfaces.

The book is designed to teach applied geometry to practicing programmers. 

I think, it falls into a Math for Programmers pattern, although I’m not sure if it’s yet a series. It should be anyway.

The unique traight of this book is that it’s a math book, but it will avoid math notation whenever possible. There will be a lot of programmatically generated plots and illustrations, since it’s about geometry, and bits of Python code instead of formulas, since it’s for programmers. The excercises will require programming, but they will mostly not be bound to any specific environment.

The idea here is: when explaining a concept, like the transformation of 3 points, or the Vandermonde matrix, I put the equations in SymPy which is a computer algebra system for Python. It sounds much scarier than it really is, it simply turns math into code. This snippets are quite readable by a programmer’s eye, but they also can be entered in any SymPy environment, including on-line free SymPy Live servise. The equations then could be solved into the source code, whether it’s C++, Python, JavaScript, or other. And the reader then could exercise with it in the programming environment of theyr choice.



4. Q&A
The three most commonly-asked questions about applied geometry in programming context are:
    • How transformation matrices work?
    • Do I really have to know about quaternions?
    • What are NURBS?



5. Tell us about your readers.
The reader is expected to be a practicing programmer who wants to learn applied geometry to become better in their work. 

The specific expectations are:
    • General knowledge of school-level geometry.
    • The ability to read snippets of Python code. 
    • Intermediate programming skills in any language.
    • Some familiarity with calculus or vector algebra is welcomed but not necessary.
The typical job roles for the primary reader are:
    • A junior-level game engine or CAD framework developer.
    • An intermediate-level game or application developer who uses graphic or modelling middleware.

The reader should be motivated by the prospect of becoming a better developer but also by the implicit promise of lowering anxiety levels. Working with math could be stressfull, but only when you don’t know it well enough. Sometimes, even a really shallow explanation is enough to switch a person from “Why isn’t this working?!” to “I wonder, how does this work?” mode.


6. Tell us about the competition and the ecosystem.
•	 What are the best books available on this topic and how does the proposed book compare to them?
Arguably, the best book of practical applied geometry is Applied Geometry for Computer Graphics and CAD by Duncan Marsh. It is, however, written for undergraduate math students and not programmers. It doesn’t concern computational aspects such as memory consumption, or code performance. Most importantly, it expects the reader to be a  mathematician in the future, and not a programmer currently. Most of the geometry books are like this.
There is another class of literature: math for game engines developers. A good representative would be Foundations of Game Engine Development by Eric Lengyel. It is a really nice book, concise and supplied with C++ code examples. But it’s just too concise. The author introduces some really deep concepts from advanced algebra, but he doesn’t really explain them, he just puts them down for the reader to remmeber. The book has some code, but it’s still essentially a math book.
The proposed book should be much more apporachable. It will explain geometric concepts to programmers using plots, diagrams, code snippets and active exercises in the language of the reader’s preference. Ideally, all the formulas and equations should be put in a form of SymPy snippets, so the reader could reproduce them and play with them improving their learning. There will be mnemonics to help them remember the material. There will be examples from real-world practice. There will be didactic stories. All these technics shown effective in short on-line tutorials, there is no good reason to dismiss them now.

• What are the best videos available on this topic and how does the proposed book compare to them?
• What other resources would you recommend to someone wanting to learn this subject?
• What are the most important web sites and companies?
• Where do others interested in this topic gather?

http://www.mathforgameprogrammers.com/


7. Book size and illustrations
Please estimate:
•	The approximate number of published pages to within a 50-page range
•	The approximate number of diagrams and other graphics
•	The approximate number of code listings 

8. Contact information
Name
Mailing Address
Preferred email
Preferred phone
Website/blog
Twitter, etc

9. Schedule
•	Most authors require 2-4 weeks to write each chapter. Please estimate your writing schedule

Chapter 1: We typically expect the first chapter in about 1 month
1/3 manuscript:
2/3 manuscript:
3/3 manuscript:

•	Are there any critical deadlines for the completion of this book? New software versions? Known competition? Technical conferences?

10. Table of Contents
The table of contents is your plan for teaching your intended readers the skills they need to accomplish the objectives you’ve established for the book. While every Table of Contents is different, there are a few common best practices for a typical In Action book.

Introductory chapters
Chapter 1: The first chapter is typically an overview of the book’s topic. This chapter should tell the reader:
•	What is the book’s topic? How does it relate to other things the reader may already know? How does this topic fit into the larger context of its technology ecosystem?
•	At a high level, how does this technology work? How would you draw a picture of this technology on a whiteboard? How does it differ from other approaches?
•	What are the practical benefits of this technology? Please provide some short use cases that illustrate these benefits.

Chapter 2: The second chapter is often a brief tutorial example that shows what the technology looks like in actual use. The reader isn’t expected to understand everything in this example, and it should be simple enough to show just the important characteristics. Ideally, the reader will be able to work through the example. 

Chapter 3: If needed, you may want to include a chapter that reviews prerequisite skills that you can’t assume all readers already have. As an alternative, you might include this information in an appendix.

Core chapters
The next several chapters should cover the core aspects of the technology. Given the reader’s existing knowledge, what’s the first/next thing the reader should learn? Are there other concepts you need to introduce so that that the reader will be able to do something useful with this topic? What examples can you provide for the reader?

Next steps:
Typically, you should expect that all readers need the information in the core chapters. In later chapters, you may cover topics of interest to only certain segments of your audience.

Apply as needed
Not all books follow this pattern. If you’re proposing a book for a specific Manning series, such as In Practice, Month of Lunches, or Grokking, you’ll need to follow the pattern established by other books in that series.

Formatting the Table of Contents
At this stage, your ToC should look something like the sample below. Please number your Table of Contents in this way

1.	Chapter name
1.1.	Section 
1.1.1.	Subsection [this level is useful, but not required, in the proposal]
1.1.2.	Subsection
1.1.3.	Subsection
1.2.	Section
1.2.1.	Subsection
1.2.2.	Subsection
1.2.3.	Subsection
1.3.	Section
1.3.1.	Subsection
1.3.2.	Subsection
1.3.3.	Subsection
1.4.	Summary

•	The first section of each chapter is usually an overview of the topic that chapter covers putting the topic into its general context.
•	The final section of each chapter is a Summary.
•	You may include a brief annotation for each chapter, but the topics covered in the ToC should be clear without the annotation.
•	Every chapter should have clear objectives. “In this chapter, the reader will learn how to…”


Part 1 Basics...
1. Elements
1.1. Numbers, points, vectors, and covectors
1.2. Functions, curves, surfaces, and manifolds
1.3. Matrices, tensors, and transformations
1.4. Lines, planes, hyperplanes, and linear systems
	1.4.1. Underspecified and overspecified systesm
	1.4.2. A visual example on an interactive linear solver
2. Geometric transformations
2.1. Translation and scale
2.2. Rotation
2.2.1. Sine and cosine, and how not to mistake them for each other
2.3. Linear transformation
	2.3.1. Why is it symmetrical?
	2.3.2. Composing your own transformation by moving a few points
2.4. Affine transformations
	2.4.1. Bundling rotation, scale, and translation together




