<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Circles and lines vs. polynomial splines</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 36pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 20pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    line-height: 1.42;
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.comment {
    font-size: 12pt;
    text-align:center;
    font-family: sans-serif;
    padding-bottom: 24pt;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 0pt;
    padding-right: 0pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
    width: 505pt;
}

table {
    border-width: 0pt;
}

td {
    vertical-align: top;
    padding: 6pt 12pt 6pt 12pt;
    font-size: 16pt;
    border: 1px solid black;
    width: 600pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
    color: #000;
}


button {
    width: 128pt;
    height: 32pt;
    font-size: 16pt;
    text-align: center;
}

input[type="radio"]{
    width: 16pt;
    height: 16pt;

}

u {
    border-bottom: 1px dotted #000;
    text-decoration: none;
    cursor: pointer;
}
    </style>
    <script language="JavaScript">
// client
var w = 640.0;
var h = 640.0;

// solver specific to [0..1] parametrized splines
function spline_for(p1, p1d, p2, p2d) {
//     A = [
//         [1, 0, 0, 0],
//         [0, 1, 0, 0],
//         [1, 1, 1, 1],
//         [0, 1, 2, 3]];
//     B = [p1, p1d, p2, p2d]
    return [
        p1,
        p1d,
        3 * p2 - p2d - 3*p1 - 2*p1d,
        p2d + p1d - 2*p2 + 2*p1
    ];
}

// polynomial
function polynomial_in_t(A, t){
    var pt = 0.0;
    for(var i = 0; i < A.length; ++i){
        pt += A[i] * Math.pow(t, i);
    }
    return pt;
}

// in radians
function t_distance(t1, t2) {
    if(t2 < t1) 
        return t_distance(t1, t2 + 2*Math.PI);
    return t2-t1;
}

// biarc
function biarcs_patch_and_its_length(x1, y1, dx1, dy1, x2, y2, dx2, dy2) {
    const norm1 = Math.sqrt(dx1*dx1 + dy1*dy1);
    const norm2 = Math.sqrt(dx2*dx2 + dy2*dy2);
    dx1 /= norm1;
    dy1 /= norm1;
    dx2 /= norm2;
    dy2 /= norm2;
    
    // intersection point and intersection parameters
    const x12 = (dx1*dx2*y1 - dx1*dx2*y2 + dx1*dy2*x2 - dx2*dy1*x1)/(dx1*dy2 - dx2*dy1);
    const y12 = (dx1*dy2*y1 - dx2*dy1*y2 - dy1*dy2*x1 + dy1*dy2*x2)/(dx1*dy2 - dx2*dy1);
    const t2 = (dx1*y1 - dx1*y2 - dy1*x1 + dy1*x2)/(dx1*dy2 - dx2*dy1);
    const t1 = (dx2*y1 - dx2*y2 - dy2*x1 + dy2*x2)/(dx1*dy2 - dx2*dy1);
    
    // biarcs
    const root_piece = Math.sqrt(
        - dx1*dx1*x1*x1 + 2*dx1*dx1*x1*x2 - dx1*dx1*x2*x2 + 2*dx1*dx2*x1*x1 - 4*dx1*dx2*x1*x2 + 2*dx1*dx2*x2*x2 - 2*dx1*dy1*x1*y1 
        + 2*dx1*dy1*x1*y2 + 2*dx1*dy1*x2*y1 - 2*dx1*dy1*x2*y2 + 2*dx1*dy2*x1*y1 - 2*dx1*dy2*x1*y2 - 2*dx1*dy2*x2*y1 + 2*dx1*dy2*x2*y2 
        - dx2*dx2*x1*x1 + 2*dx2*dx2*x1*x2 - dx2*dx2*x2*x2 + 2*dx2*dy1*x1*y1 - 2*dx2*dy1*x1*y2 - 2*dx2*dy1*x2*y1 + 2*dx2*dy1*x2*y2 
        - 2*dx2*dy2*x1*y1 + 2*dx2*dy2*x1*y2 + 2*dx2*dy2*x2*y1 - 2*dx2*dy2*x2*y2 - dy1*dy1*y1*y1 + 2*dy1*dy1*y1*y2 - dy1*dy1*y2*y2 
        + 2*dy1*dy2*y1*y1 - 4*dy1*dy2*y1*y2 + 2*dy1*dy2*y2*y2 - dy2*dy2*y1*y1 + 2*dy2*dy2*y1*y2 - dy2*dy2*y2*y2 
        + 4*x1*x1 - 8*x1*x2 + 4*x2*x2 + 4*y1*y1 - 8*y1*y2 + 4*y2*y2);
    const divisor_piece = 1./(dx1*dx1 - 2*dx1*dx2 + dx2*dx2 + dy1*dy1 - 2*dy1*dy2 + dy2*dy2 - 4);

    const ax1_1 = (dx1*dx1*x1 - 2*dx1*dx2*x1 + dx1*dy1*y1 - dx1*dy1*y2 + dx2*dx2*x1 - dx2*dy1*y1 + dx2*dy1*y2 + dy1*dy1*x2 - dy1*dy2*x1 - dy1*dy2*x2 - dy1*root_piece + dy2*dy2*x1 - 4*x1)*divisor_piece;
    const ay1_1 = (dx1*dx1*y2 - dx1*dx2*y1 - dx1*dx2*y2 + dx1*dy1*x1 - dx1*dy1*x2 - dx1*dy2*x1 + dx1*dy2*x2 + dx1*root_piece + dx2*dx2*y1 + dy1*dy1*y1 - 2*dy1*dy2*y1 + dy2*dy2*y1 - 4*y1)*divisor_piece;
    const ax2_1 = (dx1*dx1*x2 - 2*dx1*dx2*x2 + dx1*dy2*y1 - dx1*dy2*y2 + dx2*dx2*x2 - dx2*dy2*y1 + dx2*dy2*y2 + dy1*dy1*x2 - dy1*dy2*x1 - dy1*dy2*x2 + dy2*dy2*x1 - dy2*root_piece - 4*x2)*divisor_piece;
    const ay2_1 = (dx1*dx1*y2 - dx1*dx2*y1 - dx1*dx2*y2 + dx2*dx2*y1 + dx2*dy1*x1 - dx2*dy1*x2 - dx2*dy2*x1 + dx2*dy2*x2 + dx2*root_piece + dy1*dy1*y2 - 2*dy1*dy2*y2 + dy2*dy2*y2 - 4*y2)*divisor_piece;
    const r1_1 = (dx1*y1 - dx1*y2 - dx2*y1 + dx2*y2 - dy1*x1 + dy1*x2 + dy2*x1 - dy2*x2 - root_piece)*divisor_piece;
    const r2_1 = -(-dx1*y1 + dx1*y2 + dx2*y1 - dx2*y2 + dy1*x1 - dy1*x2 - dy2*x1 + dy2*x2)*divisor_piece - root_piece*divisor_piece;

    const ax1_2 = (dx1*dx1*x1 - 2*dx1*dx2*x1 + dx1*dy1*y1 - dx1*dy1*y2 + dx2*dx2*x1 - dx2*dy1*y1 + dx2*dy1*y2 + dy1*dy1*x2 - dy1*dy2*x1 - dy1*dy2*x2 + dy1*root_piece + dy2*dy2*x1 - 4*x1)*divisor_piece;
    const ay1_2 = (dx1*dx1*y2 - dx1*dx2*y1 - dx1*dx2*y2 + dx1*dy1*x1 - dx1*dy1*x2 - dx1*dy2*x1 + dx1*dy2*x2 - dx1*root_piece + dx2*dx2*y1 + dy1*dy1*y1 - 2*dy1*dy2*y1 + dy2*dy2*y1 - 4*y1)*divisor_piece;
    const ax2_2 = (dx1*dx1*x2 - 2*dx1*dx2*x2 + dx1*dy2*y1 - dx1*dy2*y2 + dx2*dx2*x2 - dx2*dy2*y1 + dx2*dy2*y2 + dy1*dy1*x2 - dy1*dy2*x1 - dy1*dy2*x2 + dy2*dy2*x1 + dy2*root_piece - 4*x2)*divisor_piece;
    const ay2_2 = (dx1*dx1*y2 - dx1*dx2*y1 - dx1*dx2*y2 + dx2*dx2*y1 + dx2*dy1*x1 - dx2*dy1*x2 - dx2*dy2*x1 + dx2*dy2*x2 - dx2*root_piece + dy1*dy1*y2 - 2*dy1*dy2*y2 + dy2*dy2*y2 - 4*y2)*divisor_piece;
    const r1_2 = (dx1*y1 - dx1*y2 - dx2*y1 + dx2*y2 - dy1*x1 + dy1*x2 + dy2*x1 - dy2*x2 + root_piece)*divisor_piece;
    const r2_2 = -(-dx1*y1 + dx1*y2 + dx2*y1 - dx2*y2 + dy1*x1 - dy1*x2 - dy2*x1 + dy2*x2)*divisor_piece + root_piece*divisor_piece;

    const solution_no = (Math.abs(r1_1) + Math.abs(r2_1)) < (Math.abs(r1_2) + Math.abs(r2_2)) ? 1 : 2;
    if(solution_no == 1) {
        var ax1 = ax1_1;
        var ay1 = ay1_1;
        var ax2 = ax2_1;
        var ay2 = ay2_1;
        var r1 = r1_1;
        var r2 = r2_1;
        var cx = (ax1 + ax2) / 2.;
        var cy = (ay1 + ay2) / 2.;
        var t12 = Math.PI/2 - Math.atan2(x1 - ax1, y1 - ay1)
        var t11 = Math.PI/2 - Math.atan2(cx - ax1, cy - ay1)
        var t22 = Math.PI/2 - Math.atan2(x2 - ax2, y2 - ay2)
        var t21 = Math.PI/2 - Math.atan2(cx - ax2, cy - ay2)
    } else if(solution_no == 2){
        var ax1 = ax1_2;
        var ay1 = ay1_2;
        var ax2 = ax2_2;
        var ay2 = ay2_2;
        var r1 = r1_2;
        var r2 = r2_2;
        var cx = (ax1 + ax2) / 2.;
        var cy = (ay1 + ay2) / 2.;
        var t11 = Math.PI/2 - Math.atan2(x1 - ax1, y1 - ay1)
        var t12 = Math.PI/2 - Math.atan2(cx - ax1, cy - ay1)
        var t21 = Math.PI/2 - Math.atan2(x2 - ax2, y2 - ay2)
        var t22 = Math.PI/2 - Math.atan2(cx - ax2, cy - ay2)
    }
    const len = Math.abs(r1 * t_distance(t11, t12)) + Math.abs(r2 * t_distance(t21, t22));
    const len1 = Math.abs(r1 * t_distance(t11, t12));
    const fun = function(t) {
        if(t < len1) {
            const d = solution_no == 1 ? (1. - t / len1) :t / len1;
            const at = t11 + t_distance(t11, t12) * d;
            return [ax1 + Math.cos(at) * Math.abs(r1), ay1 + Math.sin(at) * Math.abs(r1)];
        } else {
            const d = solution_no == 1 ? (t - len1) / (len - len1) : (1. - (t - len1) / (len - len1));
            const at = t21 + t_distance(t21, t22) * d;
            return [ax2 + Math.cos(at) * Math.abs(r2), ay2 + Math.sin(at) * Math.abs(r1)];
        }
    };
    return [fun, len];
}

// arc + line
function arcline_patch_and_its_length(x1, y1, dx1, dy1, x2, y2, dx2, dy2) {
    const norm1 = Math.sqrt(dx1*dx1 + dy1*dy1);
    const norm2 = Math.sqrt(dx2*dx2 + dy2*dy2);
    dx1 /= norm1;
    dy1 /= norm1;
    dx2 /= norm2;
    dy2 /= norm2;
    
    // intersection point and intersection parameters
    const x12 = (dx1*dx2*y1 - dx1*dx2*y2 + dx1*dy2*x2 - dx2*dy1*x1)/(dx1*dy2 - dx2*dy1);
    const y12 = (dx1*dy2*y1 - dx2*dy1*y2 - dy1*dy2*x1 + dy1*dy2*x2)/(dx1*dy2 - dx2*dy1);
    const t2 = (dx1*y1 - dx1*y2 - dy1*x1 + dy1*x2)/(dx1*dy2 - dx2*dy1);
    const t1 = (dx2*y1 - dx2*y2 - dy2*x1 + dy2*x2)/(dx1*dy2 - dx2*dy1);
    
    // line segment and arcs parameters
    const a = (Math.atan2(x1 - x12, y1 - y12) - Math.atan2(x2 - x12, y2 - y12)) / 2.;
    const r = -Math.min(t1, t2) * Math.tan(a)
    if(t1 < t2) {
        var ax = -dy1*r + x1;
        var ay = dx1*r + y1;
        var t = (dx1*dy2*r - dx2*dy1*r + dx2*x1 - dx2*x2 + dy2*y1 - dy2*y2)/(dx2*dx2 + dy2*dy2);
        var ix = (dx1*dx2*dy2*r - dx2*dx2*dy1*r + dx2*dx2*x1 + dx2*dy2*y1 - dx2*dy2*y2 + dy2*dy2*x2)/(dx2*dx2 + dy2*dy2);
        var iy = (dx1*dy2*dy2*r + dx2*dx2*y2 - dx2*dy1*dy2*r + dx2*dy2*x1 - dx2*dy2*x2 + dy2*dy2*y1)/(dx2*dx2 + dy2*dy2);
        var segx1 = x2;
        var segy1 = y2;
        var segx2 = x2 + dx2 * (Math.abs(t2) - Math.abs(t1)) * Math.sign(t2);
        var segy2 = y2 + dy2 * (Math.abs(t2) - Math.abs(t1)) * Math.sign(t2);
        var at1 = Math.PI/2 - Math.atan2(segx2 - ax, segy2 - ay);
        var at2 = Math.PI/2 - Math.atan2(x1 - ax, y1 - ay);
    } else {
        var ax = dy2*r + x2;
        var ay = -dx2*r + y2;
        var t = (dx2*dy1*r - dx1*dy2*r + dx1*x2 - dx1*x1 + dy1*y2 - dy1*y1)/(dx1*dx1 + dy1*dy1);
        var ix = (dx2*dx1*dy1*r - dx1*dx1*dy2*r + dx1*dx1*x2 + dx1*dy1*y2 - dx1*dy1*y1 + dy1*dy1*x1)/(dx1*dx1 + dy1*dy1);
        var iy = (dx2*dy1*dy1*r + dx1*dx1*y1 - dx1*dy2*dy1*r + dx1*dy1*x2 - dx1*dy1*x1 + dy1*dy1*y2)/(dx1*dx1 + dy1*dy1);
        var segx1 = x1;
        var segy1 = y1;
        var segx2 = x1 + dx1 * (Math.abs(t1) - Math.abs(t2)) * Math.sign(t1);
        var segy2 = y1 + dy1 * (Math.abs(t1) - Math.abs(t2)) * Math.sign(t1);
        var at1 = Math.PI/2 - Math.atan2(x2 - ax, y2 - ay);
        var at2 = Math.PI/2 - Math.atan2(segx2 - ax, segy2 - ay);
    }        
    if(t1 < t2){
        const len = Math.abs(r * t_distance(at2, at1)) + Math.sqrt(Math.pow(segx2-segx1, 2) + Math.pow(segy2-segy1, 2));
        const len1 = Math.abs(r * t_distance(at2, at1));
        const fun = function(t) {
            if(t < len1) {
                const d = r > 0 ? t / len1 : (1. - t / len1);
                const at = r > 0 ? at2 + t_distance(at2, at1) * d : at1 + t_distance(at1, at2) * d;
                return [ax + Math.cos(at) * Math.abs(r), ay + Math.sin(at) * Math.abs(r)];
            } else {
                const d = (t - len1) / (len - len1);
                return [segx1 + (segx2 - segx1) * d, segy1 + (segy2 - segy1) * d];
            }
        };
        return [fun, len];
    } else {
        const len = Math.abs(r * t_distance(at1, at2)) + Math.sqrt(Math.pow(segx2-segx1, 2) + Math.pow(segy2-segy1, 2));
        const len1 = Math.sqrt(Math.pow(segx2-segx1, 2) + Math.pow(segy2-segy1, 2)); 
        const fun = function(t) {
            if(t < len1) {
                const d = t / len1;
                return [segx1 + (segx2 - segx1) * d, segy1 + (segy2 - segy1) * d];
            } else {
                const d = r > 0 ? ((t - len1) / (len - len1)) : (1. - (t - len1) / (len - len1));
                const at = r > 0 ? at2 + t_distance(at2, at1) * d : at1 + t_distance(at1, at2) * d;
                return [ax + Math.cos(at) * Math.abs(r), ay + Math.sin(at) * Math.abs(r)];
            }
        }; 
        return [fun, len];
    }
}

// arc + line & biarc
function combined_patch_and_its_length(x1, y1, dx1, dy1, x2, y2, dx2, dy2) {
    const norm1 = Math.sqrt(dx1*dx1 + dy1*dy1);
    const norm2 = Math.sqrt(dx2*dx2 + dy2*dy2);
    dx1 /= norm1;
    dy1 /= norm1;
    dx2 /= norm2;
    dy2 /= norm2;
    
    // intersection point and intersection parameters
    const x12 = (dx1*dx2*y1 - dx1*dx2*y2 + dx1*dy2*x2 - dx2*dy1*x1)/(dx1*dy2 - dx2*dy1);
    const y12 = (dx1*dy2*y1 - dx2*dy1*y2 - dy1*dy2*x1 + dy1*dy2*x2)/(dx1*dy2 - dx2*dy1);
    const t2 = (dx1*y1 - dx1*y2 - dy1*x1 + dy1*x2)/(dx1*dy2 - dx2*dy1);
    const t1 = (dx2*y1 - dx2*y2 - dy2*x1 + dy2*x2)/(dx1*dy2 - dx2*dy1);
    
    // line segment and arcs parameters
    if(Math.sign(t1) == Math.sign(t2)) {
        const a = (Math.atan2(x1 - x12, y1 - y12) - Math.atan2(x2 - x12, y2 - y12)) / 2.;
        const r = -Math.min(t1, t2) * Math.tan(a)
        if(t1 < t2) {
            var ax = -dy1*r + x1;
            var ay = dx1*r + y1;
            var t = (dx1*dy2*r - dx2*dy1*r + dx2*x1 - dx2*x2 + dy2*y1 - dy2*y2)/(dx2*dx2 + dy2*dy2);
            var ix = (dx1*dx2*dy2*r - dx2*dx2*dy1*r + dx2*dx2*x1 + dx2*dy2*y1 - dx2*dy2*y2 + dy2*dy2*x2)/(dx2*dx2 + dy2*dy2);
            var iy = (dx1*dy2*dy2*r + dx2*dx2*y2 - dx2*dy1*dy2*r + dx2*dy2*x1 - dx2*dy2*x2 + dy2*dy2*y1)/(dx2*dx2 + dy2*dy2);
            var segx1 = x2;
            var segy1 = y2;
            var segx2 = x2 + dx2 * (Math.abs(t2) - Math.abs(t1)) * Math.sign(t2);
            var segy2 = y2 + dy2 * (Math.abs(t2) - Math.abs(t1)) * Math.sign(t2);
            var at1 = Math.PI/2 - Math.atan2(segx2 - ax, segy2 - ay);
            var at2 = Math.PI/2 - Math.atan2(x1 - ax, y1 - ay);
        } else {
            var ax = dy2*r + x2;
            var ay = -dx2*r + y2;
            var t = (dx2*dy1*r - dx1*dy2*r + dx1*x2 - dx1*x1 + dy1*y2 - dy1*y1)/(dx1*dx1 + dy1*dy1);
            var ix = (dx2*dx1*dy1*r - dx1*dx1*dy2*r + dx1*dx1*x2 + dx1*dy1*y2 - dx1*dy1*y1 + dy1*dy1*x1)/(dx1*dx1 + dy1*dy1);
            var iy = (dx2*dy1*dy1*r + dx1*dx1*y1 - dx1*dy2*dy1*r + dx1*dy1*x2 - dx1*dy1*x1 + dy1*dy1*y2)/(dx1*dx1 + dy1*dy1);
            var segx1 = x1;
            var segy1 = y1;
            var segx2 = x1 + dx1 * (Math.abs(t1) - Math.abs(t2)) * Math.sign(t1);
            var segy2 = y1 + dy1 * (Math.abs(t1) - Math.abs(t2)) * Math.sign(t1);
            var at1 = Math.PI/2 - Math.atan2(x2 - ax, y2 - ay);
            var at2 = Math.PI/2 - Math.atan2(segx2 - ax, segy2 - ay);
        }
        const arc_t_d = r > 0 ? t_distance(at2, at1) : t_distance(at1, at2);
        if(t1 < t2){
            const len = Math.abs(r * arc_t_d) + Math.sqrt(Math.pow(segx2-segx1, 2) + Math.pow(segy2-segy1, 2));
            const len1 = Math.abs(r * arc_t_d);
            const fun = function(t) {
                if(t < len1) {
                    const d = r > 0 ? t / len1 : (1. - t / len1);
                    const at = r > 0 ? at2 + arc_t_d * d : at1 + arc_t_d * d;
                    return [ax + Math.cos(at) * Math.abs(r), ay + Math.sin(at) * Math.abs(r)];
                } else {
                    const d = (t - len1) / (len - len1);
                    return [segx2 + (segx1 - segx2) * d, segy2 + (segy1 - segy2) * d];
                }
            };
            return [fun, len];
        } else {
            const len = Math.abs(r * arc_t_d) + Math.sqrt(Math.pow(segx2-segx1, 2) + Math.pow(segy2-segy1, 2));
            const len1 = Math.sqrt(Math.pow(segx2-segx1, 2) + Math.pow(segy2-segy1, 2)); 
            const fun = function(t) {
                if(t < len1) {
                    const d = t / len1;
                    return [segx1 + (segx2 - segx1) * d, segy1 + (segy2 - segy1) * d];
                } else {
                    const d = r > 0 ? ((t - len1) / (len - len1)) : (1. - (t - len1) / (len - len1));
                    const at = r > 0 ? at2 + arc_t_d * d : at1 + arc_t_d * d;
                    return [ax + Math.cos(at) * Math.abs(r), ay + Math.sin(at) * Math.abs(r)];
                }
            }; 
            return [fun, len];
        }
    } else { // arcs
        const root_piece = Math.sqrt(
            - dx1*dx1*x1*x1 + 2*dx1*dx1*x1*x2 - dx1*dx1*x2*x2 + 2*dx1*dx2*x1*x1 - 4*dx1*dx2*x1*x2 + 2*dx1*dx2*x2*x2 - 2*dx1*dy1*x1*y1 
            + 2*dx1*dy1*x1*y2 + 2*dx1*dy1*x2*y1 - 2*dx1*dy1*x2*y2 + 2*dx1*dy2*x1*y1 - 2*dx1*dy2*x1*y2 - 2*dx1*dy2*x2*y1 + 2*dx1*dy2*x2*y2 
            - dx2*dx2*x1*x1 + 2*dx2*dx2*x1*x2 - dx2*dx2*x2*x2 + 2*dx2*dy1*x1*y1 - 2*dx2*dy1*x1*y2 - 2*dx2*dy1*x2*y1 + 2*dx2*dy1*x2*y2 
            - 2*dx2*dy2*x1*y1 + 2*dx2*dy2*x1*y2 + 2*dx2*dy2*x2*y1 - 2*dx2*dy2*x2*y2 - dy1*dy1*y1*y1 + 2*dy1*dy1*y1*y2 - dy1*dy1*y2*y2 
            + 2*dy1*dy2*y1*y1 - 4*dy1*dy2*y1*y2 + 2*dy1*dy2*y2*y2 - dy2*dy2*y1*y1 + 2*dy2*dy2*y1*y2 - dy2*dy2*y2*y2 
            + 4*x1*x1 - 8*x1*x2 + 4*x2*x2 + 4*y1*y1 - 8*y1*y2 + 4*y2*y2);
        const divisor_piece = 1./(dx1*dx1 - 2*dx1*dx2 + dx2*dx2 + dy1*dy1 - 2*dy1*dy2 + dy2*dy2 - 4);
    
        const ax1_1 = (dx1*dx1*x1 - 2*dx1*dx2*x1 + dx1*dy1*y1 - dx1*dy1*y2 + dx2*dx2*x1 - dx2*dy1*y1 + dx2*dy1*y2 + dy1*dy1*x2 - dy1*dy2*x1 - dy1*dy2*x2 - dy1*root_piece + dy2*dy2*x1 - 4*x1)*divisor_piece;
        const ay1_1 = (dx1*dx1*y2 - dx1*dx2*y1 - dx1*dx2*y2 + dx1*dy1*x1 - dx1*dy1*x2 - dx1*dy2*x1 + dx1*dy2*x2 + dx1*root_piece + dx2*dx2*y1 + dy1*dy1*y1 - 2*dy1*dy2*y1 + dy2*dy2*y1 - 4*y1)*divisor_piece;
        const ax2_1 = (dx1*dx1*x2 - 2*dx1*dx2*x2 + dx1*dy2*y1 - dx1*dy2*y2 + dx2*dx2*x2 - dx2*dy2*y1 + dx2*dy2*y2 + dy1*dy1*x2 - dy1*dy2*x1 - dy1*dy2*x2 + dy2*dy2*x1 - dy2*root_piece - 4*x2)*divisor_piece;
        const ay2_1 = (dx1*dx1*y2 - dx1*dx2*y1 - dx1*dx2*y2 + dx2*dx2*y1 + dx2*dy1*x1 - dx2*dy1*x2 - dx2*dy2*x1 + dx2*dy2*x2 + dx2*root_piece + dy1*dy1*y2 - 2*dy1*dy2*y2 + dy2*dy2*y2 - 4*y2)*divisor_piece;
        const r1_1 = (dx1*y1 - dx1*y2 - dx2*y1 + dx2*y2 - dy1*x1 + dy1*x2 + dy2*x1 - dy2*x2 - root_piece)*divisor_piece;
        const r2_1 = -(-dx1*y1 + dx1*y2 + dx2*y1 - dx2*y2 + dy1*x1 - dy1*x2 - dy2*x1 + dy2*x2)*divisor_piece - root_piece*divisor_piece;

        const ax1_2 = (dx1*dx1*x1 - 2*dx1*dx2*x1 + dx1*dy1*y1 - dx1*dy1*y2 + dx2*dx2*x1 - dx2*dy1*y1 + dx2*dy1*y2 + dy1*dy1*x2 - dy1*dy2*x1 - dy1*dy2*x2 + dy1*root_piece + dy2*dy2*x1 - 4*x1)*divisor_piece;
        const ay1_2 = (dx1*dx1*y2 - dx1*dx2*y1 - dx1*dx2*y2 + dx1*dy1*x1 - dx1*dy1*x2 - dx1*dy2*x1 + dx1*dy2*x2 - dx1*root_piece + dx2*dx2*y1 + dy1*dy1*y1 - 2*dy1*dy2*y1 + dy2*dy2*y1 - 4*y1)*divisor_piece;
        const ax2_2 = (dx1*dx1*x2 - 2*dx1*dx2*x2 + dx1*dy2*y1 - dx1*dy2*y2 + dx2*dx2*x2 - dx2*dy2*y1 + dx2*dy2*y2 + dy1*dy1*x2 - dy1*dy2*x1 - dy1*dy2*x2 + dy2*dy2*x1 + dy2*root_piece - 4*x2)*divisor_piece;
        const ay2_2 = (dx1*dx1*y2 - dx1*dx2*y1 - dx1*dx2*y2 + dx2*dx2*y1 + dx2*dy1*x1 - dx2*dy1*x2 - dx2*dy2*x1 + dx2*dy2*x2 - dx2*root_piece + dy1*dy1*y2 - 2*dy1*dy2*y2 + dy2*dy2*y2 - 4*y2)*divisor_piece;
        const r1_2 = (dx1*y1 - dx1*y2 - dx2*y1 + dx2*y2 - dy1*x1 + dy1*x2 + dy2*x1 - dy2*x2 + root_piece)*divisor_piece;
        const r2_2 = -(-dx1*y1 + dx1*y2 + dx2*y1 - dx2*y2 + dy1*x1 - dy1*x2 - dy2*x1 + dy2*x2)*divisor_piece + root_piece*divisor_piece;

        const solution_no = (Math.abs(r1_1) + Math.abs(r2_1)) < (Math.abs(r1_2) + Math.abs(r2_2)) ? 1 : 2;
        if(solution_no == 1) {
            var ax1 = ax1_1;
            var ay1 = ay1_1;
            var ax2 = ax2_1;
            var ay2 = ay2_1;
            var r1 = r1_1;
            var r2 = r2_1;
            var cx = (ax1 + ax2) / 2.;
            var cy = (ay1 + ay2) / 2.;
            var t12 = Math.PI/2 - Math.atan2(x1 - ax1, y1 - ay1)
            var t11 = Math.PI/2 - Math.atan2(cx - ax1, cy - ay1)
            var t22 = Math.PI/2 - Math.atan2(x2 - ax2, y2 - ay2)
            var t21 = Math.PI/2 - Math.atan2(cx - ax2, cy - ay2)
        } else if(solution_no == 2){
            var ax1 = ax1_2;
            var ay1 = ay1_2;
            var ax2 = ax2_2;
            var ay2 = ay2_2;
            var r1 = r1_2;
            var r2 = r2_2;
            var cx = (ax1 + ax2) / 2.;
            var cy = (ay1 + ay2) / 2.;
            var t11 = Math.PI/2 - Math.atan2(x1 - ax1, y1 - ay1)
            var t12 = Math.PI/2 - Math.atan2(cx - ax1, cy - ay1)
            var t21 = Math.PI/2 - Math.atan2(x2 - ax2, y2 - ay2)
            var t22 = Math.PI/2 - Math.atan2(cx - ax2, cy - ay2)
        }
        const len = Math.abs(r1 * t_distance(t11, t12)) + Math.abs(r2 * t_distance(t21, t22));
        const len1 = Math.abs(r1 * t_distance(t11, t12));
        const fun = function(t) {
            if(t < len1) {
                const d = solution_no == 1 ? (1. - t / len1) :t / len1;
                const at = t11 + t_distance(t11, t12) * d;
                return [ax1 + Math.cos(at) * Math.abs(r1), ay1 + Math.sin(at) * Math.abs(r1)];
            } else {
                const d = solution_no == 1 ? (t - len1) / (len - len1) : (1. - (t - len1) / (len - len1));
                const at = t21 + t_distance(t21, t22) * d;
                return [ax2 + Math.cos(at) * Math.abs(r2), ay2 + Math.sin(at) * Math.abs(r1)];
            }
        };
        return [fun, len];
    }
}

// cubic
var xs = [240,  80, 540, 560];
var ys = [ 80, 140, 560, 340];
var point_i = 0;

function init(canvas_name){
    const canvas = document.getElementById(canvas_name + "_canvas");
    const canvas_rect = canvas.getBoundingClientRect();
    draw_batch(0, 0, false);

    canvas.addEventListener('mousemove', function(e){
        var canvas_rect = canvas.getBoundingClientRect();
        draw_batch(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        if(e.buttons == 1){
            xs[point_i] = e.clientX - canvas_rect.left;
            ys[point_i] = e.clientY - canvas_rect.top;
            draw_batch(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
        }
    }, false);

    canvas.addEventListener('mousedown', function(e){
        var canvas_rect = canvas.getBoundingClientRect();
        xs[point_i] = e.clientX - canvas_rect.left;
        ys[point_i] = e.clientY - canvas_rect.top;
        draw_batch(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
    }, false);

    canvas.addEventListener('mouseleave', function(e){
        draw_batch(0, 0, false);
    }, false);
}

function draw_arrow(context, x1, y1, x2, y2, color) {
    var d = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.moveTo(x2 - (y2 - y1) * 6 / d - (x2 - x1) * 16 / d, y2 - (y2 - y1) * 16 / d + (x2 - x1) * 6 / d);
    context.lineTo(x2, y2);
    context.moveTo(x2 + (y2 - y1) * 6 / d - (x2 - x1) * 16 / d, y2 - (y2 - y1) * 16 / d - (x2 - x1) * 6 / d);
    context.lineTo(x2, y2);


    context.strokeStyle = color;
    context.stroke();
    context.closePath();
}

function draw_common(context, client_x, client_y, do_guides) {
    // dots
    for(var i = 1; i <= 2; ++i){
        context.beginPath();
        context.arc(xs[i], ys[i], 3, 0, 2*Math.PI);
        context.fillStyle="#6633AA";
        context.fill();
        context.closePath();    
    }

    // tangents
    context.lineWidth = 1;
    draw_arrow(context, xs[1], ys[1], xs[0], ys[0], "#6633AA");
    draw_arrow(context, xs[4-2], ys[4-2], xs[4-1], ys[4-1], "#6633AA");

    // guides
    if(do_guides){
        min_d = Math.pow(xs[0] - client_x, 2) + Math.pow(ys[0] - client_y, 2);
        min_i = 0;
        for(var i = 1; i < 4; ++i){
            var di = Math.pow(xs[i] - client_x, 2) + Math.pow(ys[i] - client_y, 2);
            if(di < min_d){
                min_d = di;
                min_i = i;
            }
        }
        point_i = min_i;
        context.setLineDash([4, 4]);
        context.beginPath();
        context.moveTo(xs[min_i], ys[min_i]);
        context.lineTo(client_x, client_y);
        context.strokeStyle="#6633AA";
        context.stroke();
        context.closePath();
        context.setLineDash([]);
    }
    
    // labels
    context.font = "14px Arial";
    context.fillStyle = "#000000";
    context.textBaseline = "middle"; 
    context.textAlign = "right";
    context.fillText("point 1", xs[1] - 8, ys[1]);
    context.textAlign = "left";
    context.fillText("point 2", xs[2] + 8, ys[2]);
    context.textAlign = "center";
    context.fillText("tangent 1", (xs[0] + xs[1]) / 2, (ys[0] + ys[1]) / 2);
    context.fillText("tangent 2", (xs[2] + xs[3]) / 2, (ys[2] + ys[3]) / 2);
}


var param_client_x;
var param_client_y;
var param_do_guides;
function draw_batch(client_x, client_y, do_guides) {
    draw_cubic_canvas(client_x, client_y, do_guides);
    draw_biarcs_canvas(client_x, client_y, do_guides);
    draw_arcline_canvas(client_x, client_y, do_guides);
    draw_combined_canvas(client_x, client_y, do_guides);
    
    // for param functions AND animations
    param_client_x = client_x;
    param_client_y = client_y;
    param_do_guides = do_guides;
    compute_param_functions(); 
    draw_param_canvas(client_x, client_y, do_guides);
}

function draw_cubic_canvas(client_x, client_y, do_guides) {
    var canvas = document.getElementById("cubic_canvas");
    var context = canvas.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);
 
    var Px = spline_for(xs[1], 3*(xs[0] - xs[1]), xs[2], -3*(xs[3] - xs[2]));
    var Py = spline_for(ys[1], 3*(ys[0] - ys[1]), ys[2], -3*(ys[3] - ys[2]));

    context.beginPath();
    context.lineWidth = 3;
    for(var i = 0; i < 256; ++i) {    
        var _t1 = (i) / 256;
        var _t2 = (i + 1) / 256;
        var _x1 = polynomial_in_t(Px, _t1);
        var _y1 = polynomial_in_t(Py, _t1);
        var _x2 = polynomial_in_t(Px, _t2);
        var _y2 = polynomial_in_t(Py, _t2);
        context.moveTo(_x1, _y1);
        context.lineTo(_x2, _y2);
        if(i % 32 == 31) {
            context.strokeStyle=((i / 32)%2 < 1) ? "#AABBEE" : "#AA3366";
            context.stroke();
            context.closePath();
            context.beginPath();
        }
    }
    context.strokeStyle="#AA3366";
    context.stroke();
    context.closePath();
    context.lineWidth = 1;
    
    draw_common(context, client_x, client_y, do_guides);
}

function draw_biarcs_canvas(client_x, client_y, do_guides){
    var canvas = document.getElementById("biarcs_canvas");
    var context = canvas.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);
    
    // biarcs
    const x1 = xs[1];
    const y1 = ys[1];
    const x2 = xs[2];
    const y2 = ys[2];
    var dx1 = xs[0] - xs[1];
    var dy1 = ys[0] - ys[1];
    var dx2 = xs[3] - xs[2]; 
    var dy2 = ys[3] - ys[2];
    const norm1 = Math.sqrt(dx1*dx1 + dy1*dy1);
    const norm2 = Math.sqrt(dx2*dx2 + dy2*dy2);
    dx1 /= norm1;
    dy1 /= norm1;
    dx2 /= norm2;
    dy2 /= norm2;
    const fun_len = biarcs_patch_and_its_length(x1, y1, dx1, dy1, x2, y2, dx2, dy2);
    const fun = fun_len[0];
    const len = fun_len[1];
    
    context.lineWidth = 3;
    context.strokeStyle="#00AA00";  
   
    context.beginPath();     
    for(var i = 0; i < len; i += 2) {
        const xy1 = fun(i);
        const xy2 = fun(i+2);
        if((xy1[0] >= 0 && xy1[0] <= 640 && xy1[1] >= 0 && xy1[1] <= 640)
        || (xy2[0] >= 0 && xy2[0] <= 640 && xy2[1] >= 0 && xy2[1] <= 640)) {
            context.moveTo(xy1[0], xy1[1]);
            context.lineTo(xy2[0], xy2[1]);
        }
    }
    context.stroke();  
    context.closePath();
     
    // arrows and labels    
    draw_common(context, client_x, client_y, do_guides);
}

function draw_arcline_canvas(client_x, client_y, do_guides){
    var canvas = document.getElementById("arcline_canvas");
    var context = canvas.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);
    draw_common(context, client_x, client_y, do_guides);

    // arc and line
    const x1 = xs[1];
    const y1 = ys[1];
    const x2 = xs[2];
    const y2 = ys[2];
    var dx1 = xs[0] - xs[1];
    var dy1 = ys[0] - ys[1];
    var dx2 = xs[3] - xs[2]; 
    var dy2 = ys[3] - ys[2];
    const norm1 = Math.sqrt(dx1*dx1 + dy1*dy1);
    const norm2 = Math.sqrt(dx2*dx2 + dy2*dy2);
    dx1 /= norm1;
    dy1 /= norm1;
    dx2 /= norm2;
    dy2 /= norm2;
    const fun_len = arcline_patch_and_its_length(x1, y1, dx1, dy1, x2, y2, dx2, dy2);
    const fun = fun_len[0];
    const len = fun_len[1];
    
    context.lineWidth = 3;
    context.strokeStyle="#00AA00";  
   
    context.beginPath();
    for(var i = 0; i < len; i += 2) {
        const xy1 = fun(i);
        const xy2 = fun(i+2);
        if((xy1[0] >= 0 && xy1[0] <= 640 && xy1[1] >= 0 && xy1[1] <= 640)
        || (xy2[0] >= 0 && xy2[0] <= 640 && xy2[1] >= 0 && xy2[1] <= 640)) {
            context.moveTo(xy1[0], xy1[1]);
            context.lineTo(xy2[0], xy2[1]);
        }
    }
    context.stroke();  
    context.closePath();
     
    // arrows and labels    
    draw_common(context, client_x, client_y, do_guides);    
}

function draw_combined_canvas(client_x, client_y, do_guides){
    var canvas = document.getElementById("combined_canvas");
    var context = canvas.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);
    draw_common(context, client_x, client_y, do_guides);
    
    // arc and line
    const x1 = xs[1];
    const y1 = ys[1];
    const x2 = xs[2];
    const y2 = ys[2];
    var dx1 = xs[0] - xs[1];
    var dy1 = ys[0] - ys[1];
    var dx2 = xs[3] - xs[2]; 
    var dy2 = ys[3] - ys[2];
    const norm1 = Math.sqrt(dx1*dx1 + dy1*dy1);
    const norm2 = Math.sqrt(dx2*dx2 + dy2*dy2);
    dx1 /= norm1;
    dy1 /= norm1;
    dx2 /= norm2;
    dy2 /= norm2;
    const fun_len = combined_patch_and_its_length(x1, y1, dx1, dy1, x2, y2, dx2, dy2);
    const fun = fun_len[0];
    const len = fun_len[1];
    
    context.lineWidth = 3;
    context.strokeStyle="#00AA00";  
   
    context.beginPath();
    for(var i = 0; i < len; i += 2) {
        const xy1 = fun(i);
        const xy2 = fun(i+2);
        if((xy1[0] >= 0 && xy1[0] <= 640 && xy1[1] >= 0 && xy1[1] <= 640)
        || (xy2[0] >= 0 && xy2[0] <= 640 && xy2[1] >= 0 && xy2[1] <= 640)) {
            context.moveTo(xy1[0], xy1[1]);
            context.lineTo(xy2[0], xy2[1]);
        }
    }
    context.stroke();  
    context.closePath();
     
    // arrows and labels    
    draw_common(context, client_x, client_y, do_guides);     
}


var param_Pxy;
var param_Fd;
var param_Fxy;
function compute_param_functions() {
    var Px = spline_for(xs[1], 3*(xs[0] - xs[1]), xs[2], -3*(xs[3] - xs[2]));
    var Py = spline_for(ys[1], 3*(ys[0] - ys[1]), ys[2], -3*(ys[3] - ys[2]));
    param_Pxy = function(t) {
        return [polynomial_in_t(Px, t), polynomial_in_t(Py, t)];
    }
    const x1 = xs[1];
    const y1 = ys[1];
    const x2 = xs[2];
    const y2 = ys[2];
    var dx1 = xs[0] - xs[1];
    var dy1 = ys[0] - ys[1];
    var dx2 = xs[3] - xs[2]; 
    var dy2 = ys[3] - ys[2];
    const norm1 = Math.sqrt(dx1*dx1 + dy1*dy1);
    const norm2 = Math.sqrt(dx2*dx2 + dy2*dy2);
    dx1 /= norm1;
    dy1 /= norm1;
    dx2 /= norm2;
    dy2 /= norm2;
    const fun_len = combined_patch_and_its_length(x1, y1, dx1, dy1, x2, y2, dx2, dy2);
    param_Fd = fun_len[1];
    param_Fxy = fun_len[0];
}


function draw_param_canvas(client_x, client_y, do_guides){
    var canvas = document.getElementById("param_canvas");
    var context = canvas.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);
    draw_common(context, client_x, client_y, do_guides);
    
    if(document.getElementById("method1").checked || document.getElementById("method12").checked) {
        // cubic
        var Px = spline_for(xs[1], 3*(xs[0] - xs[1]), xs[2], -3*(xs[3] - xs[2]));
        var Py = spline_for(ys[1], 3*(ys[0] - ys[1]), ys[2], -3*(ys[3] - ys[2]));
        param_Pxy = function(t) {
            return [polynomial_in_t(Px, t), polynomial_in_t(Py, t)];
        }
        
        context.beginPath();
        context.lineWidth = 3;
        for(var i = 0; i < 256; ++i) {    
            const t1 = (i) / 256;
            const t2 = (i + 1) / 256;
            const xy1 = param_Pxy(t1);
            const xy2 = param_Pxy(t2);
            context.moveTo(xy1[0], xy1[1]);
            context.lineTo(xy2[0], xy2[1]);
            if(i % 32 == 31) {
                context.strokeStyle=((i / 32) % 2 < 1) ? "#AABBEE" : "#AA3366"; // stripes
                context.stroke();
                context.closePath();
                context.beginPath();
            }
        }
        context.strokeStyle="#AA3366";
        context.stroke();
        context.closePath();
        context.lineWidth = 1;
        
        // animation        
        const t = (time / 1000 / 3) % 1.;
        const xy = param_Pxy(t);
        context.beginPath();
        context.arc(xy[0], xy[1], 5, 0, 2*Math.PI);
        context.fillStyle="#6633AA";
        context.fill();
        context.closePath();
    }
    
    if(document.getElementById("method2").checked || document.getElementById("method12").checked) {
        // arc and a line segment   
        context.lineWidth = 3;
        context.strokeStyle="#00AA00";  
           
        for(var i = 0; i < param_Fd; i += 2) {
            context.beginPath(); 
            const xy1 = param_Fxy(i);
            const xy2 = param_Fxy(i+2);
            context.moveTo(xy1[0], xy1[1]);
            context.lineTo(xy2[0], xy2[1]);
            context.strokeStyle= ((i / 32) % 2) < 1 ? "#AA0000" : "#220000"; // stripes
            context.stroke();
            context.closePath();        
        }
        
        // animation
        const t = ((time / 1000 / 3) * param_Fd) % param_Fd;
        const xy = param_Fxy(t);
        context.beginPath();
        context.arc(xy[0], xy[1], 5, 0, 2*Math.PI);
        context.fillStyle="#6633AA";
        context.fill();
        context.closePath();
    }
    draw_common(context, client_x, client_y, do_guides);    
}

function set_biarcs_1() {
    xs = [280,  80, 560, 360];
    ys = [ 60, 110, 540, 580];
    draw_batch(0, 0, false); 
}

function set_biarcs_2() {
    xs = [280,  80, 420, 560];
    ys = [ 60, 110, 320, 420];
    draw_batch(0, 0, false); 
}

function set_biarcs_3() {
    xs = [78, 240, 400, 560];
    ys = [80, 240, 400, 563];
    draw_batch(0, 0, false); 
}

function set_arcline_1() {
    xs = [220,  80, 440, 560];
    ys = [160,  80, 520, 580];
    draw_batch(0, 0, false); 
}

function set_arcline_2() {
    xs = [280,  80, 560, 360];
    ys = [ 60, 110, 540, 580];
    draw_batch(0, 0, false); 
}

function set_arcline_3() {
    xs = [80, 160, 400, 560];
    ys = [160, 80, 400, 560];
    draw_batch(0, 0, false); 
}

var curve_xs = [ 115, 203, 560, 561, 504, 412, 193, 179 ];
var curve_ys = [ 160, 134,  80, 191, 542, 518, 470, 414 ];
var curve_point_i = 0;

function init_curve_canvas() {
    const canvas = document.getElementById("curve_canvas");
    const canvas_rect = canvas.getBoundingClientRect();
    draw_curve_canvas(0, 0, false);

    canvas.addEventListener('mousemove', function(e){
        var canvas_rect = canvas.getBoundingClientRect();
        draw_curve_canvas(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        if(e.buttons == 1){
            curve_xs[curve_point_i] = e.clientX - canvas_rect.left;
            curve_ys[curve_point_i] = e.clientY - canvas_rect.top;
            draw_curve_canvas(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
        }
    }, false);

    canvas.addEventListener('mousedown', function(e){
        var canvas_rect = canvas.getBoundingClientRect();
        curve_xs[curve_point_i] = e.clientX - canvas_rect.left;
        curve_ys[curve_point_i] = e.clientY - canvas_rect.top;
        draw_curve_canvas(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
    }, false);

    canvas.addEventListener('mouseleave', function(e){
        draw_curve_canvas(0, 0, false);
    }, false);
}

function draw_curve_canvas(client_x, client_y, do_guides){
    var canvas = document.getElementById("curve_canvas");
    var context = canvas.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    var xs = curve_xs;
    var ys = curve_ys;

    // curve
    for(var i = 0; i < 4; ++i) {
        // arc and line
        const x1 = xs[i*2];
        const y1 = ys[i*2];
        const x2 = xs[(i*2+2)%8];
        const y2 = ys[(i*2+2)%8];
        var dx1 = xs[i*2+1] - xs[i*2];
        var dy1 = ys[i*2+1] - ys[i*2];
        var dx2 = xs[(i*2+2)%8] - xs[(i*2+2+1)%8];
        var dy2 = ys[(i*2+2)%8] - ys[(i*2+2+1)%8];
        const norm1 = Math.sqrt(dx1*dx1 + dy1*dy1);
        const norm2 = Math.sqrt(dx2*dx2 + dy2*dy2);
        dx1 /= norm1;
        dy1 /= norm1;
        dx2 /= norm2;
        dy2 /= norm2;
        const fun_len = combined_patch_and_its_length(x1, y1, dx1, dy1, x2, y2, dx2, dy2);
        const fun = fun_len[0];
        const len = fun_len[1];
    
        context.lineWidth = 3;
        context.strokeStyle="#00AA00";  
        context.beginPath();
        for(var j = 0; j < len; j += 2) {
            const xy1 = fun(j);
            const xy2 = fun(j+2);
            if((xy1[0] >= 0 && xy1[0] <= 640 && xy1[1] >= 0 && xy1[1] <= 640)
            || (xy2[0] >= 0 && xy2[0] <= 640 && xy2[1] >= 0 && xy2[1] <= 640)) {
                context.moveTo(xy1[0], xy1[1]);
                context.lineTo(xy2[0], xy2[1]);
            }
        }
        context.stroke();  
        context.closePath();
    }

    // dots
    for(var i = 0; i < 4; ++i){
        context.beginPath();
        context.arc(xs[i*2], ys[i*2], 3, 0, 2*Math.PI);
        context.fillStyle="#6633AA";
        context.fill();
        context.closePath();    
    }

    // tangents
    context.lineWidth = 1;
    for(var i = 0; i < 4; ++i) {
        draw_arrow(context, xs[i*2], ys[i*2], xs[i*2+1], ys[i*2+1], "#6633AA");
    }

    // guides
    if(do_guides){
        min_d = Math.pow(xs[0] - client_x, 2) + Math.pow(ys[0] - client_y, 2);
        min_i = 0;
        for(var i = 1; i < 8; ++i){
            var di = Math.pow(xs[i] - client_x, 2) + Math.pow(ys[i] - client_y, 2);
            if(di < min_d){
                min_d = di;
                min_i = i;
            }
        }
        curve_point_i = min_i;
        context.setLineDash([4, 4]);
        context.beginPath();
        context.moveTo(xs[min_i], ys[min_i]);
        context.lineTo(client_x, client_y);
        context.strokeStyle="#6633AA";
        context.stroke();
        context.closePath();
        context.setLineDash([]);
    }
}

function colorized(text) {
    const separators = ['def ', ' for ', ' else', ' if ', ' break', 'return', 'class ', ' in ', 'global ',
        '\n', ' ', '\t', '.', ',', ':', '=', '[', ']', '(', ')', '+', '-', '*', '/'];
    const quotes = ['\'', '"'];
    const comments = [['#', '\n']];

    function painted_in(line, color) {
        return line.length == 0 ? "" : "<span style=\"color:#" + color + "\">" + line + "</span>";
    }

    function colorized(token) {
        var code_sum = 0;
        for(var i = 0; i < token.length; ++i)
            code_sum += ([1, 7, 11, 13][i % 4] * token.charCodeAt(i));
        var zero_channel = code_sum % 3;
        var color = '' + (zero_channel == 0 ? '3' : '') + (1 + (code_sum % 5) * 2)
            + (zero_channel == 1 ? '3' : '') + (4 + (code_sum % 2) * 5)
            + (zero_channel == 2 ? '3' : '');
        return painted_in(token, color);
    }

    function separated(line, i) {
        if(i == separators.length)
            return colorized(line);
        return line.split(separators[i]).map(function(subline) {
            return separated(subline, i + 1);}).join(separators[i]);
    }

    function unquoted(line, i) {
        if(i == quotes.length)
            return separated(line, 0);
        var chunk_no = 0;
        return line.split('\\' + quotes[i]).join('\0').split(quotes[i]).map(function (chunk) {
            return chunk.split('\0').join('\\' + quotes[i]);}).map(function (chunk) {
                return ++chunk_no % 2  == 1 ? unquoted(chunk, i + 1) : painted_in(quotes[i] + chunk + quotes[i], "555");}).join('');
    }

    function uncommented(line, i) {
        if(i == comments.length)
            return unquoted(line, 0);
        var chunks = line.split(comments[i][0]);
        return uncommented(chunks[0], i + 1) + chunks.slice(1).map( function(chunk) {
            var in_out_comment = chunk.split(comments[i][1]);
            return painted_in(comments[i][0] + in_out_comment[0] + (in_out_comment.length > 1 ? comments[i][1] : ''), "555")
                + uncommented(in_out_comment.slice(1).join(comments[i][1]), i + 1);}).join('');
    }

    return uncommented(text, 0);
}

function draw_on_top_of_param() {
    var canvas = document.getElementById("param_canvas");
    var context = canvas.getContext("2d");
    if(document.getElementById("method1").checked || document.getElementById("method12").checked) {

    }    
    if(document.getElementById("method2").checked || document.getElementById("method12").checked) {

    }
}

var time = 0.;
function animation_tick() {
    time += 50;
    setTimeout(animation_tick, 50);
    
    draw_param_canvas(param_client_x, param_client_y, param_do_guides);
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Circles and lines vs. polynomial splines
    </h1>
    <p>
Usually, when you want to make a parametric curve, you should go for a polynomial spline of some sort. It can be a Bezier curve, which is very obviously a bunch of polynomials stacked on top of each other under a trench coat. Or in can be a NURBS which is essentially the same as Bezier but in slightly different space. It can also be a hand-crafted spline tailored for your specific task and hardly anything else. Polynomial spline is a decent choice. But it's not the only one possible.
    </p>
    <p>
Sometimes, for the reasons mentioned only in the second half of this page to keep intrigue, you are not satisfied with polynomials. You have to look elsewhere. This page shows you one possible option apart from polynomials and it is an old-school parametric curve made from arcs and line segments stitched together. Yes, it's that simple. Euclid would have been proud.
    </p>
    <h2>Cubic polynomial</h2>
    <p>
To build a smooth parametric curve we need appropriate building blocks. Smoothness means that the function has tangent vector continuity, so a decent building block for it would be something that gives you full control over its tangents in points. A cubic polynomial is a fine example.
    </p>
    <canvas id="cubic_canvas" width=640 height=640></canvas>
    <p class="comment">Points and tangents are clickable/dragable.</p>
    <p>
Two points imply two linear equations. Two tangents are two more. Four equations, four polynomial coefficients — nice little linear system. Solve it and you have your building block.
    </p> 

    <h2>Biarcs</h2>
    <p>
We can construct an alternative building blocks by making two circles go through the points so the tangents will be orthogonal to the radius vector, and then touch. The point where the circles touch is the point where they share the tangent. Then we'll cut two arcs out of them, and that's it. The pair of arcs will be our building block.
    </p>
    <p>
In SymPy equations, these conditions look like this:
    </p>
    <pre id="code_1">
# input: point and tangent
x1, y1, dx1, dy1 = symbols('x1 y1 dx1 dy1')
x2, y2, dx2, dy2 = symbols('x2 y2 dx2 dy2')

# output: arcs' centers and radiuses
ax1, ay1, ax2, ay2 = symbols('ax1 ay1 ax2 ay2')
r1, r2 = symbols('r1 r2')

solutions = solve(
   [
    r2 - r1,  # radiuses are equal
    x1 + r1*dy1 - ax1,  # radius vector is orthogonal to dx dy
    y1 - r1*dx1 - ay1,
    x2 + r2*dy2 - ax2,
    y2 - r2*dx2 - ay2,
    (ax1-ax2)**2 + (ay1-ay2)**2 - (r1+r2)**2 # circles touch
], (ax1, ay1, ax2, ay2, r1, r2))
    </pre>
    <p>
Yes, this is a quadratic system. It results in not one but two solutions. Each circle may touch the tangent from the left or from the right so it would be logical to expect four but thanks to some geometric magic, only two of these configurations result in a touching circles case. You can see <a href="...">both cases on Github</a>.
    </p>
    <p>
We only want one though, so let's just pick the one with the least sum of radiuses and see what will happen.
    </p>
    <canvas id="biarcs_canvas" width=640 height=640></canvas>
    <form onsubmit="return false;">
        <center>
        Show
        <button type="button" id="biarcs_button_1" onclick="set_biarcs_1();">good</button> &nbsp; 
        <button type="button" id="biarcs_button_2" onclick="set_biarcs_2();">bad</button> &nbsp; 
        <button type="button" id="biarcs_button_3" onclick="set_biarcs_3();">ugly</button>
        </center>
    </form>
    <p>
We have our building block. The problem is, it works ok only when tangents are contdirected-ish. As tangents become codirected, it tends to “bubble”. And when they are also codirected with the points vector, the radiuses become too big and it introduces computational and performance problems. It's a building block for very particular kind of buildings.
    </p>
    <p>
But that's easy to settle. Let's complement it with something else.
    </p>
    <h2>Arc and line segment</h2>
    <p>
And something else is an arc and a line segment. This should work with codirected tangents making nice cane-like curves where the biarc takes a giant detour.
    </p>
    <p>
An arc and a segment is again a radius vector orthogonal to the tangent of the first point, plus a segment from the second point to the point where the circle touches the second tangent ray emited from the second point. Ok, the verbal description is a little messy, let's try SymPy equations.
    </p>
    <pre id="code_2">
# input
x1, y1, dx1, dy1 = symbols('x1 y1 dx1 dy1')
x2, y2, dx2, dy2 = symbols('x2 y2 dx2 dy2')
r1 = symbols('r1') # radius is the input

# intermediate
ix, iy = symbols('ix iy')   # circle with tangent ray intersection

# output
ax1, ay1, t2 = symbols('ax1 ay1 t2')

solutions = solve(
   [
    x1 - r1*dy1 - ax1, # arc radius is orthogonal to (x1, y1)
    y1 + r1*dx1 - ay1, #
    x2 + dx2 * t2 - ix,  # intersection point is on the tangent line of (x2, y2)
    y2 + dy2 * t2 - iy,  #
    (ix-ax1)*(ix-x2)  + (iy-ay1)*(iy-y2)    # intersection is only touching the arc
], (ax1, ay1, t2, ix, iy))
    </pre>
    <p>
Ah, that's not it! You can add an equation so the SymPy will get the arc radius for you too but it takes some time. Not sure how much, let's just say more than 25 hours on my machine.
    </p>
    <p>
It's easier to compute in numerically.
    </p>
    <p>
To do that, you need to find an intersection point of the tangent rays. Then you compute the angle between the rays. Then the shortest distance from one of starting points to the point of tangent intersection mutiplied by the tangent function of the found angle is the radius. Also, the shortest distance determimnes which of the points will touch an arc and which will get the line segment. Again, I'm not sure that the words are helping, the <a href="...">code for this is on Github</a>.
    </p>
    <canvas id="arcline_canvas" width=640 height=640></canvas>
    <form onsubmit="return false;">
        <center>
        Show
        <button type="button" id="arcline_button_1" onclick="set_arcline_1()">good</button> &nbsp; 
        <button type="button" id="arcline_button_2" onclick="set_arcline_2()">bad</button> &nbsp; 
        <button type="button" id="arcline_button_3" onclick="set_arcline_3()">ugly</button>
        </center>
    </form>
    <p>
This building block isn't perfect either. Where the tangents are controriented, the point where the arc meets the segment will appear sharp. Also, it still tends to take detours. But it complements the biarcs. In most of the cases biarcs fail, it works fine. 
    </p>
    
    <h2>Combined method</h2>
    <p>
Since we have biarcs that work half the time and arc-and-lines that works half of the time, why don't we combine them and hope this would work all the time? All we have to do is to decide when to run the former and when the latter.
    </p>
    <p>
I think the nice criterion is how the tangents are oriented towards each other. If they share a half-plane, meaning they are more or less cooriented, then the arc and line would be the good choice. If they don't share the same halfplane, so more like controriented, then the biarcs should work.
    </p>
    <p>
Again, it might be easier to read code than the explanation, so <a href="">it's also on GitHub</a> like everything else here.
    </p>
    <canvas id="combined_canvas" width=640 height=640></canvas>
    <p class="comment">
Just a reminder, this is a live plot. Points and tangents are movable.
    </p>
    <h2>Parameterization</h2>
    <p>
And now for the “why bother” part. Let's say you want something to go along the curve with constant speed. With polynomials, this is possible but complicated. You'd have to measure polynomials' derivatives, compute the curve own “speed” and then compensate for it doing small steps of different parameter increment. It's doable but cumbersome.
    </p>
    <p>
With arcs and segmetns, this task is trivial. Line segment is linear by definition and circle is parametrized by its radial coordinate, so like a motorcycle goes with constant speed with constant revs, the object will go along the curve with a constant speed if the parameterization changes constantly.
    </p>
    <canvas id="param_canvas" width=640 height=640></canvas>
    <form onsubmit="return false;">
        <center>
        <input type="radio" name="method" id="method1" value="cubic" onclick="draw_param_canvas(0, 0, false);"><label for="method1">cubic only</label> &nbsp; 
        <input type="radio" name="method" id="method2" value="combined" checked="true" onclick="draw_param_canvas(0, 0, false);"><label for="method2">ars and lines only</label> &nbsp; 
        <input type="radio" name="method" id="method12" value="both" onclick="draw_param_canvas(0, 0, false);"><label for="method12">both</label> &nbsp; 
        </center>
    </form>    
    <p>
Also, since it's trivial to compute arcs length, it's easy to parametrize these curves not only linearly but in their natural size. For instance, I can make a small circle run around the track with the speed of exactly 50 pixels per second.
    </p>
    <canvas id="curve_canvas" width=640 height=640></canvas>
    <p>
Of course, this approach has its flaws. It still doesn't work for when tangents and points all lie on the same line. It requires classification to chose among 4 possible solutions and this contributes to the algorithm size and perfromance. Polynomials are simpler.
    </p>
    <p>
But it's only one possible approach of infinite number of possible approaches. This exercise shows that you can build your own parametric curves with desired properties and not rely on some particular mathematical apparatus. The options are limitles.
    </p>
    <p>
By the way, if you know a better option for regularily parametrized parametric curves (wich are not NURBS), please <a href="mailto:ok@wordsandbuttons.online">let me know</a>.
    </p>
            
    <script language="JavaScript">
    // init all canvases in a batch
    init("cubic");
    init("biarcs");
    init("arcline");
    init("combined");
    init("param");
    init_curve_canvas();
    animation_tick();
    document.getElementById("code_1").innerHTML = colorized(document.getElementById("code_1").innerHTML);
    document.getElementById("code_2").innerHTML = colorized(document.getElementById("code_2").innerHTML);
    </script>
                
    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
    <tr>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
        <a href="index.html"><img src="favicon.ico"></a>
    </td>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
        &nbsp;&larr; there's more.
    </td>
    <td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
        +
        <a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
        <a href="https://twitter.com/wordsandbuttons">Twitter</a> &
        <a href="https://news.ycombinator.com/from?site=wordsandbuttons.online">Hacker News</a>
    </td>
    </tr>
    </table>
    </center>
  </body>
</html>
