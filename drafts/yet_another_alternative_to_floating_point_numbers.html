<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Yet another alternative to floating point numbers</title>
	<meta name="description" content="This shows how rational bounds may not only account for the input error but keep computational error under control as well.">
	<meta name="keywords" content="mathematics, programming, demos">
	<link rel="shortcut icon" type="image/x-icon" href="favicon.svg" />
	<style>
body {
	margin: 0 0 0 0;
}

a {
	text-decoration: none;
}

h1 {
	padding-top: 36pt;
	font-size: 24pt;
	width: 600pt;
	text-align: left;
}

h2 {
	padding-top: 20pt;
	font-size: 20pt;
	width: 555pt;
	text-align: left;
}

p {
	line-height: 1.42;
	font-size: 16pt;
	width: 505pt;
	text-align: left;
}

pre {
	margin: 0 0 0 0;
	padding-top: 12pt;
	padding-left: 12pt;
	padding-right: 12pt;
	padding-bottom: 12pt;
	font-size: 12pt;
	text-align: left;
}

table {
	border-width: 0pt;
}

td {
	vertical-align: top;
	padding: 6pt 12pt 6pt 12pt;
	font-size: 16pt;
	border: 1px solid black;
	width: 505pt;
}

button {
	width: 248pt;
	height: 42pt;
	margin-left:4pt;
	margin-right:4pt;
	font-size: 16pt;
}

u {
	border-bottom: 1px dotted #000;
	text-decoration: none;
	cursor: pointer;
}
	</style>
	<script language="JavaScript">
function show(n){
	document.getElementById("shown_" + n).style.display = "none";
	document.getElementById("hidden_" + n).style.display = "inline";
}

function hide(n){
	document.getElementById("shown_" + n).style.display = "inline";
	document.getElementById("hidden_" + n).style.display = "none";
}

const slider_w = 608;
const slider_h = 84;
const slider_margin_left = 32;
const slider_margin_right = 32;
const slider_margin_top = 12;
const slider_margin_bottom = 12;

var slider_lb = [];
var slider_ub = [];
var slider_min_x = [];
var slider_max_x = [];
var slider_down = [];


function position_slider(no, client_x) {
	const lb = slider_lb[no];
	const ub = slider_ub[no];
	const min_x = slider_min_x[no];
	const max_x = slider_max_x[no];
	
	var x = (client_x - slider_margin_left) / (slider_w - slider_margin_right - slider_margin_left);
	x = min_x + x * (max_x - min_x);
	x = Math.max(x, min_x);
	x = Math.min(x, max_x);
	if(Math.abs(x - lb) < Math.abs(x - ub))
		slider_lb[no] = x;
	else
		slider_ub[no] = x;
}

function init_slider(no, min_x, max_x, initial_lb, initial_ub, x_template, on_slide){
	var slider = document.getElementById("interval_" + String(no));
	// is this the JS lexical scope abuse? Maybe.
	slider_min_x[no] = min_x;
	slider_max_x[no] = max_x;
	slider_lb[no] = initial_lb;
	slider_ub[no] = initial_ub;
	slider_down[no] = false;
	draw_slider(no, x_template);

	slider.addEventListener('mouseleave', function(e){
		slider_down[no] = false;
	}, false);

	slider.addEventListener('mouseup', function(e){
		slider_down[no] = false;
	}, false);

	slider.addEventListener('mousedown', function(e){
		slider_down[no] = true;
		var canvas_rect = slider.getBoundingClientRect();
		position_slider(no, e.clientX - canvas_rect.left);
		on_slide(slider_lb[no], slider_ub[no]);
		draw_slider(no, x_template);
	}, false);

	slider.addEventListener('mousemove', function(e){
		if(slider_down[no] == true){
			var canvas_rect = slider.getBoundingClientRect();
			position_slider(no, e.clientX - canvas_rect.left);
			on_slide(slider_lb[no], slider_ub[no]);
			draw_slider(no, x_template);
		}
	}, false);
}

function draw_slider(no, x_template){
	var slider = document.getElementById("interval_" + String(no));
	ctx = slider.getContext("2d");
	const lb = slider_lb[no];
	const ub = slider_ub[no];
	const min_x = slider_min_x[no];
	const max_x = slider_max_x[no];

	ctx.clearRect(0, 0, slider_w, slider_h);
	ctx.strokeStyle="#444444";
	ctx.fillStyle="#BBBBBB";
	const dw = slider_w - slider_margin_right - slider_margin_left;
	const dh = slider_h - slider_margin_top - slider_margin_bottom;

	ctx.fillRect(slider_margin_left, slider_margin_top, dw, dh);
	const lb01 = (lb - min_x) / (max_x - min_x);
	const ub01 = (ub - min_x) / (max_x - min_x);
	ctx.strokeStyle="#000000";
	ctx.fillStyle="#777777";
	ctx.fillRect(slider_margin_left + dw * lb01, slider_margin_top, dw * (ub01 - lb01), dh);

	ctx.font = "16px sans-serif";
	ctx.fillStyle="#d64562";
	// the whole interval
	ctx.textBaseline = "top";
	ctx.textAlign = "left";
	ctx.fillText("[" + x_template.replace("%x", String(min_x)) + ",", slider_margin_left + 6, slider_margin_top + 6);
	ctx.textAlign = "right";
	ctx.fillText(x_template.replace("%x", String(max_x)) + "]", slider_w - slider_margin_right - 6, slider_margin_top + 6);
	// the selected interval
	ctx.fillStyle="#942b3b";
	ctx.textBaseline = "bottom";
	ctx.textAlign = "left";
	const left_piece_text = "[" + x_template.replace("%x", lb.toFixed(2)) + ",";
	const left_width = ctx.measureText(left_piece_text).width;
	const left_piece_x = slider_margin_left + dw * lb01 + 6;
	const right_piece_x = slider_margin_left + dw * ub01 - 6;
	const right_piece_text = x_template.replace("%x", ub.toFixed(2)) + "]";
	const right_width = ctx.measureText(right_piece_text).width;
	if(right_piece_x - left_piece_x - right_width - 12 > left_width)
		ctx.fillText(left_piece_text, left_piece_x, slider_h - slider_margin_bottom - 6);
	else
		ctx.fillText(left_piece_text + " " + right_piece_text, left_piece_x, slider_h - slider_margin_bottom - 6);
	ctx.textAlign = "right";
	if(right_piece_x - left_piece_x - right_width - 12 > left_width)
		ctx.fillText(right_piece_text, right_piece_x, slider_h - slider_margin_bottom - 6);
}

function colorized(text) {
	const separators = ['function ', ' if(', 'return ', 'var ', 'const ', ' for(',
		'\n', ' ', '\t', '.', ',', ':', ';', '+', '-', '/', '*', '(', ')', '<', '>', '[', ']', '{', '}',
		'==', '!=', '<=', '>=', '=', '-=', '+=', '*=', '/='];
	const quotes = ['\'', '"'];
	const comments = [['//', '\n'], ['/*', '*/']];

	function painted_in(line, color) {
		return line.length == 0 ? "" : "<span style=\"color:#" + color + "\">" + line + "</span>";
	}

	function colorized(token) {
		var code_sum = 0;
		for(var i = 0; i < token.length; ++i)
			code_sum += ([1, 7, 11, 13][i % 4] * token.charCodeAt(i));
		var zero_channel = code_sum % 3;
		var color = '' + (zero_channel == 0 ? '3' : '') + (1 + (code_sum % 5) * 2)
			+ (zero_channel == 1 ? '3' : '') + (4 + (code_sum % 2) * 5)
			+ (zero_channel == 2 ? '3' : '');
		return painted_in(token, color);
	}

	function separated(line, i) {
		if(i == separators.length)
			return colorized(line);
		return line.split(separators[i]).map(function(subline) {
			return separated(subline, i + 1);}).join(separators[i]);
	}

	function unquoted(line, i) {
		if(i == quotes.length)
			return separated(line, 0);
		var chunk_no = 0;
		return line.split('\\' + quotes[i]).join('\0').split(quotes[i]).map(function (chunk) {
			return chunk.split('\0').join('\\' + quotes[i]);}).map(function (chunk) {
				return ++chunk_no % 2  == 1 ? unquoted(chunk, i + 1) : painted_in(quotes[i] + chunk + quotes[i], "555");}).join('');
	}

	function uncommented(line, i) {
		if(i == comments.length)
			return unquoted(line, 0);
		var chunks = line.split(comments[i][0]);
		return uncommented(chunks[0], i + 1) + chunks.slice(1).map( function(chunk) {
			var in_out_comment = chunk.split(comments[i][1]);
			return painted_in(comments[i][0] + in_out_comment[0] + (in_out_comment.length > 1 ? comments[i][1] : ''), "555")
				+ uncommented(in_out_comment.slice(1).join(comments[i][1]), i + 1);}).join('');
	}

	return uncommented(text.split('&lt;').join('<').split('&gt;').join('>'), 0);
}

const max_relative_errors = [3.3675e-08, 29.3984, 7.60319e+09];
function log10(x) {	// for IE compatibility
	return Math.log(x) / Math.log(10);
}
const log10_max_relative_errors = [log10(max_relative_errors[0]), log10(max_relative_errors[1]), log10(max_relative_errors[2])];
	</script>
</head>
<body>
	<center>
	<h1>
Yet another alternative to floating point numbers
	</h1>
	<p>
Floating point numbers are fine. They are decently designed and well standardized, they provide a good compromise between performance and precision. They work great most of the time. Until the day when they suddenly don't and nobody knows why.
	</p>
	<p>
For me, that day came when I got a complaint about a bug in a Taubin smoothing estimator. <a href="https://graphics.stanford.edu/courses/cs468-01-fall/Papers/taubin-smoothing.pdf">Taubin smoothing</a> takes a triangle mesh, a pair of magic numbers called &lambda; and &mu;, a little time to think, and it makes the mesh smooth. It also makes sure that the mesh isn't reduced to a perfectly smooth but rather uninteresting sphere or a point.
	</p>
	<p>
The first magic number &lambda; is something between 0 and 1. When it's 0 — nothing happens at all, and when it's 1 — nothing good happens either. It should be somewhere in between. Nobody really knows how to pick this number but an experienced engineer can at least make an educated guess. 
	</p>
	<p>
The second magic number governs the shrinkage compensation. It's a negative number slightly greater than &lambda; in its absolute value. Nodoby knows how to pick it either but this time even an educated guess is a challenge.
	</p>
	<p>
That's why you need an estimator. Something that picks the &mu; for you. And we have one. And it was bugged. And I was the one to fix it.
	</p>
	<p>
The first day of investigation showed that the estimator is in fact entirely correct. The second day of invetigation showed that the tests covering the bug are just as well correct. The third day of investigation brought a promising hypothesis that the whole story is just a bad dream and all it takes to solve the mystery is to wake up. The fourth morning killed that hypothesis just as many others before.
	</p>
	<p>
Luckily I have a friend who is smarter than me and he advised to fuzz the input a little and see what will happen. I did. And somehting happened. The bug didn't go away but the &mu; changed unproportionally large for the small changes in the input. Fascinating!
	</p>
	<p>
We all know that computations work with some error. It's fine, we get input data from sensors and they work with some error. We print out our finished models, and the printers have some limited precision as well. It's all good while the error is small. But what if it isn't?
	</p>
	<p>
In my case, a completely correct algorithm had a computational error of about 1. Not 1e-16 or 1e-5 but 1. Just 1. So if you expect your &mu; to be somewhat close to -0.7, and the estimator says it's 0.3, it is in fact correct. It is still a correct estimation within its error range.
	</p>
	<p>
Correct but entirely useless.
	</p>
	<h2>
Challenge your intuition with guess an error game
	</h2>
	<div id="shown_code_1">
	<span style="line-height: 2.0;">
	<button type="button" onclick="show('code_1')">Show the code</button>
	</span>
	</div>
	<div id="hidden_code_1" style="display: none">
	<table><tr>
	<td>
	<pre id="code_1">
// find roots for ax^3 + bx^2 + cx + d = 0
std::array&lt;double, 3&gt; roots_for_cubic(std::array&lt;double, 4&gt; abcd) {
    double PI = std::atan(1.) * 4.;

    double a1 = abcd[1] / abcd[0];
    double a2 = abcd[2] / abcd[0];
    double a3 = abcd[3] / abcd[0];
    double q = (a1 * a1 - 3. * a2) / 9.;
    double sq = -2. * std::sqrt(q);
    double r = (2. * a1 * a1 * a1 - 9. * a1 * a2 + 27. * a3) / 54.0;
    double z = r * r - q * q * q;

    std::array&lt;double, 3&gt; roots;
    if(z &lt;= 0.) {
        double t = std::acos(r / std::sqrt(q * q * q));
        roots[0] = sq * std::cos(t / 3.) - a1 / 3.;
        roots[1] = sq * std::cos((t + 2. * PI) / 3.) - a1 / 3.;
        roots[2] = sq * std::cos((t + 4. * PI) / 3.) - a1 / 3.;
    } else {
        roots[0] = pow(std::sqrt(z) + std::abs(r) , 1. / 3.);
        roots[0] += q / roots[0];
        roots[0] *= ( r &lt; 0. ) ? 1 : -1;
        roots[0] -= a1 / 3.;
        roots[1] = std::numeric_limits&lt;double&gt;::quiet_NaN();
        roots[2] = std::numeric_limits&lt;double&gt;::quiet_NaN();
    }
    return roots;
}

// find polynomial coefficients a, b, c, and d for the roots
std::array&lt;double, 4&gt; cubic_for_roots(std::array&lt;double, 3&gt; xs) {
    return {1. // one of them should be set as a constant
    , - (xs[0] + xs[1] + xs[2])
    , + (xs[0] * xs[1] + xs[1] * xs[2] + xs[2] * xs[0])
    , - (xs[0] * xs[1] * xs[2])};
}
	</td></tr></table>
	<span style="line-height: 2.0;">
	<button type="button" onclick="hide('code_1')">Hide the code</button>
	</span>
	</div>
	<br>
	<canvas id="interval_0" width=608 height=128></canvas>

	<p>
...
	</p>

	<script language="JavaScript">
	init_slider(0, 0, 10, 2, 5, "10^%x", function(lb, ub) {console.log([lb, ub]);});
	document.getElementById("code_1").innerHTML = colorized(document.getElementById("code_1").innerHTML);
	</script>

	<table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
	<tr>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
		<a href="index.html"><img src="favicon.svg"></a> 
	</td>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
		&nbsp;&larr; there's more.
	</td>
	<td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
		+
		<a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
		<a href="https://wordsandbuttons.online/rss"><span style="letter-spacing: 1pt;">RSS</span></a>
	</td>
	</tr>
	</table>
	</center>
</body>
</html>
