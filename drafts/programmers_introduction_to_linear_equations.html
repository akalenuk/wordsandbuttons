<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Вступ до&nbsp;лінійних рявнянь для програмістів</title>
    <meta name="keywords" content="programming,linear equations,linear systems,tutorial,introduction,learning">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 32pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 16pt;
    font-size: 20pt;
    width: 575pt;
    text-align: left;
}

p {
    font-size: 16pt;
    width: 545pt;
    text-align: left;
}

.results {
    font-family: sans-serif;
    font-size: 14pt;
    width: 505pt;
    text-align: left;
}

.comment {
    font-size: 12pt;
    text-align:center;
    font-family: sans-serif;
    padding-bottom: 24pt;
}

.formula {
    font-family: monospace;
    font-size: 16pt;
    font-style: italic;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

table.footer {
    padding: 64pt 0pt 32pt 0pt;
    background-color: transparent;
    width: 505pt;
}

td.footer {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: normal;
    padding: 0;
    margin: 0;
    border: 0;
}

li {
    font-size: 16pt;
    width: 545pt;
    text-align: left;
    padding-bottom: 6pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 545pt;
    background-color: #eeee99;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-bottom: 12pt;
    font-size: 12pt;
    text-align: left;
}

table {
    border-width: 0pt;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    font-family: monospace;
    text-align: center;
}

table td {
    padding: 0pt 3pt 0pt 3pt;
    margin: 0 0 0 0;
    border-width: 0pt;
}

.brackets {
    font-size:32pt;
    padding-bottom:2pt;
    font-family: sans-serif;
    font-weight: 100;
    font-style: normal;
}

input[type="text"] {
    width: 20pt;
    height: 22pt;
    margin: 0;
    padding-left: 1pt;
    font-size: 14pt;
}

button {
    width: 108pt;
    height: 28pt;
    margin-left:4pt;
    margin-right:4pt;
    font-size: 16pt;
}

.incdec {
    width: 22pt;
    height: 22pt;
    margin-left: 1pt;
    margin-right: 1pt;
    font-size: 14pt;
}
    </style>
    <script language="JavaScript">
// quest count
var quests = [0, 0, 0, 0, 0, 0, 0, 0, 0];
var hidden_quests = [0, 0, 0];

// client
var w = 640.0;
var h = 512.0;

// visible region
var x_min = -1.0;
var y_min = -1.0;
var x_max = 5.0;
var y_max = 4.0;

// colors
var line_colors = ["#d64562", "#457fd6", "#62d645"];
var fill_colors = ["#e3bfc3", "#bfc7e3", "#c4e3bf"];


var client_x_center = w*(0-x_min)/(x_max-x_min);
var client_x_step = (w/(x_max-x_min));

var client_y_center = h - h*(0-y_min)/(y_max-y_min);
var client_y_step = (h/(y_max-y_min));

function client_to_x(client_x){
    return (client_x - client_x_center) / client_x_step;
}

function client_to_y(client_y){
    return (client_y_center - client_y) / client_y_step;
}

function x_to_client(x){
    return x * client_x_step + client_x_center;
}

function y_to_client(y){
    return client_y_center - y * client_y_step;
}

function draw_grid_on(context){
    context.font = "16px sans-serif";
    // axes
    context.beginPath();
    context.moveTo(0, client_y_center);
    context.lineTo(w, client_y_center);
    context.lineTo(w - 12, client_y_center - 5);
    context.moveTo(w, client_y_center);
    context.lineTo(w - 12, client_y_center + 5);
    context.moveTo(client_x_center, h);
    context.lineTo(client_x_center, 0);
    context.lineTo(client_x_center - 5, 12);
    context.moveTo(client_x_center, 0);
    context.lineTo(client_x_center + 5, 12);
    context.fillStyle="#000000";
    // numbers
    for(var i = x_min + 1; i <= x_max - 1; i++){
        context.moveTo(client_x_center + i*client_x_step, client_y_center);
        context.lineTo(client_x_center + i*client_x_step, client_y_center - 5);
        context.fillText(i, client_x_center + i*client_x_step + 4, client_y_center + 16);
    }
    for(var i = y_min + 1; i <= y_max - 1; i++){
        context.moveTo(client_x_center, client_y_center - i*client_y_step);
        context.lineTo(client_x_center + 5, client_y_center - i*client_y_step);
        context.fillText(i, client_x_center + 5, client_y_center - i*client_y_step + 16);
    }
    // letters
    context.fillText("X1", client_x_center + x_max*client_x_step - 24, client_y_center - 16);
    context.fillText("X2", client_x_center - 30, client_y_center - y_max*client_y_step + 16);

    context.strokeStyle="#000000";
    context.stroke();
    context.closePath();
}

function dot_of(a11, a12, a21, a22){
    return a11*a21 + a12*a22;
}

function length_of(a1, a2){
    return Math.sqrt(dot_of(a1, a2, a1, a2));
}

function projected_x(x, y, a1, a2, b){
    return x + a1 * (b - dot_of(x, y, a1, a2)) / dot_of(a1, a2, a1, a2);
}

function projected_y(x, y, a1, a2, b){
    return y + a2 * (b - dot_of(x, y, a1, a2)) / dot_of(a1, a2, a1, a2);
}

function get_points_on_the_ends(a1, a2, b) {    // I need a beter algo (classifier) for this
    var xys = []

    if(a1 == 0.0)
        return [[x_min, b / a2], [x_max, b / a2]];
    if(a2 == 0.0)
        return [[b / a1, y_min], [b / a1, y_max]];

    var x_in_y_min = (b - a2 * y_min) / a1;
    if(x_in_y_min >= x_min && x_in_y_min < x_max)
        xys.push([x_in_y_min, y_min]);

    var x_in_y_max = (b - a2 * y_max) / a1;
    if(x_in_y_max >= x_min && x_in_y_max < x_max)
        xys.push([x_in_y_max, y_max]);

    var y_in_x_min = (b - a1 * x_min) / a2;
    if(y_in_x_min >= y_min && y_in_x_min < y_max)
        xys.push([x_min, y_in_x_min]);

    var y_in_x_max = (b - a1 * x_max) / a2;
    if(y_in_x_max >= y_min && y_in_x_max < y_max)
        xys.push([x_max, y_in_x_max]);

    if(xys.length < 2)
        return get_points_on_the_ends(a1 + 0.001, a2 - 0.001, b + 0.001);
    return xys;
}

function equation_for_two_points(x1, y1, x2, y2) {
    return [1.0, (-x1 + x2)/(y1 - y2), (-x1*y2 + x2*y1)/(y1 - y2)];
}

function new_equation_for_one_point(a1, a2, b, x, y) {
    var xys = get_points_on_the_ends(a1, a2, b);
    if(length_of(x - xys[0][0], y - xys[0][1]) > length_of(x - xys[1][0], y - xys[1][1])) {
        return equation_for_two_points(x, y, xys[0][0], xys[0][1]);
    } else {
        return equation_for_two_points(x, y, xys[1][0], xys[1][1]);
    }
}

function solve_2(a11, a12, b1, a21, a22, b2) {
    sx = (-a12*b2 + a22*b1)/(a11*a22 - a12*a21);
    sy = (a11*b2 - a21*b1)/(a11*a22 - a12*a21);
    return [sx, sy];
}


//////
/// simple plots
function find_nearest_eqution_id(name, client_x, client_y) {
    var x = client_to_x(client_x);
    var y = client_to_y(client_y);
    var closest_eq_i = 0;
    var eq0 = eval(name + "_eq_1");
    var x0 = projected_x(x, y, eq0[0], eq0[1], eq0[2]);
    var y0 = projected_y(x, y, eq0[0], eq0[1], eq0[2]);
    var closest_distance = length_of(x - x0, y - y0);
    for(var i = 1; i < eval(name + "_eqs"); ++i) {
        var eq = eval(name + "_eq_" + (i+1));
        var xi = projected_x(x, y, eq[0], eq[1], eq[2]);
        var yi = projected_y(x, y, eq[0], eq[1], eq[2]);
        var distancei = length_of(x - xi, y - yi);
        if (distancei < closest_distance) {
            closest_distance = distancei;
            closest_eq_i = i;
        }
    }
    return closest_eq_i + 1;
}

function invalidate_plot_named(name) {
    var temp_id = eval(name + "_eq_temp_id");
    eval(name + "_eq_" + temp_id + " = " + name + "_eq_" + temp_id + "_temp;");
    draw_plot_named(name, 0, 0, false);
    update_system(name);
    update_matrix(name);
}

function init_plot_named(name) {
    plot = document.getElementById(name);
    var canvas_rect = plot.getBoundingClientRect();
    invalidate_plot_named(name);

    plot.addEventListener('mousemove', function(e){
       var canvas_rect = plot.getBoundingClientRect();
       draw_plot_named(name, e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
       if(e.buttons == 1){
           invalidate_plot_named(name);
       } else if(e.buttons == 0){
            nearest_eq_id = find_nearest_eqution_id(name, e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
            eval(name + "_eq_temp_id = nearest_eq_id;");
       }
    }, false);

    plot.addEventListener('mousedown', function(e){
        invalidate_plot_named(name);
        var canvas_rect = plot.getBoundingClientRect();
        nearest_eq_id = find_nearest_eqution_id(name, e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
        eval(name + "_eq_temp_id = nearest_eq_id;");
    }, false);

    plot.addEventListener('mouseup', function(e){
        invalidate_plot_named(name);
    }, false);

    plot.addEventListener('mouseleave', function(e){
       draw_plot_named(name, 0, 0, false);
    }, false);
}

function draw_plot_named(name, client_x, client_y, do_guides) {
    plot = document.getElementById(name);
    var context = plot.getContext("2d");

    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // equations
    for(var i = 0; i < eval(name + "_eqs"); ++i) {
        context.beginPath();
        var eq = eval(name + "_eq_" + (i+1));
        var xys = get_points_on_the_ends(eq[0], eq[1], eq[2]);
        context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
        context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
        context.strokeStyle = line_colors[i];
        context.lineWidth = 2;
        context.stroke();
        context.closePath();
        context.lineWidth = 1;
    }

    // grid
    draw_grid_on(context);

    if(do_guides){
        // draw the quide
        var closest_eq_id = eval(name + "_eq_temp_id");
        var closest_eq = eval(name + "_eq_" + closest_eq_id);
        var x = client_to_x(client_x);
        var y = client_to_y(client_y);
        var temp_eq = new_equation_for_one_point(closest_eq[0], closest_eq[1], closest_eq[2], x, y);
        eval(name + "_eq_" + closest_eq_id + "_temp = temp_eq;");
        context.beginPath();
        var xys = get_points_on_the_ends(temp_eq[0], temp_eq[1], temp_eq[2]);
        context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
        context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
        context.strokeStyle = line_colors[closest_eq_id - 1];
        context.setLineDash([4, 4]);
        context.stroke();
        context.setLineDash([]);
        context.closePath();
    }
}



//////
/// equations and matrix
function printable(a) {
    a_trimmed = Number(a.toFixed(2));
    if (Math.floor(a_trimmed) == a_trimmed)
        return a_trimmed;
    return a.toFixed(2);
}

function coefficient1(a, x) {
    a_trimmed = Number(a.toFixed(2));
    if (a_trimmed == 1)
        return x;
    if (a_trimmed == -1)
        return "-" + x;
    if (a_trimmed == 0)
        return "";
    return printable(a) + x;
}

function coefficient2(a, x) {
    a_trimmed = Number(a.toFixed(2));
    if (a_trimmed == 1)
        return " + " + x;
    if (a_trimmed == -1)
        return " - " + x;
    if (a_trimmed == 0)
        return "";
    if (a_trimmed > 0)
        return " + " + printable(a) + x;
    if (a_trimmed < 0)
        return " - " + -printable(a) + x;
}

function printable_eq(a1, x1, a2, x2, b) {
    if (Number(a1.toFixed(2)) == 0.0 && Number(a2.toFixed(2)) == 0.0)
        return "Not a valid equation; both coefficients are 0."
    if (Number(a1.toFixed(2)) == 0.0)
        return coefficient1(a2, x2) + " = " + printable(b);
    return coefficient1(a1, x1) + coefficient2(a2, x2) + " = " + printable(b);
}

function update_matrix(name) {
    if(document.getElementById(name + "_matrix_col1") == null)
        return;

    var eq1 = eval(name + "_eq_1");
    var eq2 = eval(name + "_eq_2");
    document.getElementById(name + "_matrix_col1").innerHTML =
        printable(eq1[0]) + "<br>" + printable(eq2[0]);
    document.getElementById(name + "_matrix_col2").innerHTML =
        printable(eq1[1]) + "<br>" + printable(eq2[1]);
    document.getElementById(name + "_matrix_col3").innerHTML =
        printable(eq1[2]) + "<br>" + printable(eq2[2]);
}

function update_system(name) {
    if(document.getElementById(name + "_system_row1") == null)
        return;

    var eq1 = eval(name + "_eq_1");
    var eq2 = eval(name + "_eq_2");
    document.getElementById(name + "_system_row1").innerHTML =
        printable_eq(eq1[0], "x<sub>1</sub>", eq1[1], "x<sub>2</sub>", eq1[2]);
    document.getElementById(name + "_system_row2").innerHTML =
        printable_eq(eq2[0], "x<sub>1</sub>", eq2[1], "x<sub>2</sub>", eq2[2]);
}



//////
/// systems
const system_1_eqs = 2;
var system_1_eq_1;
var system_1_eq_2;

var system_1_eq_temp_id = 1;
var system_1_eq_1_temp;
var system_1_eq_2_temp;

function set_system_1() {
    system_1_eq_1 = [1.0, -1.35, 0.4];
    system_1_eq_2 = [1.0, 2.0, 7.0];

    system_1_eq_temp_id = 1;
    system_1_eq_1_temp = system_1_eq_1;
    system_1_eq_2_temp = system_1_eq_2;
}
set_system_1();

function reset_system_1() {
    set_system_1();
    draw_plot_named('system_1', 0, 0, false);
    update_matrix('system_1');
    update_system('system_1');
}

// system 2
const system_2_eqs = 3;
var system_2_eq_1;
var system_2_eq_2;
var system_2_eq_3;

var system_2_eq_temp_id = 1;
var system_2_eq_1_temp;
var system_2_eq_2_temp;
var system_2_eq_3_temp;

function set_system_2() {
    system_2_eq_1 = [1.0, -1.35, 0.4];
    system_2_eq_2 = [1.0, 2.0, 7.0];
    system_2_eq_3 = [1.0, 0.3, 1.6];

    system_2_eq_temp_id = 1;
    system_2_eq_1_temp = system_2_eq_1;
    system_2_eq_2_temp = system_2_eq_2;
    system_2_eq_3_temp = system_2_eq_3;
}
set_system_2();

function reset_system_2() {
    set_system_2();
    draw_plot_named('system_2', 0, 0, false);
}

// system 3
const system_3_eqs = 2;
var system_3_eq_1;
var system_3_eq_2;

var system_3_eq_temp_id = 1;
var system_3_eq_1_temp;
var system_3_eq_2_temp;

function set_system_3() {
    system_3_eq_1 = [1.0, 1.5, 4.5];
    system_3_eq_2 = [1.0, -3.5, -3.0];

    system_3_eq_temp_id = 1;
    system_3_eq_1_temp = system_3_eq_1;
    system_3_eq_2_temp = system_3_eq_2;
}
set_system_3();

function reset_system_3() {
    set_system_3();
    draw_plot_named('system_3', 0, 0, false);
    update_system('system_3');
}


//////
/// solver

// lines
var solver_1_eqs = 2;
var solver_1_eq_1;
var solver_1_eq_2;

// start
var start_x;
var start_y;

// margin
var end_step_length;

// current id
var solver_1_eq_temp_id = 1;

// temps
var solver_1_eq_1_temp;
var solver_1_eq_2_temp;
var end_step_length_temp;

function set_solver_1() {
    solver_1_eq_1 = [-0.9, 1.0, -1.0]
    solver_1_eq_2 = [-0.15, 1.0, 2.5]
    start_x = 1.0;
    start_y = 1.0;
    end_step_length = 0.3

    solver_1_eq_2_temp = solver_1_eq_2;
    solver_1_eq_1_temp = solver_1_eq_1;
    end_step_length_temp = end_step_length;
}
set_solver_1();

function invalidate_solver_1(client_x, client_y){
    var solver = document.getElementById("solver_1");
    var canvas_rect = solver.getBoundingClientRect();
    if(document.getElementById("button_1").disabled) {
           eval("solver_1_eq_" + solver_1_eq_temp_id + " = " + name + "solver_1_eq_" + solver_1_eq_temp_id + "_temp;");
    } else if(document.getElementById("button_2").disabled) {
        start_x = client_to_x(client_x - canvas_rect.left);
        start_y = client_to_y(client_y - canvas_rect.top);
    } else if(document.getElementById("button_3").disabled) {
        end_step_length = temp_end_step_length;
    }
    draw_solver_1(0, 0, false);
    draw_solver_2(0, 0, false);
}

function init_solver_1(){
    var solver = document.getElementById("solver_1");
    var canvas_rect = solver.getBoundingClientRect();
    draw_solver_1(0, 0, false);

    solver.addEventListener('mousemove', function(e){
        var canvas_rect = solver.getBoundingClientRect();
        draw_solver_1(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        if(e.buttons == 1) {
            invalidate_solver_1(e.clientX, e.clientY);
        } else if(e.buttons == 0) {
            solver_1_eq_temp_id = find_nearest_eqution_id("solver_1", e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
        }
    }, false);

    solver.addEventListener('mousedown', function(e){
        invalidate_solver_1(e.clientX, e.clientY);
        var canvas_rect = solver.getBoundingClientRect();
        solver_1_eq_temp_id = find_nearest_eqution_id("solver_1", e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
    }, false);

    solver.addEventListener('mouseup', function(e){
        invalidate_solver_1(e.clientX, e.clientY);
    }, false);

    solver.addEventListener('mouseleave', function(e){
        draw_solver_1(0, 0, false);
    }, false);
}

var last_iterations = 100;
var last_error = 100.;
function draw_solver_1(client_x, client_y, do_guides){
    var solver = document.getElementById("solver_1");
    var context = solver.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);


    // lines and stop criterias
    context.globalAlpha = 0.6;
    for(var i = 0; i < solver_1_eqs; ++i){
        var eq = eval("solver_1_eq_" + (i + 1));
        // stop
        context.beginPath();
        var db2 = end_step_length * length_of(eq[0], eq[1]);
        context.moveTo(x_to_client(x_min), y_to_client((eq[2] - db2 - eq[0]*(x_min))/eq[1]));
        context.lineTo(x_to_client(x_max), y_to_client((eq[2] - db2 - eq[0]*(x_max))/eq[1]));
        context.lineTo(x_to_client(x_max), y_to_client((eq[2] + db2 - eq[0]*(x_max))/eq[1]));
        context.lineTo(x_to_client(x_min), y_to_client((eq[2] + db2 - eq[0]*(x_min))/eq[1]));
        context.lineTo(x_to_client(x_min), y_to_client((eq[2] - db2 - eq[0]*(x_min))/eq[1]));
        context.strokeStyle = line_colors[i];
        context.stroke();
        context.closePath();
        context.fillStyle = fill_colors[i];
        context.fill();
    }
    context.globalAlpha = 1.0;
    for(var i = 0; i < solver_1_eqs; ++i){
        var eq = eval("solver_1_eq_" + (i + 1));
        // line
        context.beginPath();
        context.lineWidth = 2;
        var xys = get_points_on_the_ends(eq[0], eq[1], eq[2]);
        context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
        context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
        context.strokeStyle = line_colors[i];
        context.stroke();
        context.lineWidth = 1;
        context.closePath();
    }

    // solver
    context.beginPath();
    context.moveTo(x_to_client(start_x), y_to_client(start_y));
    var prev_x = start_x + end_step_length + 1.;    // not to fall as done
    var prev_y = start_y;
    var cur_x = start_x;
    var cur_y = start_y;
    var i;
    for(i = 0; i <= 100; i++) // max iterations = 100
    {
        if(length_of(prev_x - cur_x, prev_y - cur_y) < end_step_length)
            break;  // done
        prev_x = cur_x;
        prev_y = cur_y;
        if(i % 2 == 0){
            cur_x = projected_x(prev_x, prev_y, solver_1_eq_1[0], solver_1_eq_1[1], solver_1_eq_1[2]);
            cur_y = projected_y(prev_x, prev_y, solver_1_eq_1[0], solver_1_eq_1[1], solver_1_eq_1[2]);
        }else{
            cur_x = projected_x(prev_x, prev_y, solver_1_eq_2[0], solver_1_eq_2[1], solver_1_eq_2[2]);
            cur_y = projected_y(prev_x, prev_y, solver_1_eq_2[0], solver_1_eq_2[1], solver_1_eq_2[2]);
        }
        context.lineTo(x_to_client(cur_x), y_to_client(cur_y));
    }
    last_iterations = i;
    context.strokeStyle="#002200";
    context.setLineDash([2, 2]);
    context.stroke();
    context.setLineDash([]);
    context.closePath();

    // grid
    draw_grid_on(context);

    // mouse move
    if(do_guides){
        if(document.getElementById("button_1").disabled){
            var eq = eval("solver_1_eq_" + solver_1_eq_temp_id);
            var x = client_to_x(client_x);
            var y = client_to_y(client_y);
            var temp_eq = new_equation_for_one_point(eq[0], eq[1], eq[2], x, y);
            eval("solver_1_eq_" + solver_1_eq_temp_id + "_temp = temp_eq;");

            context.beginPath();
            var xys = get_points_on_the_ends(temp_eq[0], temp_eq[1], temp_eq[2]);
            context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
            context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
            context.strokeStyle = line_colors[solver_1_eq_temp_id - 1];
            context.setLineDash([4, 4]);
            context.stroke();
            context.setLineDash([]);
            context.closePath();

        }else if(document.getElementById("button_2").disabled){
            context.beginPath();
            context.setLineDash([4, 4]);
            context.moveTo(x_to_client(start_x), y_to_client(start_y));
            context.lineTo(client_x, client_y);
            context.strokeStyle="#557755";
            context.stroke();
            context.setLineDash([]);
            context.closePath();
        }else if(document.getElementById("button_3").disabled){
            var a11 = solver_1_eq_1[0];
            var a12 = solver_1_eq_1[1];
            var b1 = solver_1_eq_1[2];
            var a21 = solver_1_eq_2[0];
            var a22 = solver_1_eq_2[1];
            var b2 = solver_1_eq_2[2];
            var x = client_to_x(client_x);
            var y = client_to_y(client_y);
            var x1 = projected_x(x, y, a11, a12, b1);
            var y1 = projected_y(x, y, a11, a12, b1);
            var x2 = projected_x(x, y, a21, a22, b2);
            var y2 = projected_y(x, y, a21, a22, b2);
            var d1 = length_of(x-x1, y-y1);
            var d2 = length_of(x-x2, y-y2);
            if(d1 < d2){
                temp_end_step_length = d1;
            }else{
                temp_end_step_length = d2;
            }
            // red
            context.beginPath();
            context.setLineDash([4, 4]);
            var db1 = temp_end_step_length * length_of(a11, a12);
            context.moveTo(x_to_client(x_min), y_to_client((b1 - db1 - a11*(x_min))/a12));
            context.lineTo(x_to_client(x_max), y_to_client((b1 - db1 - a11*(x_max))/a12));
            context.moveTo(x_to_client(x_min), y_to_client((b1 + db1 - a11*(x_min))/a12));
            context.lineTo(x_to_client(x_max), y_to_client((b1 + db1 - a11*(x_max))/a12));
            context.strokeStyle="#ff8866";
            context.stroke();
            context.setLineDash([]);
            context.closePath();
            // blue
            context.beginPath();
            context.setLineDash([4, 4]);
            var db2 = temp_end_step_length * length_of(a21, a22);
            context.moveTo(x_to_client(x_min), y_to_client((b2 - db2 - a21*(x_min))/a22));
            context.lineTo(x_to_client(x_max), y_to_client((b2 - db2 - a21*(x_max))/a22));
            context.moveTo(x_to_client(x_min), y_to_client((b2 + db2 - a21*(x_min))/a22));
            context.lineTo(x_to_client(x_max), y_to_client((b2 + db2 - a21*(x_max))/a22));
            context.strokeStyle="#6699ff";
            context.stroke();
            context.setLineDash([]);
            context.closePath();
        }
    }

    // iteration count
    results = document.getElementById("results");
    if(last_iterations > 100){
        results.innerHTML = "Ітерацій > 100";
    }else{
        results.innerHTML = "Ітерацій = " + last_iterations;
    }
    // solution
    var sxy = solve_2(solver_1_eq_1[0], solver_1_eq_1[1], solver_1_eq_1[2],  solver_1_eq_2[0], solver_1_eq_2[1], solver_1_eq_2[2]);
    results.innerHTML += "<br>";
    results.innerHTML += "Знайдений розв'язок: (" + cur_x.toFixed(3) + "; " + cur_y.toFixed(3) + "), ";
    results.innerHTML += "<i>точний: (" + sxy[0].toFixed(3) + "; " + sxy[1].toFixed(3) + ")</i>";
    error = length_of(sxy[0] - cur_x, sxy[1] - cur_y);
    results.innerHTML += "<br>";
    results.innerHTML += "Припустима довжина переходу: " + end_step_length.toFixed(3) + ", справжня похибка: " + error.toFixed(3);
    last_error = error;
}

function reset_solver() {
    set_solver_1();
    set_solver_2();
    draw_solver_1(0, 0, false);
    draw_solver_2(0, 0, false);
}

function radio(n) {
    for(var i = 1; i <= 3; i++){
        radio_i = document.getElementById("button_" + i);
        radio_i.disabled = false;
    }
    radio_n = document.getElementById("button_" + n);
    radio_n.disabled = true;
}

///////
/// solver 2
var solver_2_eqs = 2;
var solver_2_eq_1_temp;
var solver_2_eq_2_temp;
function set_solver_2() {
    solver_2_eq_2_temp = solver_1_eq_2;
    solver_2_eq_1_temp = solver_1_eq_1;
}

function invalidate_solver_2(client_x, client_y) {
    var solver = document.getElementById("solver_2");
    var canvas_rect = solver.getBoundingClientRect();
    eval("solver_1_eq_" + solver_1_eq_temp_id + " = " + name + "solver_2_eq_" + solver_1_eq_temp_id + "_temp;");
    draw_solver_1(0, 0, false);
    draw_solver_2(0, 0, false);
}

function init_solver_2(){
    var solver = document.getElementById("solver_2");
    var canvas_rect = solver.getBoundingClientRect();
    draw_solver_2(0, 0, false);

    solver.addEventListener('mousemove', function(e){
        var canvas_rect = solver.getBoundingClientRect();
        draw_solver_2(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        if(e.buttons == 1) {
            invalidate_solver_2(e.clientX, e.clientY);
        } else if(e.buttons == 0) {
            solver_1_eq_temp_id = find_nearest_eqution_id("solver_1", e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
        }
    }, false);

    solver.addEventListener('mousedown', function(e){
        invalidate_solver_2(e.clientX, e.clientY);
        var canvas_rect = solver.getBoundingClientRect();
        solver_1_eq_temp_id = find_nearest_eqution_id("solver_1", e.clientX - canvas_rect.left, e.clientY - canvas_rect.top);
    }, false);

    solver.addEventListener('mouseup', function(e){
        invalidate_solver_2(e.clientX, e.clientY);
    }, false);

    solver.addEventListener('mouseleave', function(e){
        draw_solver_2(0, 0, false);
    }, false);
}

function draw_solver_2(client_x, client_y, do_guides){
    var solver = document.getElementById("solver_2");
    var context = solver.getContext("2d");
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // only lines now
    for(var i = 0; i < solver_1_eqs; ++i){
        var eq = eval("solver_1_eq_" + (i + 1));
        // line
        context.beginPath();
        context.lineWidth = 2;
        var xys = get_points_on_the_ends(eq[0], eq[1], eq[2]);
        context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
        context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
        context.strokeStyle = line_colors[i];
        context.stroke();
        context.lineWidth = 1;
        context.closePath();
    }

    // solver
    context.beginPath();
    context.moveTo(x_to_client(0), y_to_client(0));
    var ixy = solve_2(solver_1_eq_1[0], solver_1_eq_1[1], 0,  solver_1_eq_2[0], solver_1_eq_2[1], solver_1_eq_2[2]);
    context.lineTo(x_to_client(ixy[0]), y_to_client(ixy[1]));
    var sxy = solve_2(solver_1_eq_1[0], solver_1_eq_1[1], solver_1_eq_1[2],  solver_1_eq_2[0], solver_1_eq_2[1], solver_1_eq_2[2]);
    context.lineTo(x_to_client(sxy[0]), y_to_client(sxy[1]));
    context.strokeStyle="#002200";
    context.lineWidth = 2;
    context.setLineDash([2, 2]);
    context.stroke();
    context.lineWidth = 1;
    context.setLineDash([]);
    context.closePath();

    // grid
    draw_grid_on(context);

    // mouse move
    if(do_guides){
        var x = client_to_x(client_x);
        var y = client_to_y(client_y);
        var eq = eval("solver_1_eq_" + solver_1_eq_temp_id);

        var temp_eq = new_equation_for_one_point(eq[0], eq[1], eq[2], x, y);
        eval("solver_2_eq_" + solver_1_eq_temp_id + "_temp = temp_eq;");

        context.beginPath();
        var xys = get_points_on_the_ends(temp_eq[0], temp_eq[1], temp_eq[2]);
        context.moveTo(x_to_client(xys[0][0]), y_to_client(xys[0][1]));
        context.lineTo(x_to_client(xys[1][0]), y_to_client(xys[1][1]));
        context.strokeStyle = line_colors[solver_1_eq_temp_id - 1];
        context.setLineDash([4, 4]);
        context.stroke();
        context.setLineDash([]);
        context.closePath();
    }
}


///////
/// linear multiplier
function inc(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) + 1;
    eval('change_' + counter_name + '()');
}

function dec(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) - 1;
    eval('change_' + counter_name + '()');
}

function change_linear_multiplier() {
    var multiplier = Number(document.getElementById('linear_multiplier').value);
    var row = document.getElementById('linear_row2');
    if(multiplier != 0) {
        row.innerHTML = printable_eq(multiplier, "x<sub>1</sub>", 2 * multiplier, "x<sub>2</sub>", 3 * multiplier);
    } else {
        row.innerHTML = "Ага, ну звісно окрім 0.";
        hidden_quests[0] = 1;
    }
}

//////
/// underspecified
function change_s3_1_1() {}
function change_s3_1_2() {}
function change_s3_1_3() {}
function change_s3_1_4() {}
function change_s3_2_1() {}
function change_s3_2_2() {}
function change_s3_2_3() {}
function change_s3_2_4() {}


//////
/// elimination
function do_one_elimination_step() {
    if(Math.abs(system_3_eq_1[1] / system_3_eq_1[0] - system_3_eq_2[1] / system_3_eq_2[0]) < 0.05) {
        document.getElementById('step_name').innerHTML = "Авжеж! На&nbsp;паралельних прямих цей метод не&nbsp;працює. Чудово що&nbsp;ви&nbsp;знайшли це&nbsp;самі!";
        hidden_quests[1] = 1;
    } else if (system_3_eq_1[0] == 1.0 && system_3_eq_1[1] == 0.0 && system_3_eq_2[0] == 0.0 && system_3_eq_2[1] == 1.0) {
        document.getElementById('step_name').innerHTML = "Вже розв'язано!";
    } else if (system_3_eq_2[1] != system_3_eq_1[1] && system_3_eq_2[1] != 1.0 && system_3_eq_1[1] != 0) {
        document.getElementById('step_name').innerHTML = "Поділили друге рівняння на&nbsp;його ж&nbsp;другий коефіцієнт.";
        system_3_eq_2[0] /= system_3_eq_2[1];
        system_3_eq_2[2] /= system_3_eq_2[1];
        system_3_eq_2[1] = 1.0;
    } else if (system_3_eq_2[1] != system_3_eq_1[1] && system_3_eq_1[1] != 0) {
        document.getElementById('step_name').innerHTML = "Помножили друге рівняння на&nbsp;другий коефіцієнт першого.";
        system_3_eq_2[0] *= system_3_eq_1[1];
        system_3_eq_2[1] = system_3_eq_1[1];
        system_3_eq_2[2] *= system_3_eq_1[1];
    } else if (system_3_eq_2[1] == system_3_eq_1[1] && system_3_eq_1[1] != 0) {
        document.getElementById('step_name').innerHTML = "Відняли все друге рівняння із&nbsp;першого.";
        system_3_eq_1[0] -= system_3_eq_2[0];
        system_3_eq_1[1] = 0.0;
        system_3_eq_1[2] -= system_3_eq_2[2];
    } else if (system_3_eq_1[1] == 0.0 && system_3_eq_1[0] != 1.0 && system_3_eq_1[0] != system_3_eq_2[0] && system_3_eq_2[0] != 0.0 ) {
        document.getElementById('step_name').innerHTML = "Поділили перше рівняння на&nbsp;його ж&nbsp;перший коефіцієнт.";
        system_3_eq_1[2] /= system_3_eq_1[0];
        system_3_eq_1[0] = 1.0;
    } else if (system_3_eq_1[1] == 0.0 && system_3_eq_1[0] == 1.0 && system_3_eq_2[0] != 1.0 && system_3_eq_2[0] != 0.0) {
        document.getElementById('step_name').innerHTML = "Помножили перше рівняння на&nbsp;перший коефіцієнт другого рівняння.";
        system_3_eq_1[2] *= system_3_eq_2[0];
        system_3_eq_1[0] = system_3_eq_2[0];
    } else if (system_3_eq_1[1] == 0.0 && system_3_eq_1[0] == system_3_eq_2[0]) {
        document.getElementById('step_name').innerHTML = "Відняли все перше рівняння із&nbsp;другого.";
        system_3_eq_2[0] = 0.0;
        system_3_eq_2[1] -= system_3_eq_1[1];
        system_3_eq_2[2] -= system_3_eq_1[2];
    } else if (system_3_eq_1[1] == 0.0 && system_3_eq_2[0] == 0.0) {
        document.getElementById('step_name').innerHTML = "Поділили рівняння на&nbsp;відповідні ненульові коефіцієнти.";
        system_3_eq_1[2] /= system_3_eq_1[0];
        system_3_eq_1[0] = 1.0;
        system_3_eq_2[2] /= system_3_eq_2[1];
        system_3_eq_2[1] = 1.0;
    }
    update_system("system_3");
    draw_plot_named("system_3");
}

//////
/// quests
function done_system_1_quest_1() {
    var xy = solve_2(system_1_eq_1[0], system_1_eq_1[1], system_1_eq_1[2], system_1_eq_2[0], system_1_eq_2[1], system_1_eq_2[2]);
    if(Math.abs(xy[0]) > 0.25 || Math.abs(xy[1]) > 0.25) {
        document.getElementById("reply_quest_1").innerHTML = "Вибачте, але ні. Спробуте ще раз.";
    } else if(Math.abs(xy[0]) >= 0.01 || Math.abs(xy[1]) >= 0.01) {
        document.getElementById("reply_quest_1").innerHTML = "Правильно!";
        document.getElementById("buttons_quest_1").style.display = 'none';
        quests[0] = 1;
    } else {
        document.getElementById("reply_quest_1").innerHTML = "Ідеально точно!";
        document.getElementById("buttons_quest_1").style.display = 'none';
        quests[0] = 1;
    }
    draw_plot_named('system_1', 0, 0, false);
}

function done_system_1_quest_2() {
    var xy = solve_2(system_1_eq_1[0], system_1_eq_1[1], system_1_eq_1[2], system_1_eq_2[0], system_1_eq_2[1], system_1_eq_2[2]);
    if(Math.abs(xy[0]) < 25 && Math.abs(xy[1]) < 25) {
        document.getElementById("reply_quest_2").innerHTML = "Вибачте, але розв'язок все ще існує: <i>x<sub>1</sub> =" + printable(xy[0]) + ", x<sub>2</sub> = " + printable(xy[1]) + "</i>. Спробуйте ще раз.";
    } else {
        document.getElementById("reply_quest_2").innerHTML = "Саме так! Коли прімі паралельні, розв'язку немає.";
        document.getElementById("buttons_quest_2").style.display = 'none';
        quests[1] = 1;
    }
    draw_plot_named('system_1', 0, 0, false);
}

function done_system_1_quest_3() {
    xyxy1 = get_points_on_the_ends(system_1_eq_1[0], system_1_eq_1[1], system_1_eq_1[2]);
    xyxy2 = get_points_on_the_ends(system_1_eq_2[0], system_1_eq_2[1], system_1_eq_2[2]);
    if(Math.abs(xyxy1[0][0] - xyxy2[0][0]) > 0.1 ||
       Math.abs(xyxy1[0][1] - xyxy2[0][1]) > 0.1 ||
       Math.abs(xyxy1[1][0] - xyxy2[1][0]) > 0.1 ||
       Math.abs(xyxy1[1][1] - xyxy2[1][1]) > 0.1) {
        var xy = solve_2(system_1_eq_1[0], system_1_eq_1[1], system_1_eq_1[2], system_1_eq_2[0], system_1_eq_2[1], system_1_eq_2[2]);
        document.getElementById("reply_quest_3").innerHTML = "Вибачте, але розв'язок все ще один: <i>x<sub>1</sub> =" + printable(xy[0]) + ", x<sub>2</sub> = " + printable(xy[1]) + "</i>. Спробуйте ще раз.";
    } else {
        document.getElementById("reply_quest_3").innerHTML = "Так! Якщо прямі співпадають, то і&nbsp;розв'язків буде нескінченна кількість. Кожна точка прямої — вже розв'язок.";
        document.getElementById("buttons_quest_3").style.display = 'none';
        quests[2] = 1;
    }
    draw_plot_named('system_1', 0, 0, false);
}

function done_system_2_quest_4() {
    var xy1 = solve_2(system_2_eq_1[0], system_2_eq_1[1], system_2_eq_1[2], system_2_eq_2[0], system_2_eq_2[1], system_2_eq_2[2]);
    var xy2 = solve_2(system_2_eq_2[0], system_2_eq_2[1], system_2_eq_2[2], system_2_eq_3[0], system_2_eq_3[1], system_2_eq_3[2]);
    var xy3 = solve_2(system_2_eq_3[0], system_2_eq_3[1], system_2_eq_3[2], system_2_eq_1[0], system_2_eq_1[1], system_2_eq_1[2]);
    if(Math.abs(xy1[0] - xy2[0]) > 0.1 ||
       Math.abs(xy1[1] - xy2[1]) > 0.1){
        document.getElementById("reply_quest_4").innerHTML = "Перетини є, але це&nbsp;ще не&nbsp;розв'язок. Спробуйте ще раз.";
    } else {
        document.getElementById("reply_quest_4").innerHTML = "Так! Розв'язок знайдеться, якщо всі три прямі перетинатимуться в&nbsp;одній точці.";
        document.getElementById("buttons_quest_4").style.display = 'none';
        quests[3] = 1;
    }
    draw_plot_named('system_2', 0, 0, false);
}

function almost(a, b) {
    return Math.abs(a-b) < 1.e-5;
}

function done_system_3_quest_5() {
    var a11 =  Number(document.getElementById("s3_1_1").value);
    var a12 =  Number(document.getElementById("s3_1_2").value);
    var a13 =  Number(document.getElementById("s3_1_3").value);
    var b1 =  Number(document.getElementById("s3_1_4").value);
    var a21 =  Number(document.getElementById("s3_2_1").value);
    var a22 =  Number(document.getElementById("s3_2_2").value);
    var a23 =  Number(document.getElementById("s3_2_3").value);
    var b2 =  Number(document.getElementById("s3_2_4").value);

    if(almost(a11 / a21, a12 / a22) && almost(a11 / a21, a13 / a23))
    {
        if(almost(a11 / a21, b1 / b2))
        {
            document.getElementById("reply_quest_5").innerHTML = "Звісно, вони лінійно залежні. Тобто утворюють одну і&nbsp;ту саму площину. Але кожна точка на&nbsp;площині все ж&nbsp;таки буде розв'язком.";
        } else {
            document.getElementById("reply_quest_5").innerHTML = "Правильно! <br>Паралельні площини виглядають так: матрична частина системи рівнянь складається із&nbsp;лінійно залежних рівнянь, а от вся система із&nbsp;вектором свободних членов — вже ні.";
            document.getElementById("buttons_quest_5").style.display = 'none';
            document.getElementById("quest_5_formula").style.display = 'none';
            quests[4] = 1;
        }
    } else {
        document.getElementById("reply_quest_5").innerHTML = "Тут нескінченна кількість розв'язків. Перетин площин — це пряма. Кожна точка на&nbsp;цій прямій буде розв'язком системи.";
    }
}

function done_system_4_quest_6() {
    if(last_iterations == 58) {
        document.getElementById("reply_quest_6").innerHTML = "Саме так! Або треба погіпшити сходимість, або зробити критерій зупинки більш строгим. Звісно, можна і&nbsp;стартову точку теж переносити.";
        document.getElementById("buttons_quest_6").style.display = 'none';
        quests[5] = 1;
    } else {
        document.getElementById("reply_quest_6").innerHTML = "Це ж&nbsp;не&nbsp;точно 58 ітерацій.";
    }
}

function done_system_4_quest_7() {
    if(last_error >= 6.0) {
        document.getElementById("reply_quest_7").innerHTML = "Звісно ж! Похибка залежить не&nbsp;тільки від критерію зупинки. При нашому критерії, чим гостіший кут між прямими, тим більше буде похибка по відношенню до останнього переходу.";
        document.getElementById("buttons_quest_7").style.display = 'none';
        quests[6] = 1;
    } else {
        document.getElementById("reply_quest_7").innerHTML = "Це все ще менше за&nbsp;6.0.";
    }
}

function done_system_4_quest_8() {
    var q101 = Math.abs(solver_1_eq_1[0] / solver_1_eq_1[1]);
    var q110 = Math.abs(solver_1_eq_1[1] / solver_1_eq_1[0]);
    var q201 = Math.abs(solver_1_eq_2[0] / solver_1_eq_2[1]);
    var q210 = Math.abs(solver_1_eq_2[1] / solver_1_eq_2[0]);
    if(Math.abs(q101 - q210) < 0.1 || Math.abs(q110 - q201) < 0.1) {
        document.getElementById("reply_quest_8").innerHTML = "Саме так! Якщо прямі ортогональні, рішення завжди знаходиться щобільше за&nbsp;два переходи. Ітерацій тоді буде три, бо третя ітерація тільки зупиняє алгоритм і&nbsp;нікуди далі не&nbsp;йде.";
        document.getElementById("buttons_quest_8").style.display = 'none';
        quests[7] = 1;
    } else if(last_iterations <= 3){
        document.getElementById("reply_quest_8").innerHTML = "Ну воно ніби і&nbsp;так, але якщо посунути стартову точку, то буде вже більше за&nbsp;три ітерації.";
    } else {
        document.getElementById("reply_quest_8").innerHTML = "Вибачте, але ні. Спробуйте ще раз.";
    }
}

function done_quest_9() {
    if(document.getElementById("aq8_1").checked) {
        document.getElementById("reply_quest_9").innerHTML = "Вибачте, але складність набагато більша.";
    }else if(document.getElementById("aq8_2").checked) {
        document.getElementById("reply_quest_9").innerHTML = "Ні, не&nbsp;зовсім. Ви&nbsp;не&nbsp;впустили зовнішній цикл?";
    }else if(document.getElementById("aq8_3").checked) {
        document.getElementById("reply_quest_9").innerHTML = "Саме так! Чотири вкладених цикли, кожен залежить від кількості рівнянь. Отже і&nbsp;складність буде <i>O(n<sup>4</sup>)</i>.";
        document.getElementById("complexity_buttons").style.display = 'none';
        document.getElementById("buttons_quest_9").style.display = 'none';
        quests[8] = 1;
    }else if(document.getElementById("aq8_4").checked) {
        document.getElementById("reply_quest_9").innerHTML = "Майже. Зверніть уваге, що&nbsp;два останніх цикла насправді не&nbsp;вкладені.";
    }else {
        document.getElementById("reply_quest_9").innerHTML = "Оберіть спершу якусь відповідь.";
    }
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Вступ до&nbsp;лінійних рівнянь <br>для програмістів
    </h1>
    <p>
Сучасному програмістові не&nbsp;доводиться самому писати алгоритми для розв'язку систем лінійних рівнянь. Цей вступ, власне, і&nbsp;не про деталі реалізацій. Втім, проблеми, які можна розв'язати у&nbsp;формі лінійних рівнянь, сучасному програмістові зустрічаються. Цей вступ, відповідно, саме про концептуальні основи, які допомогають такі проблеми розпізнати і&nbsp;вирішити.
    </p>
    <p>
Насправді, навіть якщо вас взагалі не&nbsp;збуджує лінійна алгебра, вам все одно можуть бути цікаві деякі ідеї про які тут йдеться. Сходимість, похибка обчислення, складність алгоритмів, — всі ці речі будуть наочно проілюстровані на&nbsp;прикладах простих лінійних систем.
    </p>
    <p>
Лінійна система — це система лінійних рівнянь. Рівняння називається лінійним, якщо воно не&nbsp;містить нічого окрім зваженої суми змінних що&nbsp;дорівнює константі. У&nbsp;двовимірному просторі лінійне рівняння працює ще як&nbsp;рівняння прямої. У&nbsp;тривимірному — площини. У&nbsp;чьотирьох і&nbsp;більше — гіперплощини.
    </p>
    <p>
Систему можна записати просто як&nbsp;множину рівнянь.
    </p>
    <table class="formula">
    <tr>
    <td rowspan=2 class="brackets">{</td>
    <td id="system_1_system_row1">
    a11x1 + a12x2 = b1
    </td>
    </tr><tr>
    <td id="system_1_system_row2">
    a21x1 + a22x2 = b2
    </td>
    </tr>
    </table>
    <p>
А можна як&nbsp;одне матричне рівняння.
    </p>

    <table class="formula">
    <tr>
    <td class="brackets">[</td>
    <td id="system_1_matrix_col1">
1<br>0
    </td>
    <td id="system_1_matrix_col2">
0<br>1
    </td>
    <td class="brackets">]</td>
    <td class="brackets">[</td>
    <td>
x<sub>1</sub> <br> x<sub>2</sub>
    </td>
    <td class="brackets">]</td>
    <td> = </td>
    <td class="brackets">[</td>
    <td id="system_1_matrix_col3">
0<br>1
    </td>
    <td class="brackets">]</td>
    </tr>
    </table>

    <p>
Cистему можна навіть намалювати.
    </p>
    <canvas id="system_1" width=640 height=512></canvas>
    <p class="comment">
Цей графік інтерактивний. На&nbsp;ньому можна покерувати кривими, а системи нагорі автоматично перебудуються.
    </p>
    <div style="text-align:right; width:640px; padding-bottom:12pt;">
        <button type="button" id="button_1_reset" onclick="reset_system_1()">Наново</button>
    </div>

    <p>
Графічне представлення — це така корисна ментальна модель. Про прямі думати легше ніж про числа і&nbsp;змінні. Наприклад, розв'язком системи рівнянь є&nbsp;перетин прямих. Дуже просто.
    </p>

    <form>
        <b>Перший квест.</b> Керуючи прямими на&nbsp;інтерактивному графіку зверху, зробіть систему, яка матиме розв'язок в&nbsp;нулі: <br><i>x<sub>1</sub> = 0, x<sub>2</sub> = 0</i>. <br>Зробіть і&nbsp;натисніть кнопку &laquo;Перевірити!&raquo;.
        <div id="reply_quest_1" style="padding-top:6pt;"></div>
        <div id="buttons_quest_1" style="text-align:right;">
            <button type="button" id="button_1_1" onclick="done_system_1_quest_1()">Перевірити!</button>
        </div>
    </form>

    <p>
Не всі системи в&nbsp;принципі можна розв'язати.
    </p>

    <form>
        <b>Другий квест.</b> Керуючи прямими на&nbsp;графіку, зробіть систему, яка в&nbsp;принципі не&nbsp;матимиме розв'язку.
        <div id="reply_quest_2" style="padding-top:6pt;"></div>
        <div id="buttons_quest_2" style="text-align:right;">
            <button type="button" id="button_1_2" onclick="done_system_1_quest_2()">Перевірити!</button>
        </div>
    </form>

    <p>
А буває навпаки, буває що кількість розв'язків нескінченна.
    </p>

    <form>
        <b>Третій квест.</b> Керуючи прямими на&nbsp;тому ж&nbsp;графіку, зробіть систему із&nbsp;безкінечною кількістю розв'язків.
        <div id="reply_quest_3" style="padding-top:6pt;"></div>
        <div id="buttons_quest_3" style="text-align:right;">
            <button type="button" id="button_1_3" onclick="done_system_1_quest_3()">Перевірити!</button>
        </div>
    </form>

    <p>
Чисельні методи зазвичай розраховані на&nbsp;пошук єдиного розв'язку і&nbsp;такі системи можуть бути для них проблемою. Втім, деякі імплементації проблемою це&nbsp;не вважають і&nbsp;повертають перший ліпший розв'язок. Що&nbsp;само по собі вже проблема.
    </p>
    <p>
Якщо помножити кожен коефіцієнт рівняння разом із&nbsp;константою на&nbsp;одне і&nbsp;те саме число, всі факти про точки, які це&nbsp;рівняння описує, лишаться незмінними. Це&nbsp;буде те саме рівняння. Воно буде рівнянням тієї ж&nbsp;самої прямої. Рівняння, які мають різні коефіцієнти, але описують одну і&nbsp;ту ж&nbsp;пряму, називаються лінійно залежними.
    </p>
    <table class="formula">
    <tr>
    <td id="linear_row1">
    x<sub>1</sub> + 2x<sub>2</sub> = 3
    </td>
    </tr><tr>
    <td>
    <button type="button" class="incdec" onclick="dec('linear_multiplier')">-</button><input type="text" style="width: 32pt;" id="linear_multiplier" value="2" oninput="change_linear_multiplier();"><button type="button" class="incdec" onclick="inc('linear_multiplier')">+</button>
    </td>
    </tr><tr>
    <td id="linear_row2">
    2x<sub>1</sub> + 4x<sub>2</sub> = 6
    </td>
    </tr>
    </table>

    <p>
Система рівнянь може мати більше рівнянь ніж змінних. Такі системи називаються перевизначеними.
    </p>
    <canvas id="system_2" width=640 height=512></canvas>
    <div style="text-align:right; width:640px; padding-bottom:12pt;">
        <button type="button" id="button_2_reset" onclick="reset_system_2()">Наново</button>
    </div>
    <p>
В загальному випадку, такі системи не&nbsp;мають розв'язку. Але&nbsp;в&nbsp;окремих випадках можуть і&nbsp;мати.
    </p>

    <form>
        <b>Четвертий квест.</b> Використовуючи графік із&nbsp;трьома прямими, зробіть систему із&nbsp;єдиним розв'язком.
        <div id="reply_quest_4" style="padding-top:6pt;"></div>
        <div id="buttons_quest_4" style="text-align:right;">
            <button type="button" id="button_2_4" onclick="done_system_2_quest_4()">Перевірити!</button>
        </div>
    </form>

    <p>
Може бути і&nbsp;навпаки. Система може мати більше змінних аніж рівнянь. Такі системи називаються недовизначеними.
    </p>
    <p>
Звісно, у&nbsp;двовимірному випадку, недовизначена система складатиметься з&nbsp;одного рівняння. Кожна точка прямої цього рівняння і&nbsp;буде розв'язком. Та&nbsp;чи система це&nbsp;взагалі?
    </p>
    <p>
Але у&nbsp;багатовимірних випадках, недоспецифіковані системи розв'язків можуть і&nbsp;не мати.
    </p>

     <form>
        <b>П'ятий квест.</b> Використовуючи матрицю знизу, зробіть недоспецифіковану систему із&nbsp;двох рівнянь, яка не&nbsp;матиме жодного розв'язку.

        <div id="reply_quest_5" style="padding-top:6pt;"></div>
        <div id="quest_5_formula">
            <table class="formula" style="padding:0 0 6pt 0;">
            <tr>
            <td class="brackets">[</td>
            <td id="system_3_matrix_col1_nonupdateable">
<nobr><button type="button" class="incdec" onclick="dec('s3_1_1')">-</button><input type="text" id="s3_1_1" value="1" oninput=""><button type="button" class="incdec" onclick="inc('s3_1_1')">+</button></nobr><br><nobr><button type="button" class="incdec" onclick="dec('s3_2_1')">-</button><input type="text" id="s3_2_1" value="2" oninput=""><button type="button" class="incdec" onclick="inc('s3_2_1')">+</button></nobr>
            </td>
            <td id="system_3_matrix_col2_nonupdateable">
<nobr><button type="button" class="incdec" onclick="dec('s3_1_2')">-</button><input type="text" id="s3_1_2" value="2" oninput=""><button type="button" class="incdec" onclick="inc('s3_1_2')">+</button></nobr><br><nobr><button type="button" class="incdec" onclick="dec('s3_2_2')">-</button><input type="text" id="s3_2_2" value="3" oninput=""><button type="button" class="incdec" onclick="inc('s3_2_2')">+</button></nobr>
            </td>
            <td id="system_3_matrix_col3_nonupdateable">
<nobr><button type="button" class="incdec" onclick="dec('s3_1_3')">-</button><input type="text" id="s3_1_3" value="3" oninput=""><button type="button" class="incdec" onclick="inc('s3_1_3')">+</button></nobr><br><nobr><button type="button" class="incdec" onclick="dec('s3_2_3')">-</button><input type="text" id="s3_2_3" value="4" oninput=""><button type="button" class="incdec" onclick="inc('s3_2_3')">+</button></nobr>
            </td>
            <td class="brackets">]</td>
            <td class="brackets">[</td>
            <td>
x<sub>1</sub><br>x<sub>2</sub><br>x<sub>3</sub>
            </td>
            <td class="brackets">]</td>
            <td> = </td>
            <td class="brackets">[</td>
            <td id="system_3_matrix_col4">
<nobr><button type="button" class="incdec" onclick="dec('s3_1_4')">-</button><input type="text" id="s3_1_4" value="4" oninput=""><button type="button" class="incdec" onclick="inc('s3_1_4')">+</button></nobr><br><nobr><button type="button" class="incdec" onclick="dec('s3_2_4')">-</button><input type="text" id="s3_2_4" value="5" oninput=""><button type="button" class="incdec" onclick="inc('s3_2_4')">+</button></nobr>
            </td>
            <td class="brackets">]</td>
            </tr>
            </table>
        </div>
        <div id="buttons_quest_5" style="text-align:right;">
            <button type="button" id="button_3_5" onclick="done_system_3_quest_5()">Перевірити!</button>
        </div>
    </form>

    <p>
Є два класи алгоритмів які розв'язують системи лінійних рівнянь: ітеративні та&nbsp;точні.
    </p>
    <p>
Ітеративні алгоритми концептуально прості. Вони всі зводяться до&nbsp;трьох кроків.
    </p>
    <ol>
    <li>Починаємо з&nbsp;якоїсь точки.</li>
    <li>Перевіряємо, чи ця точка вже схожа на&nbsp;розв'язок. <br>Якщо так — чудово, ми&nbsp;впорались!</li>
    <li>Якщо ні, робимо щось що&nbsp;має наблизити її до&nbsp;розв'язку. <br>Йдемо до&nbsp;кроку №2.</li>
    </ol>
    <p>
Давайте зробимо з&nbsp;цього конкретний алгоритм.
    </p>
    <p>
Той крок, що&nbsp;наближує точку до&nbsp;розв'язку, буде простою проекцією на&nbsp;пряму. Точка, проекція, і&nbsp;розв'язок утворюватимуть прямокутний трикутник. Отже проекція буде принаймні не&nbsp;далі від розв'язку, аніж сама точка, тому що гіпотенуза не&nbsp;може бути коротшою за&nbsp;катет. 
    </p>
    <p>
Ми&nbsp;будемо по черзі проецювати точку з&nbsp;однієї прямої на&nbsp;іншу, і рано чи піздно доберемося до&nbsp;якогось задовільно малого околу розв'язку.
    </p>
    <p>
Якщо звісно система має розв'язок.
    </p>
    <p>
Щодо умови виходу, ми&nbsp;зробимо ще простіше. Ми&nbsp;мірятимо те, скільки точка подолала за&nbsp;свій останній перехід щоб спроецюватися. Очікувано, із&nbsp;тим як&nbsp;ми наближатимемося до&nbsp;розв'язку, і&nbsp;переходи ставатимуть коротші. Отже, коли перехід стане зовсім маленьким, ми&nbsp;вважатемемо, що&nbsp;розв'язок достатньо близько аби ближче вже не&nbsp;підходити.
    </p>
    <p>
А от на&nbsp;питання &laquo;де починати&raquo; відповіді не&nbsp;буде. Чудово було б&nbsp;почати одразу біля розв'язку, але наш алгоритм має працювати починаючи з&nbsp;будь-якої точки, тож і&nbsp;багато думати про вибір першої не варто.
    </p>
    <p>
Ось інтерактивна ілюстрація такого алгоритму.
    </p>
    <div id="solver_buttons">
    <center>
        <button type="button" id="button_1" style="width: 180px;" onclick="radio(1)" disabled="true">Прямі</button>
        <button type="button" id="button_2" style="width: 180px;" onclick="radio(2)">Початок</button>
        <button type="button" id="button_3" style="width: 180px;" onclick="radio(3)">Перехід</button>
    </center>
    </div>
    <canvas id="solver_1" width=640 height=512></canvas>
    <div style="text-align:right; width:640px; padding-bottom:12pt;">
        <button type="button" id="reset_solver" onclick="reset_solver()">Наново</button>
    </div>

    <p class="results" id="results">
    </p>

    <p>
Якщо подібний до&nbsp;цього алгоритм і&nbsp;справді наближається до&nbsp;розв'язку із&nbsp;кожною ітерацією, то кажуть, що&nbsp;він сходиться. Якщо навпаки, віддаляється — розходиться. Сходимість — це друга за&nbsp;важливістю характеристика ітеративного алгоритму. Фактично це&nbsp;його швидкість.
    </p>
    <p>
А найголовніша властивість ітеративного алгоритму — це стабільність. Кожна операція на&nbsp;числах з&nbsp;плаваючою точкою може додавати якусь нехай невелику похибку. Якщо ми&nbsp;виконуватимемо такі операції багато разів підряд, похибка накопичуватиметься і&nbsp;зрештою може стати проблемою. 
    </p>
    <p>
Стабільні алгоритми вміють не&nbsp;накопичуюти похибку. Нехай на&nbsp;кожній окремій ітерації якась похибка і&nbsp;присутня, але вона не&nbsp;впливатиме на&nbsp;похибку на&nbsp;наступній ітерації.
    </p>
    <p>
Цей конкретний алгоритм стабільний і&nbsp;геометрично не&nbsp;може розходитись. Більш того, його сходимість наочно пов'язана із&nbsp;кутом між прямими.
    </p>
    <form>
        <b>Шостий квест.</b> Використовуючи графік нагорі, зробіть таку систему і&nbsp;налаштуйте умови, щоб отримати розв'язок рівно за&nbsp;58 ітерацій.
        <div id="reply_quest_6" style="padding-top:6pt;"></div>
        <div id="buttons_quest_6" style="text-align:right;">
            <button type="button" id="button_4_6" onclick="done_system_4_quest_6()">Перевірити!</button>
        </div>
    </form>
    <p>
Втім, стабільність і&nbsp;сходимість — це ще не&nbsp;все. Цей конкретний алгоритм, наприклад, непридатний до&nbsp;практичного застосування з іншої причини. Якщо прямі майже паралельні, умова виходу яку ми&nbsp;обрали буде давати завелику похибку.
    </p>
    <form>
        <b>Сьомий квест.</b> Зробіть на&nbsp;графіку вгорі таку систему і&nbsp;такі умови, щоб похибка розв'язку була більше ніж 6.0.
        <div id="reply_quest_7" style="padding-top:6pt;"></div>
        <div id="buttons_quest_7" style="text-align:right;">
            <button type="button" id="button_4_7" onclick="done_system_4_quest_7()">Перевірити!</button>
        </div>
    </form>
    <p>
Точні алгоритми, на&nbsp;відміну від ітеративних, сходимості не&nbsp;мають. Натомість, вони виконуть свою работу за&nbsp;певну наперед визначену кількість операцій.
    </p>
    <p>
Але при деяких умовах, ітеративні алгоритми поводяться як&nbsp;точні. Теж виконуть роботу за&nbsp;наперед визначену кількість ітерацій.
    </p>
    <form>
        <b>Восьмий квест.</b> Зробіть на&nbsp;графіку нагорі систему, яка б&nbsp;завжди розв'язувалась не&nbsp;більше ніж за&nbsp;3 ітерації.
        <div id="reply_quest_8" style="padding-top:6pt;"></div>
        <div id="buttons_quest_8" style="text-align:right;">
            <button type="button" id="button_4_8" onclick="done_system_4_quest_8()">Перевірити!</button>
        </div>
    </form>
    <p>
Точні алгоритми працюють так незалежно від системи. Що&nbsp;найцікавіше, ми&nbsp;теж можемо перетворити наш простий ітеративний алгоритм на&nbsp;точний додавши всього одну невелику деталь
    </p>
    <p>
Ми робимо переходи послідовно проецюючи точку з&nbsp;прямої на&nbsp;пряму. Проекція відбувається ортогонально до&nbsp;наступної прямої. Давайте тепер замість цього проецювати точку на&nbsp;наступну пряму вздовж прямої поточної.
    </p>
    <canvas id="solver_2" width=640 height=512></canvas>
    <div style="text-align:right; width:640px; padding-bottom:12pt;">
        <button type="button" id="reset_solver" onclick="reset_solver()">Наново</button>
    </div>
    <p>
Раз алгоритм тепер не&nbsp;ітеративний, то і умова виходу йому не&nbsp;потрібна. А ще, так як&nbsp;ми маємо тепер &laquo;абсолютну сходимість&raquo;, вибір першої точки теж ні на&nbsp;що не&nbsp;впливає. Хіба це&nbsp;не чудово?! Навіщо взагалі видумали ці ітеративні алгоритми?
    </p>
    <p>
Питання, звісно, саркастично-риторичне. Так само як&nbsp;практична ефективність ітеративного алгоритма залежить від сходимості, практична ефективність алгоритму точного залежить від його складності. Наприклад, цей конкретний алгоритм як&nbsp;раз непрактично складний.
    </p>
    <p>
Складність — це не&nbsp;те саме що&nbsp;просто кількість операцій. Як&nbsp;і&nbsp;сходимість, складність алгоритму може залежати від багатьох обставин. Інакше кажучи, змінних. Отже, це&nbsp;не число, а функція. Зазвичай, для того щоб записати функцію складності, ми&nbsp;використовуємо О-нотацію. Хитрість в&nbsp;тому, що&nbsp;у&nbsp;цій нотації ми&nbsp;описуємо вид трохи іншої функції — такої, яка обмежує складність алгоритму в&nbsp;залежності від певних параметрів.
    </p>
    <p>
Якщо, наприклад, треба оцінити цикл, який робить щось щонайбільше n раз, ми&nbsp;кажемо що&nbsp;його складність у&nbsp;О-нотації лінійна тобто <i>O(n)</i>. Насправді, навіть якщо в&nbsp;деяких випадках цикл може закінчити роботу не&nbsp;доходячи до&nbsp;кінця, на&nbsp;оцінку обмежуючої функції це&nbsp;не&nbsp;впливає. Ми&nbsp;описуємо обмеження влгоритму а не його справжні числа. Це&nbsp;дозволяє нам мати уявленя про нього не&nbsp;занурюючись у&nbsp;тонкощі імплементації
    </p>
    <p>
Якщо цикл має в&nbsp;середині ще один цикл, то оцінка складності стає квадратичною: <i>O(n<sup>2</sup>)</i>. Якщо це&nbsp;цикл всередині цикла всередині цикла: <i>O(n<sup>3</sup>)</i>. Оцінка подібного роду називається поліноміальною, і&nbsp;часто зустрічається на&nbsp;практиці. Наприклад, наш новий алгоритм теж має поліноміальну оціночну складність.
    </p>
    <div style="width:505pt;">
    <pre>
def cross_of(A):
  ''' n-dimensional cross product on (n-1) vectors in list A '''
  D = len(A[0])
  N = len(A)

  v_res = [0.] * D
  <b>for</b> i in xrange(0, D):
    <b>for</b> jk in xrange(0, D ** N):
      v_ijk = [i] + [(jk/(D ** (N-j-1))) % D <b>for</b> j in xrange(0, N)]
      t_res = v__E(v_ijk)
      if t_res != 0:
        <b>for</b> k in xrange(0, N):
          t_res *= A[k][v_ijk[k + 1]]
        v_res[i] += t_res
  return v_res


def solution_for(A, B):
  p = [0. for each in B]
  <b>for</b> i in xrange(len(A)):
    plane_n = A[i]
    plane_d = -B[i]
    other_planes_ns = A[:i] + A[i+1:]
    projection_vector = cross_of(other_planes_ns)
    p = project_by_vector(p, projection_vector, plane_n, plane_d)
  return p
    </pre>
    </div>

    <form>
        <b>Дев'ятий квест.</b> Оцініть складність цього алгоритму у&nbsp;O-нотації.<br>
        <div id="complexity_buttons" style="font-family:sans-serif; font-style:italic;"><i>
        <input type="radio" name="q8" id="aq8_1" value="A">O(n<sup>2</sup>)<br>
        <input type="radio" name="q8" id="aq8_2" value="B">O(n<sup>3</sup>)<br>
        <input type="radio" name="q8" id="aq8_3" value="C">O(n<sup>4</sup>)<br>
        <input type="radio" name="q8" id="aq8_4" value="D">O(n<sup>5</sup>)<br>
        </i>
        </div>
        <div id="reply_quest_9" style="padding-top:6pt;"></div>
        <div id="buttons_quest_9" style="text-align:right;">
            <button type="button" id="button_5_9" onclick="done_quest_9()">Перевірити!</button>
        </div>
    </form>
    <p>
Як ви&nbsp;можете собі уявити, така оцінка робить алгоритм неефективним на&nbsp;великих системах. Для розв'язку системи із&nbsp;тисячею рівнянь нашому алгоритму знадобиться порядка триліона операцій. Це&nbsp;немало. Якщо збільшити систему ще на&nbsp;кілька порядків, то Сонце згасне до&nbsp;того як&nbsp;він взагалі закінчить свою работу.
    </p>
    <p>
От ітеративні алгоритми для того і&nbsp;придумали, щоб не&nbsp;чекати тисячі років там де можна почекати кілька хвилин і&nbsp;мати не&nbsp;такий точний, але все-таки розв'язок.
    </p>
    <p>
Це не&nbsp;означає, що&nbsp;вони завжди працюють швидше за&nbsp;точні. Просто вони надають здатність балансувати між точністью і&nbsp;швидкістю.
    </p>
    <p>
Отже, наші попередні алгоритми годяться тільки для того, щоб навчати на&nbsp;них сходимості і&nbsp;складності. На&nbsp;щастя, ліпші варіанти вже давно знайдені, описані, і&nbsp;реалізовані в&nbsp;коді. Наприклад, алгоритм Гауса, який має складність <a href="https://en.wikipedia.org/wiki/Gaussian_elimination#Computational_efficiency"><i>O(n<sup>3</sup>)</i></a>. При тому, що&nbsp;теоретична найліпша складність LU-розкладення взагалі <a href="https://en.wikipedia.org/wiki/LU_decomposition#Theoretical_complexity"><i>O(n<sup>2.376</sup>)</i></a>.
    </p>
    <p>
Головна ідея розкладання полягає в&nbsp;тому, що&nbsp;ми&nbsp;можемо змінювати систему як&nbsp;нам заманеться, поки ми&nbsp;робитимемо це&nbsp;за правилами, які не&nbsp;порушують істиності кожного окремого рівняння.
    </p>
    <p>
Ми вже бачили, що&nbsp;якщо помножити рівняння на&nbsp;якесь ненульове число, її відповідна пряма не&nbsp;змінюється. Рівняння містить ту саму інформацію, що&nbsp;і&nbsp;до множення. 
    </p>
    <p>
А&nbsp;ще&nbsp;ми можемо додавати бідь-яке рівняння до&nbsp;будь-якого іншого. Звісно, це&nbsp;змінить його пряму, але не&nbsp;точку розв'язку, бо обидва рівняня мають однакову точку розв'язку за&nbsp;визначенням. Не&nbsp;неї додавання сусіднього рівняння матиме такий самий ефект як&nbsp;і&nbsp;множення. Ніякого.
    </p>
    <p>
Цих двох операцій цілком достатньо, щоб перетворити якусь довільну систему рівнянь на&nbsp;тривіальну.
    </p>
    <canvas id="system_3" width=640 height=512></canvas>
    <div style="text-align:right; width:640px; padding-bottom:12pt;">
        <button type="button" id="button_3_reset" onclick="reset_system_3()">Наново</button>
    </div>
    <table class="formula">
    <tr>
    <td rowspan=2 class="brackets">{</td>
    <td id="system_3_system_row1">
    a11x1 + a12x2 = b1
    </td>
    </tr><tr>
    <td id="system_3_system_row2">
    a21x1 + a22x2 = b2
    </td>
    </tr>
    </table>
    <button type="button" id="elimination" onclick="do_one_elimination_step()">Один крок</button>
    <p class="comment" id="step_name">
    </p>
    <h2>
P. S.
    </h2>
    <p>
Навчальні алгоритми — це просто забавки. Як&nbsp;обрати практичний алгоритм у&nbsp;кожному конкретному випадку? Ось&nbsp;декілька підказок.
    </p>
    <ol>
    <li>
Якщо система розряджена, тобто більшість коефіцієнтів дорівнюють нулю, доцільно використовувати один із&nbsp;спеціальних &laquo;sparce structures&raquo; методів основаних на&nbsp;<a href="https://en.wikipedia.org/wiki/LU_decomposition">розкладанні</a> (факторизації) або <a href="https://en.wikipedia.org/wiki/System_of_linear_equations#Elimination_of_variables">елімінації</a>.
    </li>
    <li>
Якщо рівняння утворюють диагонально домінантну матрицю, тобто найбільший коефіцієнт рівняння лежить на&nbsp;диагоналі, непогано працюють ітеративні методи, такі як&nbsp;<a href="https://en.wikipedia.org/wiki/Jacobi_method">метод Якобі</a> або <a href="https://en.wikipedia.org/wiki/Gauss%E2%80%93Seidel_method">Гауса-Зейделя</a>.
    </li>
    <li>
А от якщо система рівнянь малесенька, може 2, 3 або 4 рівняння, найкращім рішенням буде взагалі не&nbsp;використовувати алгоритмів. Знайдіть для неї розв'язок у&nbsp;загальному випадку використовуючи, наприклад, <a href="http://live.sympy.org/">SymPy</a> і&nbsp;вставьте його собі в&nbsp;код. Так, це&nbsp;працюватиме ефективніше за&nbsp;будь-який алгоритм. І&nbsp;ні, нема жодного закону, який міг би&nbsp;це&nbsp;заборонити.
    </li>
    </ol>
    <script language="JavaScript">
        init_plot_named('system_1');
        init_plot_named('system_2');
        init_plot_named('system_3');
        change_linear_multiplier();
        init_solver_1();
        init_solver_2();
    </script>

    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
    <tr>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
        <a href="../index.html"><img src="favicon.ico"></a>
    </td>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
        &nbsp;&larr; there's more.
    </td>
    <td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
        +
        <a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
        <a href="https://twitter.com/wordsandbuttons">Twitter</a> &
        <a href="https://news.ycombinator.com/from?site=wordsandbuttons.online">Hacker News</a>
    </td>
    </tr>
    </table>
    </center>
  </body>
</html>
