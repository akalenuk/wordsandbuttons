<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Partial order and non-boolean logic</title>
	<meta name="description" content="...">
	<meta name="keywords" content="mathematics, tutorials">
	<link rel="shortcut icon" type="image/x-icon" href="favicon.svg" />
	<style>
body {
	margin: 0 0 0 0;
}

a {
	text-decoration: none;
}

h1 {
	padding-top: 36pt;
	font-size: 24pt;
	width: 600pt;
	text-align: left;
}

h2 {
	padding-top: 20pt;
	font-size: 20pt;
	width: 555pt;
	text-align: left;
}

p {
	line-height: 1.42;
	font-size: 16pt;
	width: 505pt;
	text-align: left;
}

li {
	line-height: 2;
	font-size: 16pt;
	width: 505pt;
	text-align: left;
}

td.big {
	font-size: 42pt;
	vertical-align: middle;
	text-align: center;
}

pre {
	margin: 0 0 0 0;
	padding: 12pt 12pt 12pt 12pt;
	font-size: 12pt;
	text-align: left;
	border: none;
	width: 505pt;
}

table {
	border-width: 0pt;
}

td {
	vertical-align: top;
	font-size: 18pt;
}

td.comparison {
	border-top: 1px solid black;
	vertical-align: top;
	font-size: 18pt;
}

td.comparison_result {
	border-top: 1px solid black;
	vertical-align: top;
	font-size: 18pt;
	color: #777;
}

th {
	vertical-align: top;
	font-size: 18pt;
	font-weight: normal;
	padding-bottom: 8pt;
}

button {
	width: 248pt;
	height: 42pt;
	margin-left:4pt;
	margin-right:4pt;
	font-size: 16pt;
}

u {
	border-bottom: 1px dotted #000;
	text-decoration: none;
	cursor: pointer;
}

.formula {
	font-family: sans-serif;
	font-size: 16pt;
	font-style: italic;
	padding-top: 6pt;
	padding-bottom: 6pt;
}

input[type="text"] {
	width: 100pt;
	height: 22pt;
	padding-left: 3pt;
	font-size: 16pt;
	margin: 2pt 6pt 2pt 6pt;
	width: 48pt;
}

table.comparison {
	font-family: sans-serif;
	font-size: 13pt;
	width: 505pt;
	text-align: center;
	border-spacing: 16pt 0;
}

.formula {
	font-family: sans-serif;
	font-size: 15pt;
	font-style: italic;
	text-align: center;
	padding-top: 6pt;
	padding-bottom: 6pt;
}

.abc {
	font-family: sans-serif;
	font-size: 15pt;
	font-style: italic;
	white-space: nowrap;
}
	</style>
	<script language="JavaScript">
const slider_w = 608;
const slider_h = 84;
const slider_margin_left = 32;
const slider_margin_right = 32;
const slider_margin_top = 12;
const slider_margin_bottom = 12;

var slider_lb = [];
var slider_ub = [];
var slider_min_x = [];
var slider_max_x = [];
var slider_down = [];
var slider_template = [];
var slider_value = [];
var slider_lb_is_ub = [];

function position_slider(no, client_x, ub_is_lb) {
	const lb = slider_lb[no];
	const ub = slider_ub[no];
	const min_x = slider_min_x[no];
	const max_x = slider_max_x[no];
	
	var x = (client_x - slider_margin_left) / (slider_w - slider_margin_right - slider_margin_left);
	x = min_x + x * (max_x - min_x);
	x = Math.max(x, min_x);
	x = Math.min(x, max_x);
	if(ub_is_lb) {
		slider_lb[no] = x;
		slider_ub[no] = x;
	} else {
		if(Math.abs(x - lb) < Math.abs(x - ub))
			slider_lb[no] = x;
		else
			slider_ub[no] = x;
	}

	// they could still be swapped via 0-length interval
	if(slider_lb[no] > slider_ub[no]) {
		temp = slider_ub[no];
		slider_ub[no] = slider_lb[no];
		slider_lb[no] = temp;
	}
}

function init_slider(no, min_x, max_x, initial_lb, initial_ub, x_template, lb_is_ub, on_slide){
	var slider = document.getElementById("interval_" + String(no));
	slider_min_x[no] = min_x;
	slider_max_x[no] = max_x;
	slider_lb[no] = initial_lb;
	slider_ub[no] = initial_ub;
	slider_down[no] = false;
	slider_template[no] = x_template;
	slider_value[no] = min_x - 1.0; // anything below min is "none"
	slider_lb_is_ub[no] = lb_is_ub;
	draw_slider(no);

	slider.addEventListener('mouseleave', function(e){
		slider_lb[no] = Math.round(slider_lb[no] * 10) / 10;
		slider_ub[no] = Math.round(slider_ub[no] * 10) / 10;
		slider_down[no] = false;
		on_slide(slider_lb[no], slider_ub[no]);
		draw_slider(no);
	}, false);

	slider.addEventListener('mouseup', function(e){
		slider_lb[no] = Math.round(slider_lb[no] * 10) / 10;
		slider_ub[no] = Math.round(slider_ub[no] * 10) / 10;
		slider_down[no] = false;
		on_slide(slider_lb[no], slider_ub[no]);
		draw_slider(no);
	}, false);

	slider.addEventListener('mousedown', function(e){
		slider_down[no] = true;
		var canvas_rect = slider.getBoundingClientRect();
		position_slider(no, e.clientX - canvas_rect.left, slider_lb_is_ub[no]);
		on_slide(slider_lb[no], slider_ub[no]);
		draw_slider(no);
	}, false);

	slider.addEventListener('mousemove', function(e){
		if(slider_down[no] == true){
			var canvas_rect = slider.getBoundingClientRect();
			position_slider(no, e.clientX - canvas_rect.left, slider_lb_is_ub[no]);
			on_slide(slider_lb[no], slider_ub[no]);
			draw_slider(no);
		}
	}, false);
}

function draw_slider(no){
	x_template = slider_template[no]

	const slider = document.getElementById("interval_" + String(no));
	ctx = slider.getContext("2d");
	const lb = slider_lb[no];
	const ub = slider_ub[no];
	const min_x = slider_min_x[no];
	const max_x = slider_max_x[no];

	ctx.clearRect(0, 0, slider_w, slider_h);
	ctx.strokeStyle="#444444";
	ctx.fillStyle="#BBBBBB";
	const dw = slider_w - slider_margin_right - slider_margin_left;
	const dh = slider_h - slider_margin_top - slider_margin_bottom;

	ctx.fillRect(slider_margin_left, slider_margin_top, dw, dh);
	const lb01 = (lb - min_x) / (max_x - min_x);
	const ub01 = (ub - min_x) / (max_x - min_x);
	ctx.strokeStyle="#000000";
	ctx.fillStyle="#777777";
	ctx.fillRect(slider_margin_left + dw * lb01 - 0.5, slider_margin_top, dw * (ub01 - lb01) + 0.5, dh);

	ctx.font = "16px sans-serif";
	ctx.fillStyle="#d64562";

	// the whole interval
	ctx.textBaseline = "top";
	ctx.textAlign = "left";
	ctx.fillText("[" + x_template.replace("%x", String(min_x)) + ",", slider_margin_left + 6, slider_margin_top + 6);
	ctx.textAlign = "right";
	ctx.fillText(x_template.replace("%x", String(max_x)) + "]", slider_w - slider_margin_right - 6, slider_margin_top + 6);

	// the selected interval
	ctx.fillStyle="#942b3b";
	ctx.textBaseline = "bottom";
	ctx.textAlign = "left";
	if(slider_lb_is_ub[no]) {
		const text = x_template.replace("%x", lb.toFixed(1));
		const text_x = slider_margin_left + dw * lb01 + 6;
		ctx.fillText(text, text_x, slider_h - slider_margin_bottom - 6);
	} else {
		const left_piece_text = "[" + x_template.replace("%x", lb.toFixed(1)) + ",";
		const left_width = ctx.measureText(left_piece_text).width;
		const left_piece_x = slider_margin_left + dw * lb01 + 6;
		const right_piece_x = slider_margin_left + dw * ub01 - 6;
		const right_piece_text = x_template.replace("%x", ub.toFixed(1)) + "]";
		const right_width = ctx.measureText(right_piece_text).width;
		if(right_piece_x - left_piece_x - right_width - 12 > left_width)
			ctx.fillText(left_piece_text, left_piece_x, slider_h - slider_margin_bottom - 6);
		else
			ctx.fillText(left_piece_text + " " + right_piece_text, left_piece_x, slider_h - slider_margin_bottom - 6);
		ctx.textAlign = "right";
		if(right_piece_x - left_piece_x - right_width - 12 > left_width)
			ctx.fillText(right_piece_text, right_piece_x, slider_h - slider_margin_bottom - 6);
	}
}

function reevaluate() {
	// partial order. de = deffinitely equal, pe = possibly equal
	if(slider_lb[1] == slider_ub[1] && slider_lb[1] == slider_lb[2] && slider_lb[2] == slider_ub[2])
		document.getElementById('de').innerHTML = 'true';
	else
		document.getElementById('de').innerHTML = 'false';

	if( (slider_lb[1] <= slider_ub[2] && slider_ub[1] >= slider_lb[2]) || 
		(slider_ub[1] >= slider_lb[2] && slider_lb[1] <= slider_ub[2]))
		document.getElementById('pe').innerHTML = 'true';
	else
		document.getElementById('pe').innerHTML = 'false';

	if(slider_ub[1] < slider_lb[2])
		document.getElementById('dl').innerHTML = 'true';
	else
		document.getElementById('dl').innerHTML = 'false';

	if(slider_lb[1] < slider_ub[2])
		document.getElementById('pl').innerHTML = 'true';
	else
		document.getElementById('pl').innerHTML = 'false';

	if(slider_lb[1] > slider_ub[2])
		document.getElementById('dg').innerHTML = 'true';
	else
		document.getElementById('dg').innerHTML = 'false';

	if(slider_ub[1] > slider_lb[2])
		document.getElementById('pg').innerHTML = 'true';
	else
		document.getElementById('pg').innerHTML = 'false';


	if(slider_ub[1] < slider_lb[2] || slider_lb[1] > slider_ub[2])
		document.getElementById('dne').innerHTML = 'true';
	else
		document.getElementById('dne').innerHTML = 'false';

	if(!(slider_lb[1] == slider_ub[1] && slider_lb[1] == slider_lb[2] && slider_lb[2] == slider_ub[2]))
		document.getElementById('pne').innerHTML = 'true';
	else
		document.getElementById('pne').innerHTML = 'false';


	if(slider_lb[1] <= slider_lb[2] && slider_lb[1] <= slider_ub[2] && slider_ub[1] <= slider_ub[2] && slider_ub[1] <= slider_lb[2])
		document.getElementById('dle').innerHTML = 'true';
	else
		document.getElementById('dle').innerHTML = 'false';

	if(slider_lb[1] <= slider_lb[2] || slider_lb[1] <= slider_ub[2] || slider_ub[1] <= slider_ub[2] || slider_ub[1] <= slider_lb[2])
		document.getElementById('ple').innerHTML = 'true';
	else
		document.getElementById('ple').innerHTML = 'false';


	if(slider_lb[1] >= slider_lb[2] && slider_lb[1] >= slider_ub[2] && slider_ub[1] >= slider_ub[2] && slider_ub[1] >= slider_lb[2])
		document.getElementById('dge').innerHTML = 'true';
	else
		document.getElementById('dge').innerHTML = 'false';

	if(slider_lb[1] >= slider_lb[2] || slider_lb[1] >= slider_ub[2] || slider_ub[1] >= slider_ub[2] || slider_ub[1] >= slider_lb[2])
		document.getElementById('pge').innerHTML = 'true';
	else
		document.getElementById('pge').innerHTML = 'false';

	// total order e = equal
	if(slider_lb[3] == slider_lb[4])
		document.getElementById('e').innerHTML = 'true';
	else
		document.getElementById('e').innerHTML = 'false';

	if(slider_lb[3] < slider_lb[4])
		document.getElementById('l').innerHTML = 'true';
	else
		document.getElementById('l').innerHTML = 'false';

	if(slider_lb[3] > slider_lb[4])
		document.getElementById('g').innerHTML = 'true';
	else
		document.getElementById('g').innerHTML = 'false';

	if(slider_lb[3] != slider_lb[4])
		document.getElementById('ne').innerHTML = 'true';
	else
		document.getElementById('ne').innerHTML = 'false';

	if(slider_lb[3] <= slider_lb[4])
		document.getElementById('le').innerHTML = 'true';
	else
		document.getElementById('le').innerHTML = 'false';

	if(slider_lb[3] >= slider_lb[4])
		document.getElementById('ge').innerHTML = 'true';
	else
		document.getElementById('ge').innerHTML = 'false';
}
	</script>
</head>
<body>
	<center>
	<h1>
Partial order and non-boolean logic
	</h1>

	<p>
Numbers. Numbers are easy. All you need to know to sort them out is that
	</p>
	<ul>
	<li>
If 1 &le; 2 and 2 &le; 3 then 1 &le; 3.
	</li>
	<li>
Either 4 &le; 5 or 5 &le; 4...
	</li>
	<li>
...or both, but if 6 &le; 6 and 6 &le; 6 then 6 = 6.
	</li>
	</ul>
	<p>
Oh, shit! I forgot to do the mathy thing. Let's start over.
	</p>
	<p>
The first property is called <b>transitivity</b>.
	</p>
	<p class="formula">
a &le; b &and; b &le; c &rArr; a &le; c.
	</p>
	<p>
The second one is <b>connexity</b>.
	</p>
	<p class="formula">
a &le; b &or; b &le; a
	</p>
	<p>
And the third one is <b>antisymmetry</b>
	</p>
	<p class="formula">
a &le; b &and; b &le; a &rArr; a = b
	</p>
	<p>
These three rules or axioms are enough to install the <b>total order</b>, also known as <b>linear order</b> on the set of real numbers. This makes number sortable. Even though the only comparison sign in the rules is “<span class="abc">&le;</span>”, we can now tell either <span class="abc">a &lt; b</span> or <span class="abc">a &gt; b</span> or <span class="abc">a = b</span> for every a and b.
	</p>
	<table>
	<tr>
	<td class="big">a:</td><td><canvas id="interval_3" width=608 height=84></canvas></td>
	</tr><tr>
	<td class="big">b:</td><td><canvas id="interval_4" width=608 height=84></canvas></td>
	</tr>
	</table>
<br>

<table class="comparison">
<tr><th>Predicate</th><th>Result</th></tr>
<tr><td class="comparison">a = b</td>		<td id='e' class="comparison_result"></td></tr>
<tr><td class="comparison">a &lt; b</td>	<td id='l' class="comparison_result"></td></tr>
<tr><td class="comparison">a &gt; b</td>	<td id='g' class="comparison_result"></td></tr>
<tr><td class="comparison">a &ne; b</td>	<td id='ne' class="comparison_result"></td></tr>
<tr><td class="comparison">a &le; b</td>	<td id='le' class="comparison_result"></td></tr>
<tr><td class="comparison">a &ge; b</td>	<td id='ge' class="comparison_result"></td></tr>
</table>
	<p>
The numbers are comparable. That implies that you can sort them. Of course, not only numbers are comparable. Names are comparable and sortable in alphabetical order. Skyscrapers are comparable and sortable by height. A lot of things are comparable and sortable.
	</p>
	<p>
But a few things aren't. Like the <a href="https://wordsandbuttons.online/yet_another_alternative_to_floating_point_numbers.html">intervals we use to represent numbers with errors</a>. We use them when we don't know the exact number <span class="abc">x</span> but we know its error <span class="abc">&epsilon;</span> and therefore have all the reasons to believe that it's jammed somehwere between <span class="abc">x<sub>1</sub></span> and <span class="abc">x<sub>2</sub></span> where
	</p>
	<p class="formula">
x<sub>1</sub> = x &minus; &epsilon;
<br>
x<sub>2</sub> = x &plus; &epsilon;
	</p>
	<p>
These intervals are very helpful when we want to measure the computational error or to know if an algorithm is stable enough. They aren't comparable though.
	</p>
	<p>
Consider two overlapping intervals. Let's say, <span class="abc">[3, 6]</span> and <span class="abc">[5, 8]</span>. We know that the fist interval actually means a number in between  <span class="abc">3</span> and  <span class="abc">6</span>. The second — another number between <span class="abc">5</span> and <span class="abc">8</span>. Intuitively, the latter should be greater than the former. But what if it is  <span class="abc">5</span> and the former is  <span class="abc">6</span>? Then it's obviously less. There is a chance they are even equal. So we have some things and there is some kind of order, for instance,  <span class="abc">[6, 8]</span> is definitely greater than  <span class="abc">[3, 5]</span>. But this order doesn't hold for every possible pair of intervals.
	</p>
	<p>
This makes things unpleasant. For the very least, we can't now use Boolean logic since the all the comparisons now return three states. E. g. <span class="abc">a &le; b</span> can now be <span class="abc">true</span>, <span class="abc">false</span> or <span class="abc">none of the above</span>.
	</p>
	<p>
Consequently, this means the conventional <span class="abc">if... else</span> statement now has to be redesigned. And all the algorithms that use it.
	</p>
	<p>
Fortunatelly, we woulnd't have to give up boolean logic if we argee to “split” the semantics of the predicates into two. For every predicate on the two intervals, we can still say whether the numbers they represent definitely suffice the predicate, ot whether they possibly do so.
	</p>
	<p>
Now, for instance, <span class="abc">[3, 5]</span> is deffinitely less than <span class="abc">[6, 8]</span>, and <span class="abc">[3, 6]</span> is possibly less than <span class="abc">[5, 8]</span>.
	</p>
<br>
	<table>
	<tr>
	<td class="big">a:</td><td><canvas id="interval_1" width=608 height=84></canvas></td>
	</tr><tr>
	<td class="big">b:</td><td><canvas id="interval_2" width=608 height=84></canvas></td>
	</tr>
	</table>

<br>

<table class="comparison">
<tr><th>Predicate</th><th>Deffinitely</th><th>Possibly</th></tr>
<tr><td class="comparison">a = b</td>		<td id='de' class="comparison_result"></td>		<td id='pe' class="comparison_result"></td></tr>
<tr><td class="comparison">a &lt; b</td>	<td id='dl' class="comparison_result"></td>		<td id='pl' class="comparison_result"></td></tr>
<tr><td class="comparison">a &gt; b</td>	<td id='dg' class="comparison_result"></td>		<td id='pg' class="comparison_result"></td></tr>
<tr><td class="comparison">a &ne; b</td>	<td id='dne' class="comparison_result"></td>	<td id='pne' class="comparison_result"></td></tr>
<tr><td class="comparison">a &le; b</td>	<td id='dle' class="comparison_result"></td>	<td id='ple' class="comparison_result"></td></tr>
<tr><td class="comparison">a &ge; b</td>	<td id='dge' class="comparison_result"></td>	<td id='pge' class="comparison_result"></td></tr>
</table>

	<p>
Now every <span class="abc">if... else</span> works within its context. Yes, the algorithms still require revision since the algebra behind the logic changes. Now <span class="abc">&not; (a &lt; b) &nequiv; a &ge; b</span>. But at least they may be built using the same building blocks as if the intervals were numbers.
	</p>

	<script language="JavaScript">
	init_slider(1, 0, 10, 3, 6, "%x", false, function(lb, ub) {
		reevaluate();
	});
	init_slider(2, 0, 10, 5, 8, "%x", false, function(lb, ub) {
		reevaluate();
	});

	init_slider(3, 0, 10, 3, 3, "%x", true, function(lb, ub) {
		reevaluate();
	});
	init_slider(4, 0, 10, 7, 7, "%x", true, function(lb, ub) {
		reevaluate();
	});

	reevaluate();
	</script>


	<table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
	<tr>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
		<a href="all_mathematics.html">#mathematics</a> <a href="all_programming.html">#programming</a>
	</td>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
		&nbsp;&larr; there's more.
	</td>
	<td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
		+
		<a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
		<a href="https://wordsandbuttons.online/rss"><span style="letter-spacing: 1pt;">RSS</span></a>
	</td>
	</tr>
	</table>
	</center>
</body>
</html>
