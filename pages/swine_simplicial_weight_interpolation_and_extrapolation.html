<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SWInE: Simplicial Weight Interpolation and Extrapolation</title>
    <meta name="description" content="An alternative to splines nobody knows about. The localization of Shepard's method for a simplicial complex.">
    <meta name="keywords" content="mathematics, demos">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.svg" />
    <style>
body {
    margin: 0 0 0 0;
}

a {
    text-decoration: none;
}

h1 {
    padding-top: 36pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 20pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    line-height: 1.42;
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.formula {
    font-family: sans-serif;
    font-size: 15pt;
    font-style: italic;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

table.footer {
    padding: 64pt 0pt 32pt 0pt;
    background-color: transparent;
    width: 505pt;
}

td.footer {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: normal;
    padding: 0;
    margin: 0;
    border: 0;
}

li {
    font-size: 16pt;
    width: 505pt;
    text-align: left;
    padding-bottom: 6pt;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
    background-color: #eeee99;
}

input[type="text"] {
    width: 32pt;
    height: 22pt;
    font-size: 16pt;
    text-align: center;
}

button {
    width: 32pt;
    height: 26pt;
    font-size: 16pt;
    text-align: center;
}
    </style>
    <script language="JavaScript">
// client
const w = 640.0;
const h = 640.0;

//// 2d
// visible region (these are purely cosmetic, the real numbers are client)
var x2d_min = -1.0;
var y2d_min = -1.0;
var x2d_max = 4.0;
var y2d_max = 4.0;

var client_x2d_center = w*(0-x2d_min)/(x2d_max-x2d_min);
var client_x2d_step = (w/(x2d_max-x2d_min));

var client_y2d_center = h - h*(0-y2d_min)/(y2d_max-y2d_min);
var client_y2d_step = (h/(y2d_max-y2d_min));

function draw_grid_on(context){
    // grid
    context.font = "16px sans-serif";
    context.beginPath();
    context.moveTo(0, client_y2d_center);
    context.lineTo(w, client_y2d_center);
    context.lineTo(w - 12, client_y2d_center - 5);
    context.moveTo(w, client_y2d_center);
    context.lineTo(w - 12, client_y2d_center + 5);
    context.moveTo(client_x2d_center, h);
    context.lineTo(client_x2d_center, 0);
    context.lineTo(client_x2d_center - 5, 12);
    context.moveTo(client_x2d_center, 0);
    context.lineTo(client_x2d_center + 5, 12);
    context.fillStyle="#000000";
    for(var i = x2d_min + 1; i <= x2d_max - 1; i++){
        if(i != 0) {
            context.moveTo(client_x2d_center + i*client_x2d_step, client_y2d_center);
            context.lineTo(client_x2d_center + i*client_x2d_step, client_y2d_center - 5);
            context.fillText(i, client_x2d_center + i*client_x2d_step + 4, client_y2d_center + 16);
        }
    }
    for(var i = y2d_min + 1; i <= y2d_max - 1; i++){
        if(i != 0) {
            context.moveTo(client_x2d_center, client_y2d_center - i*client_y2d_step);
            context.lineTo(client_x2d_center + 5, client_y2d_center - i*client_y2d_step);
        }
        context.fillText(i, client_x2d_center + 5, client_y2d_center - i*client_y2d_step + 16);
    }
    context.strokeStyle = "#000000";
    context.stroke();
    context.closePath();
}

function closest_point_starting_from(x, y, xs, ys, i) {
    for(var j = i + 1; j < xs.length; ++j)
        if(d2(x, y, xs[j], ys[j]) < d2(x, y, xs[i], ys[i]))
            return closest_point_starting_from(x, y, xs, ys, j);
    return i;
}

// finds a closest point from xs, ys to x, y
function closest_point(x, y, xs, ys){
    return closest_point_starting_from(x, y, xs, ys, 0);
}

// interpolation/extrapolation with no basis functions
var weight2d1 = 2;
const wf2d1 = function(x) {return 1./Math.pow(x, weight2d1);}

function ie_no_basis(x, xs, ys) {
    if(x < xs[0])
        return ys[0];
    if(x > xs[xs.length- 1])
        return ys[xs.length - 1];

    var i = 0;
    for(var j = 0; j < xs.length; ++j)
        if(x > xs[j])
            i = j;
    return (ys[i] * wf2d1(x - xs[i]) + ys[i+1] * wf2d1(xs[i+1] - x))
        / (wf2d1(x - xs[i]) + wf2d1(xs[i+1] - x));
}

// interpolation/extrapolation with basis functions
var weight2d2 = 2;
const wf2d2 = function(x) {return 1./Math.pow(x, weight2d2);}

function ie_basis(x, xs, bs) {
    if(x < xs[0])
        return bs[0](x);
    if(x > xs[xs.length- 1])
        return bs[xs.length - 1](x);

    var i = 0;
    for(var j = 0; j < xs.length; ++j)
        if(x > xs[j])
            i = j;
    return (bs[i](x) * wf2d2(x - xs[i]) + bs[i+1](x) * wf2d2(xs[i+1] - x))
        / (wf2d2(x - xs[i]) + wf2d2(xs[i+1] - x));
}

// returns [a, b] for ax+b basis function
function linear_basis(x1, y1, x2, y2) {
    /*
    x1, y1, x2, y2, a, b = symbols('x1 y1 x2 y2 a b')
    print(solve([
        a * x1 + b - y1,
        a * x2 + b - y2
        ], (a, b)))
    */
    return ab = [(y1 - y2)/(x1 - x2), (x1*y2 - x2*y1)/(x1 - x2)];
}

// fits linear functon to go trough the point (retaining the slope)
function fit_linear_to(basis, x, y) {
    const delta_b = y - (basis[0] * x + basis[1]);
    return [basis[0], basis[1] + delta_b];
}

// returns [a, b, c] for a*x*x + b*x + c
function quadratic_basis(x1, y1, x2, y2, x3, y3) {
    /*
    x1, y1, x2, y2, x3, y3, a, b, c = symbols('x1 y1 x2 y2 x3 y3 a b c')

    print(solve([
        a * x1 * x1 + b * x1 + c - y1,
        a * x2 * x2 + b * x2 + c - y2,
        a * x3 * x3 + b * x3 + c - y3,
        ], (a, b, c)))
    */
    return abc = [
        (y1*(x2 - x3) - y2*(x1 - x3) + y3*(x1 - x2))/(x1*x1*x2 - x1*x1*x3 - x1*x2*x2 + x1*x3*x3 + x2*x2*x3 - x2*x3*x3),
        (-y1*(x2*x2 - x3*x3) + y2*(x1*x1 - x3*x3) - y3*(x1*x1 - x2*x2))/(x1*x1*x2 - x1*x1*x3 - x1*x2*x2 + x1*x3*x3 + x2*x2*x3 - x2*x3*x3),
        (x1*x2*y3*(x1 - x2) - x1*x3*y2*(x1 - x3) + x2*x3*y1*(x2 - x3))/(x1*x1*x2 - x1*x1*x3 - x1*x2*x2 + x1*x3*x3 + x2*x2*x3 - x2*x3*x3)
    ];
}

var x2s1 = [128*2, 128*4];
var y2s1 = [128*3, 128*1];

var x2s2 = [128*1, 128*2, 128*3, 128*4];
var y2s2 = [128*2, 128*1, 128*2.5, 128*3];

function order_points_s1() {
    if(x2s1[0] > x2s1[1]) {
        x = x2s1[0];
        y = y2s1[0];
        x2s1[0] = x2s1[1];
        y2s1[0] = y2s1[1];
        x2s1[1] = x;
        y2s1[1] = y;
    }
}

function init_canvas2d1() {
    var canvas = document.getElementById("canvas2d1");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        const point_i = closest_point(x, y, x2s1, y2s1);
        x2s1[point_i] = x;
        y2s1[point_i] = y;
        order_points_s1();
        draw_canvas2d1(0, 0, false);
    }, false);

    canvas.addEventListener('mousemove', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        if(e.buttons == 1){
            const point_i = closest_point(x, y, x2s1, y2s1);
            x2s1[point_i] = x;
            y2s1[point_i] = y;
            order_points_s1();
            draw_canvas2d1(0, 0, false);
        } else {
            draw_canvas2d1(x, y, true);
        }
    }, false);

    canvas.addEventListener('mouseup', function(e){
        order_points_s1();
        draw_canvas2d1(0, 0, false);
    }, false);

    canvas.addEventListener('mouseleave', function(e){
        draw_canvas2d1(0, 0, false);
    }, false);

    draw_canvas2d1();
}

function draw_canvas2d1(client_x, client_y, do_guides){
    var canvas = document.getElementById("canvas2d1");
    var context = canvas.getContext("2d");

    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    const do_interpolation = document.getElementById("i").checked || document.getElementById("ie").checked;
    const do_extrapolation = document.getElementById("e").checked || document.getElementById("ie").checked;
    // interpolation/extrapolation
    context.strokeStyle="#888888";
    context.lineWidth = 3;
    context.beginPath()
    for(var i = 0; i < w; ++i) {
        var do_segment =  ((i < x2s1[0]-1 || i > x2s1[x2s1.length - 1]) && do_extrapolation)
                       || ((i >= x2s1[0]-1 && i <= x2s1[x2s1.length - 1]) && do_interpolation);
        if(do_segment) {
            const y1 = ie_no_basis(i, x2s1, y2s1);
            const y2 = ie_no_basis(i+1, x2s1, y2s1);
            if((Math.abs(i + 1 - x2s1[0]) <= 0.5 || Math.abs(i - x2s1[1]) <= 0.5) && weight2d1 <= 0.)
                continue; // ironic, since this is the function's discontinuity
            context.moveTo(i, y1);
            context.lineTo(i+1, y2);
        }
    }
    context.stroke();
    context.closePath();
    context.lineWidth = 1;

    // grid
    draw_grid_on(context);

    // dots
    context.strokeStyle="#f71134";
    for(var i = 0; i <= x2s1.length; ++i){
        context.beginPath();
        context.arc(x2s1[i], y2s1[i], 4, 0, 2*Math.PI);
        context.stroke();
        context.closePath();
    }

    // guides
    if(do_guides){
        const point_i = closest_point(client_x, client_y, x2s1, y2s1);
        draw_arrow(context, x2s1[point_i], y2s1[point_i], client_x, client_y);
    }
}

var basis2d = [];
function recalculate_basis2d() {
    /*
    cccc onstant-constant-constant-constant
    cllc constant-linear-linear-constant
    llll linear-linear-linear-linear
    cqqc constant-quadratic-quadratic-constant
    lqql linear-quadratic-quadratic-linear
    qqqq quadratic-quadratic-quadratic-quadratic
    */
    if(document.getElementById("cccc").checked) {
        basis2d[0] = function(x) {return y2s2[0];};
        basis2d[1] = function(x) {return y2s2[1];};
        basis2d[2] = function(x) {return y2s2[2];};
        basis2d[3] = function(x) {return y2s2[3];};
    } else if(document.getElementById("cllc").checked) {
        const b1 = fit_linear_to(linear_basis(x2s2[0], y2s2[0], x2s2[2], y2s2[2]), x2s2[1], y2s2[1]);
        const b2 = fit_linear_to(linear_basis(x2s2[1], y2s2[1], x2s2[3], y2s2[3]), x2s2[2], y2s2[2]);
        basis2d[0] = function(x) {return y2s2[0];};
        basis2d[1] = function(x) {return b1[0]*x + b1[1];};
        basis2d[2] = function(x) {return b2[0]*x + b2[1];};
        basis2d[3] = function(x) {return y2s2[3];};
    } else if(document.getElementById("llll").checked) {
        const b0 = linear_basis(x2s2[0], y2s2[0], x2s2[1], y2s2[1]);
        const b1 = fit_linear_to(linear_basis(x2s2[0], y2s2[0], x2s2[2], y2s2[2]), x2s2[1], y2s2[1]);
        const b2 = fit_linear_to(linear_basis(x2s2[1], y2s2[1], x2s2[3], y2s2[3]), x2s2[2], y2s2[2]);
        const b3 = linear_basis(x2s2[2], y2s2[2], x2s2[3], y2s2[3]);
        basis2d[0] = function(x) {return b0[0]*x + b0[1];};
        basis2d[1] = function(x) {return b1[0]*x + b1[1];};
        basis2d[2] = function(x) {return b2[0]*x + b2[1];};
        basis2d[3] = function(x) {return b3[0]*x + b3[1];};
    } else if(document.getElementById("cqqc").checked) {
        const b1 = quadratic_basis(x2s2[0], y2s2[0], x2s2[1], y2s2[1], x2s2[2], y2s2[2]);
        const b2 = quadratic_basis(x2s2[1], y2s2[1], x2s2[2], y2s2[2], x2s2[3], y2s2[3]);
        basis2d[0] = function(x) {return y2s2[0];};
        basis2d[1] = function(x) {return b1[0]*x*x + b1[1]*x + b1[2];};
        basis2d[2] = function(x) {return b2[0]*x*x + b2[1]*x + b2[2];};
        basis2d[3] = function(x) {return y2s2[3];};
    } else if(document.getElementById("lqql").checked) {
        const b0 = linear_basis(x2s2[0], y2s2[0], x2s2[1], y2s2[1]);
        const b1 = quadratic_basis(x2s2[0], y2s2[0], x2s2[1], y2s2[1], x2s2[2], y2s2[2]);
        const b2 = quadratic_basis(x2s2[1], y2s2[1], x2s2[2], y2s2[2], x2s2[3], y2s2[3]);
        const b3 = linear_basis(x2s2[2], y2s2[2], x2s2[3], y2s2[3]);
        basis2d[0] = function(x) {return b0[0]*x + b0[1];};
        basis2d[1] = function(x) {return b1[0]*x*x + b1[1]*x + b1[2];};
        basis2d[2] = function(x) {return b2[0]*x*x + b2[1]*x + b2[2];};
        basis2d[3] = function(x) {return b3[0]*x + b3[1];};
    } else if(document.getElementById("qqqq").checked) {
        const b1 = quadratic_basis(x2s2[0], y2s2[0], x2s2[1], y2s2[1], x2s2[2], y2s2[2]);
        const b2 = quadratic_basis(x2s2[1], y2s2[1], x2s2[2], y2s2[2], x2s2[3], y2s2[3]);
        basis2d[0] = function(x) {return b1[0]*x*x + b1[1]*x + b1[2];};
        basis2d[1] = function(x) {return b1[0]*x*x + b1[1]*x + b1[2];};
        basis2d[2] = function(x) {return b2[0]*x*x + b2[1]*x + b2[2];};
        basis2d[3] = function(x) {return b2[0]*x*x + b2[1]*x + b2[2];};
    }
}

function init_canvas2d2(){
    var canvas = document.getElementById("canvas2d2");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        const point_i = closest_point(x, y, x2s2, y2s2);
        x2s2[point_i] = x;
        y2s2[point_i] = y;
        recalculate_basis2d();
        draw_canvas2d2(0, 0, false);
    }, false);

    canvas.addEventListener('mousemove', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        if(e.buttons == 1){
            const point_i = closest_point(x, y, x2s2, y2s2);
            x2s2[point_i] = x;
            y2s2[point_i] = y;
            recalculate_basis2d();
            draw_canvas2d2(0, 0, false);
        } else {
            draw_canvas2d2(x, y, true);
        }
    }, false);

    canvas.addEventListener('mouseup', function(e){
        draw_canvas2d2(0, 0, false);
    }, false);

    canvas.addEventListener('mouseleave', function(e){
        draw_canvas2d2(0, 0, false);
    }, false);

    recalculate_basis2d();
    draw_canvas2d2();
}

function draw_canvas2d2(client_x, client_y, do_guides){
    var canvas = document.getElementById("canvas2d2");
    var context = canvas.getContext("2d");

    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // interpolation/extrapolation
    context.strokeStyle="#888888";
    context.lineWidth = 3;
    context.beginPath()
    for(var i = 0; i < w; ++i) {
        const y1 = ie_basis(i, x2s2, basis2d);
        const y2 = ie_basis(i+1, x2s2, basis2d);
        context.moveTo(i, y1);
        context.lineTo(i+1, y2);
    }
    context.stroke();
    context.closePath();
    context.lineWidth = 1;

    // basis
    context.strokeStyle="#f71134";
    for(var j = 0; j < x2s2.length; ++j) {
        context.beginPath()
        for(var i = 0; i < w; ++i) {
            if(Math.abs(i - x2s2[j]) < 64) {
                const y1 = basis2d[j](i);
                const y2 = basis2d[j](i+1);
                context.moveTo(i, y1);
                context.lineTo(i+1, y2);
            }
        }
        context.stroke();
        context.closePath();
    }

    // grid
    draw_grid_on(context);

    // dots
    context.strokeStyle="#f71134";
    for(var i = 0; i <= x2s2.length; ++i){
        context.beginPath();
        context.arc(x2s2[i], y2s2[i], 4, 0, 2*Math.PI);
        context.stroke();
        context.closePath();
    }

    // guides
    if(do_guides){
        const point_i = closest_point(client_x, client_y, x2s2, y2s2);
        draw_arrow(context, x2s2[point_i], y2s2[point_i], client_x, client_y);
    }
}


//// 3d
// points
const a = 256;
var x3s = [-1, 320   , 320 - a/2, 320 + a/2, 320 + a, 320 + a/2, 320 - a/2, 320 - a];
var y3s = [-1, 320   , 320 - a  , 320 - a  , 320    , 320 + a  , 320 + a  , 320    ];
var z3s = [-1, 8*4+4 , 8*16+4   , 8*28+4   , 8*12+4 , 8*20+4   , 8*24+4   , 8*8+4  ];
// triangles' points are ordered clockwise
var tris = [[2, 3, 1], [3, 4, 1], [4, 5, 1], [5, 6, 1], [6, 7, 1], [7, 2, 1]];

// weight funtion
var weight3d = 2;
const wf = function(x) {return 1./Math.pow(x, weight3d);}


// finds a closest point from x3s, y3s to x, y
function closest_3d_point(x, y){
    return closest_point_starting_from(x, y, x3s, y3s, 1);
}

// point belongs to a triangle
function in_tri(px, py, x1, y1, x2, y2, x3, y3) {
    /* shove it into sympy to get solution
    px, py, x1, y1, x2, y2, x3, y3, a, b = symbols('px py x1 y1 x2 y2 x3 y3 a b')
    solve([
    x1 + a * (x2-x1) + b * (x3-x1) - px,
    y1 + a * (y2-y1) + b * (y3-y1) - py
    ], (a, b))
    */
    var d = 1.0 / ((x1 - x2)*(y1 - y3) - (x1 - x3)*(y1 - y2));
    var a = (-(px - x1)*(y1 - y3) + (py - y1)*(x1 - x3)) * d;
    var b = ((px - x1)*(y1 - y2) - (py - y1)*(x1 - x2)) * d;
    return (a >= 0 && b >= 0 && a + b <= 1.);
}

// point projection belongs to an edge
function in_edge(px, py, x1, y1, x2, y2) {
    if((px-x1)*(y2-y1)-(py-y1)*(x2-x1) < 0) // border should be ordered for that
        return false;
    /*
    px, py, x1, y1, x2, y2, a = symbols('px py x1 y1 x2 y2 a')
    solve([(x1 + (x2 - x1) * a - px) * (x2 - x1) + (y1 + (y2 - y1) * a - py) * (y2 - y1)], (a))
    */
    var a = (-px*x1 + px*x2 - py*y1 + py*y2 + x1*x1 - x1*x2 + y1*y1 - y1*y2)/(x1*x1 - 2*x1*x2 + x2*x2 + y1*y1 - 2*y1*y2 + y2*y2);
    return (a > 0 && a < 1);
}

// distance squared from (x1, y1) to (x2, y2)
function d2(x1, y1, x2, y2) {
    return (x2-x1)*(x2-x1)+(y2-y1)*(y2-y1);
}

// project point on edge
function projected_on_edge(px, py, x1, y1, x2, y2) {
     /*
    px, py, x1, y1, x2, y2, a = symbols('px py x1 y1 x2 y2 a')
    solve([(x1 + (x2 - x1) * a - px) * (x2 - x1) + (y1 + (y2 - y1) * a - py) * (y2 - y1)], (a))
    */
    var a = (-px*x1 + px*x2 - py*y1 + py*y2 + x1*x1 - x1*x2 + y1*y1 - y1*y2)/(x1*x1 - 2*x1*x2 + x2*x2 + y1*y1 - 2*y1*y2 + y2*y2);
    return [x1 + (x2 - x1) * a, y1 + (y2 - y1) * a];
}

// distance from (x1, y1) to (x2, y2)
function d(x1, y1, x2, y2) {
    return Math.sqrt(d2(x1, y1, x2, y2));
}

// distance from (x, y) to edge [(x1, y1), (x2, y2)]
function d_e(x, y, x1, y1, x2, y2) {
    const dxe = x2-x1;
    const dye = y2-y1;
    const dx = x-x1;
    const dy = y-y1;
    const area = Math.abs(dxe*dy - dye*dx);
    return area / d(x1, y1, x2, y2);
}

const d_min = 1e-5; // too close

// interpolation on the edge
function z_in_edge(px, py, x1, y1, z1, x2, y2, z2) {
    const pp = projected_on_edge(px, py, x1, y1, x2, y2);
    const d1 = d(pp[0], pp[1], x1, y1);
    const d2 = d(pp[0], pp[1], x2, y2);
    if(d1 < d_min)
        return z1;
    if(d2 < d_min)
        return z2;
    return (z1 * wf(d1) + z2 * wf(d2)) / (wf(d1) + wf(d2));
}

function z_in_edge_by_basis(px, py, x1, y1, b1, x2, y2, b2) {
    const pp = projected_on_edge(px, py, x1, y1, x2, y2);
    const d1 = d(pp[0], pp[1], x1, y1);
    const d2 = d(pp[0], pp[1], x2, y2);
    if(d1 < d_min)
        return b1(x1, y1);
    if(d2 < d_min)
        return b2(x2, y2);
    return (b1(px, py) * wf(d1) + b2(px, py) * wf(d2)) / (wf(d1) + wf(d2));
}

// interpolation in tri
function z_in_tri(px, py, x1, y1, z1, x2, y2, z2, x3, y3, z3) {
    const d1 = d_e(px, py, x1, y1, x2, y2);
    const d2 = d_e(px, py, x2, y2, x3, y3);
    const d3 = d_e(px, py, x3, y3, x1, y1);
    if(d1 < d_min)
        return z_in_edge(px, py, x1, y1, z1, x2, y2, z2);
    if(d2 < d_min)
        return z_in_edge(px, py, x2, y2, z2, x3, y3, z3);
    if(d3 < d_min)
        return z_in_edge(px, py, x3, y3, z3, x1, y1, z1);
    return (z_in_edge(px, py, x1, y1, z1, x2, y2, z2) * wf(d1)
          + z_in_edge(px, py, x2, y2, z2, x3, y3, z3) * wf(d2)
          + z_in_edge(px, py, x3, y3, z3, x1, y1, z1) * wf(d3))
        / (wf(d1) + wf(d2) + wf(d3));
}

function z_in_tri_by_basis(px, py, x1, y1, b1, x2, y2, b2, x3, y3, b3) {
    const d1 = d_e(px, py, x1, y1, x2, y2);
    const d2 = d_e(px, py, x2, y2, x3, y3);
    const d3 = d_e(px, py, x3, y3, x1, y1);
    if(d1 < d_min)
        return z_in_edge_by_basis(px, py, x1, y1, b1, x2, y2, b2);
    if(d2 < d_min)
        return z_in_edge_by_basis(px, py, x2, y2, b2, x3, y3, b3);
    if(d3 < d_min)
        return z_in_edge_by_basis(px, py, x3, y3, b3, x1, y1, b1);
    return (z_in_edge_by_basis(px, py, x1, y1, b1, x2, y2, b2) * wf(d1)
          + z_in_edge_by_basis(px, py, x2, y2, b2, x3, y3, b3) * wf(d2)
          + z_in_edge_by_basis(px, py, x3, y3, b3, x1, y1, b1) * wf(d3))
        / (wf(d1) + wf(d2) + wf(d3));
}

// approximator (used to build a linear basis)
function solved_linear(A, B, n){
    function underflow_padded(x){
        function sign_0_positive(x){ // Math.sign like with no 0 option
            if(x >= 0)
                return 1.0;
            return -1.0;
        }
        if(Math.abs(x) < 1.e-5) // pixel-size input error is ok, so we don't want much precision anyway
            return 1.e-5 * sign_0_positive(x);
        return x;
    }
    var X = [];
    for (var i = 0; i < n; ++i)
        X.push(0.0);

    // triangulize
    for (var i = 0; i < n-1; ++i)
        for (var j = 0; j < i+1; ++j) {
            r = A[i+1][j] / underflow_padded(A[j][j]);
            A[i+1][j] = 0.;
            for (var b_j = j+1; b_j < n; ++b_j){
                A[i+1][b_j] -= A[j][b_j]*r;
            }
            B[i+1] -= B[j]*r;
        }

    // calculate xs
    X[n-1] = B[n-1] / underflow_padded(A[n-1][n-1]);
    for (var i = n-2; i >= 0; --i){
        var s = 0.0;
        for (var j = i; j < n; ++j){
            s = s + A[i][j]*X[j];
        }
        X[i] = (B[i] - s) / underflow_padded(A[i][i]);
    }
    return X;
}

function approximation_polynomial_coefficients_for(points, n) {
    const N = points.length;
    var A = [];
    var B = [];

    for (var i = 0; i < n; ++i){
        var Ai = []
        for (var j = 0; j < n; ++j){
            Ai.push(0);
            for(var k = 0; k < N; ++k){
                Ai[j] += Math.pow(points[k][0], i + j);
            }
        }
        A.push(Ai);
        B.push(0);
        for(var k = 0; k < N; ++k){
            B[i] += points[k][1] * Math.pow(points[k][0], i);
        }
    }
    return solved_linear(A, B, n);
}

function init_canvas3d(){
    var canvas = document.getElementById("canvas3d");
    canvas.addEventListener('mousedown', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        const point_i = closest_3d_point(x, y);
        x3s[point_i] = x;
        y3s[point_i] = y;
        compute_edges_and_z_field();
        draw_canvas3d(0, 0, false);
    }, false);

    canvas.addEventListener('mousemove', function(e){
        canvas_rect = canvas.getBoundingClientRect();
        const x = e.clientX - canvas_rect.left;
        const y = e.clientY - canvas_rect.top;
        if(e.buttons == 1){
            const point_i = closest_3d_point(x, y);
            x3s[point_i] = x;
            y3s[point_i] = y;
            compute_edges_and_z_field();
            draw_canvas3d(0, 0, false);
        } else {
            draw_canvas3d(x, y, true);
        }
    }, false);

    canvas.addEventListener('mouseup', function(e){
        draw_canvas3d(0, 0, false);
    }, false);

    canvas.addEventListener('mouseleave', function(e){
        draw_canvas3d(0, 0, false);
    }, false);

    compute_edges_and_z_field();
    draw_canvas3d();
}

function draw_arrow(context, x1, y1, x2, y2, color) {
	const d = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
	const t = d < 16 ? (d / 16.) : 1.;
	context.beginPath();
	context.moveTo(x1, y1);
	context.lineTo(x2, y2);
	context.moveTo(x2 - ((y2 - y1) * 4.5 / d + (x2 - x1) * 16.5 / d) * t, y2 - ((y2 - y1) * 16.5 / d - (x2 - x1) * 4.5 / d) * t);
	context.lineTo(x2, y2);
	context.moveTo(x2 + ((y2 - y1) * 4.5 / d - (x2 - x1) * 16.5 / d) * t, y2 - ((y2 - y1) * 16.5 / d + (x2 - x1) * 4.5 / d) * t);
	context.lineTo(x2, y2);
	context.strokeStyle = color;
	context.stroke();
	context.closePath();
}

// these hacks are here to store edges in sets
function edge_as_number(edge) {
    return edge[0] * 10000 + edge[1];
}

function number_as_edge(number) {
    return [Math.floor(number / 10000), number % 10000];
}

var edges = [];
var basis_3d = [];
var z_field = [];
const Z_NOT_DETERMINED = Number.NEGATIVE_INFINITY;
const Z_NOT_APLICABLE = Number.POSITIVE_INFINITY;
function compute_edges_and_z_field() {
    // compute all edges
    var all_edges = new Set();
    var inner_edges = new Set();
    for(var i = 0; i < tris.length; ++i) {
        for(var j = 0; j < 3; ++j) {
            const i1 = tris[i][j % 3];
            const i2 = tris[i][(j+1) % 3];
            const ordered_edge = i1 < i2 ? [i1, i2] : [i2, i1];
            if(all_edges.has(edge_as_number(ordered_edge)))
                inner_edges.add(edge_as_number(ordered_edge));
            all_edges.add(edge_as_number(ordered_edge))
        }
    }
    edges = Array.from(all_edges.values()).map(number_as_edge);

    // compute outer edges
    var outer_edges = [];
    for(var i = 0; i < tris.length; ++i) {
        for(var j = 0; j < 3; ++j) {
            const edge = [tris[i][j % 3], tris[i][(j+1) % 3]];
            const egde = [tris[i][(j+1) % 3], tris[i][j % 3]];
            if(!(inner_edges.has(edge_as_number(edge)) || inner_edges.has(edge_as_number(egde))))
                outer_edges.push(edge);
        }
    }

    const do_interpolation = document.getElementById("i3d").checked || document.getElementById("ie3d").checked;
    const do_extrapolation = document.getElementById("e3d").checked || document.getElementById("ie3d").checked;
    const do_linear_basis = document.getElementById("basis3d_linear").checked;
    if(do_linear_basis) {
        basis_3d = [[]]; // starts with 1 (0 is empty)

        for(var i = 1; i < x3s.length; ++i) {
            var points_i = [i];
            // find neighbors
            for(var j = 0; j < edges.length; ++j) {
                if(edges[j][0] == i)
                    points_i.push(edges[j][1]);
                if(edges[j][1] == i)
                    points_i.push(edges[j][0]);
            }
            var x_points = [];
            var y_points = [];
            for(var j = 0; j < points_i.length; ++j) {
                x_points.push([x3s[points_i[j]],z3s[points_i[j]]]);
                y_points.push([y3s[points_i[j]],z3s[points_i[j]]]);
            }
            const x_line = approximation_polynomial_coefficients_for(x_points, 2);
            const y_line = approximation_polynomial_coefficients_for(y_points, 2);
            const oa = x_line[1];
            const ob = y_line[1];
            const oc = z3s[i] - (oa*x3s[i] + ob*y3s[i]);
            basis_3d.push(function(x, y) {return oa * x + ob * y + oc;});
        }

        // compute z-field with linear basis
        z_field = [];
        for (var i = 0; i < w*h; i += 1) {
            var y = Math.floor(i / w);
            var x = i % w;
            var z = Z_NOT_DETERMINED;
            for(var j = 0; j < tris.length; ++j)
                if(in_tri(x, y, x3s[tris[j][0]], y3s[tris[j][0]], x3s[tris[j][1]], y3s[tris[j][1]], x3s[tris[j][2]], y3s[tris[j][2]])) {
                    if(do_interpolation)
                        z = z_in_tri_by_basis(x, y,
                            x3s[tris[j][0]], y3s[tris[j][0]], basis_3d[tris[j][0]],
                            x3s[tris[j][1]], y3s[tris[j][1]], basis_3d[tris[j][1]],
                            x3s[tris[j][2]], y3s[tris[j][2]], basis_3d[tris[j][2]]);
                    else
                        z = Z_NOT_APLICABLE;
                    break;
                }
            if(do_extrapolation && z == Z_NOT_DETERMINED) {
                for(var j = 0; j < outer_edges.length; ++j) {
                    if(in_edge(x, y, x3s[outer_edges[j][0]], y3s[outer_edges[j][0]], x3s[outer_edges[j][1]], y3s[outer_edges[j][1]])) {
                        if(z != Z_NOT_DETERMINED && z != Z_NOT_APLICABLE) {
                            break
                        }
                        z = z_in_edge_by_basis(x, y, x3s[outer_edges[j][0]], y3s[outer_edges[j][0]], basis_3d[outer_edges[j][0]], x3s[outer_edges[j][1]], y3s[outer_edges[j][1]], basis_3d[outer_edges[j][1]]);
                    }
                }
            }
            if(do_extrapolation && z == Z_NOT_DETERMINED)
                z = basis_3d[closest_3d_point(x, y)](x, y);
            z_field.push(z);
        }
    } else {
        // compute z-field with constant values instead of basis
        z_field = [];
        for (var i = 0; i < w*h; i += 1) {
            var y = Math.floor(i / w);
            var x = i % w;
            var z = Z_NOT_DETERMINED;

            for(var j = 0; j < tris.length; ++j)
                if(in_tri(x, y, x3s[tris[j][0]], y3s[tris[j][0]], x3s[tris[j][1]], y3s[tris[j][1]], x3s[tris[j][2]], y3s[tris[j][2]])) {
                    if(do_interpolation)
                        z = z_in_tri(x, y,
                            x3s[tris[j][0]], y3s[tris[j][0]], z3s[tris[j][0]],
                            x3s[tris[j][1]], y3s[tris[j][1]], z3s[tris[j][1]],
                            x3s[tris[j][2]], y3s[tris[j][2]], z3s[tris[j][2]]);
                    else
                        z = Z_NOT_APLICABLE;
                    break;
                }
            if(do_extrapolation && z == Z_NOT_DETERMINED) {
                for(var j = 0; j < outer_edges.length; ++j) {
                    if(in_edge(x, y, x3s[outer_edges[j][0]], y3s[outer_edges[j][0]], x3s[outer_edges[j][1]], y3s[outer_edges[j][1]])) {
                        if(z != Z_NOT_DETERMINED && z != Z_NOT_APLICABLE) {
                            break
                        }
                        z = z_in_edge(x, y, x3s[outer_edges[j][0]], y3s[outer_edges[j][0]], z3s[outer_edges[j][0]], x3s[outer_edges[j][1]], y3s[outer_edges[j][1]], z3s[outer_edges[j][1]]);
                    }
                }
            }
            if(do_extrapolation && z == Z_NOT_DETERMINED)
                z = z3s[closest_3d_point(x, y)];
            z_field.push(z);
        }
    }
}

function draw_canvas3d(client_x, client_y, do_guides){
    var canvas = document.getElementById("canvas3d");
    var context = canvas.getContext("2d");

    // draw z-field
    var pixel_field = context.createImageData(w, h);
    for (var i = 0; i < pixel_field.data.length; i += 4) {
        if(z_field[Math.floor(i/4)] == Z_NOT_APLICABLE || z_field[Math.floor(i/4)] == Z_NOT_DETERMINED) {
            pixel_field.data[i + 0] = 0x00;
            pixel_field.data[i + 1] = 0x00;
            pixel_field.data[i + 2] = 0x00;
            pixel_field.data[i + 3] = 0x00;
        } else {
            const color = Math.trunc(z_field[Math.floor(i/4)] / 8) * 8;
            pixel_field.data[i + 0] = color;
            pixel_field.data[i + 1] = color;
            pixel_field.data[i + 2] = color;
            pixel_field.data[i + 3] = 0xFF;
        }
    }
    context.putImageData(pixel_field, -0.5, -0.5);

    // dots
    context.strokeStyle="#f71134";
    for(var i = 1; i <= x3s.length; ++i){
        context.beginPath();
        context.arc(x3s[i], y3s[i], 4, 0, 2*Math.PI);
        context.stroke();
        context.closePath();
    }

    // guides
    if(do_guides){
        const point_i = closest_3d_point(client_x, client_y);
        draw_arrow(context, x3s[point_i], y3s[point_i], client_x, client_y);
    }

    // complex
    context.setLineDash([4, 4]);
    for(var i = 0; i < edges.length; ++i) {
     context.beginPath();
        context.moveTo(x3s[edges[i][0]], y3s[edges[i][0]]);
        context.lineTo(x3s[edges[i][1]], y3s[edges[i][1]]);
        context.stroke();
        context.closePath();
    }
    context.setLineDash([]);
}

// UI
function inc(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) + 1;
    eval('change_' + counter_name + '()');
}

function dec(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) - 1;
    eval('change_' + counter_name + '()');
}

function change_weight2d1() {
    weight2d1 = document.getElementById('weight2d1').value;
    draw_canvas2d1();
}

function change_weight2d2() {
    weight2d2 = document.getElementById('weight2d2').value;
    draw_canvas2d2();
}

function change_weight3d() {
    weight3d = document.getElementById('weight3d').value;
    compute_edges_and_z_field();
    draw_canvas3d();
}
    </script>
  </head>
  <body>
    <center>
    <h1>
<Span id="index_swine">SWInE</Span>: Simplicial Weight Interpolation and Extrapolation
    </h1>
    <p>
I've been procrastinating on this for more than ten years. The thing is, this particular algorithm is my brainchild. While working on my thesis, I stole exactly three ideas from other people, made them work together, and gave that compilation a funny name. This counts as authorship, right?
    </p>
    <p>
I had my fun playing with the concept but the conclusion I had to put into my thesis was: “SWInE is rather promising”. In academic language, this means “useless”. Almost everything you can do with SWInE, you can do with splines better. And this brings the dilemma. On one hand, I can share a unique piece of knowledge very few people in the world possess; on the other hand, this piece of knowledge is worthless.
    </p>
    <p>
Finally, I came up with this argument. The three ideas behind the algorithm are prominent. And if an algorithm helps show them in action, then maybe this is what makes the algorithm worthy.
    </p>
    <h2>
Idea 1: <span id="index_inverse_weights">inverse weights</span>
    </h2>
    <p>
Let's say we have two points <i>(x<sub>1</sub>, y<sub>1</sub>)</i> and <i>(x<sub>2</sub>, y<sub>2</sub>)</i>. There is a function <i>F(x)</i> that fits these points. Fits means that
    </p>
    <p class="formula">
F(x<sub>1</sub>) = y<sub>1</sub>
<br>
F(x<sub>2</sub>) = y<sub>2</sub>
    </p>
    <p>
When we determine this function in between points, it is called <b>interpolation</b>. When do that on the left and on the right of the points — <b>extrapolation</b>.
    </p>
    <p>
Using the <b>inverse weights</b> is the way to build the interpolating function everywhere apart from the points themselves.
    </p>
    <table class="formula">
    <tr>
    <td rowspan=2>
    &forall; x, x<sub>i</sub> &lt; x &lt; x<sub>i+1</sub> &nbsp; F(x) = &nbsp;
    </td>
    <td style="border-bottom: 1px solid black">
    y<sub>i</sub> * k(x - x<sub>i</sub>) + y<sub>i+1</sub> * k(x<sub>i+1</sub> - x)
    </td>
    </tr>
    <tr>
    <td>
    k(x - x<sub>i</sub>) + k(x<sub>i+1</sub> - x)
    </td>
    </tr>
    </table>
    <table class="formula">
    <tr>
    <td rowspan=2>
    k(x) = &nbsp;
    </td>
    <td style="border-bottom: 1px solid black">
    1
    </td>
    </tr>
    <tr>
    <td>
    x<sup>n</sup>
    </td>
    </tr>
    </table>
    <p>
Yes, there would be a zero division in <i>x<sub>i</sub></i> so the function is left undefined there. But we can fix that with the magic of limits. The function becomes infinitely close to the points in their respected proximities, so we can make it continuous by defining it in the points explicitly
    </p>
    <p class="formula">
F(x<sub>i</sub>) = y<sub>i</sub>
    </p>
    <p>
Also, the function outside the points can be defined as the first point on the left, and as the last point on the right. This will work as a primitive extrapolation.
    </p>
    <p>
The n-coefficient in the weight function affects the way the function looks. You can experiment with it on the following interactive plot.
    </p>
    <canvas id="canvas2d1" width=640 height=640></canvas>
    <form>
    Do:
    <input type="radio" name="ie" id="i" value="i" onclick="draw_canvas2d1(0, 0, false);"><label for="i">interpolation</label>,
    <input type="radio" name="ie" id="e" value="e" onclick="draw_canvas2d1(0, 0, false);"><label for="e">extrapolation</label>,
    <input type="radio" name="ie" id="ie" value="ie" checked="true" onclick="draw_canvas2d1(0, 0, false);"><label for="ie">both</label>;
    <br>
    <br>
    with the weight coefficient:
    <button type="button" onclick="dec('weight2d1')">-</button>
    <input type="text" style="width: 32pt;" id="weight2d1" value="2" oninput="change_weight2d1();">
    <button type="button" onclick="inc('weight2d1')">+</button>
    </form>
    <p>
When the weight coefficient equals zero, the function becomes discontinuous. Negative coefficients are useless for interpolation. However, fractional coefficients may be useful. They bring more control over the function with no additional changes in the algorithm.
    </p>
    <p>
Mathematically, the inverse weights are simple. But there is no such thing as a limit in floating-point computation, there is no infinitely small proximity. There is no grace, only digits and errors. You have to define the interpolating function explicitly not only in <i>x<sub>i</sub></i> points but in some measurable proximity too.
    </p>
    <p>
Then again, every computation on floating-point numbers is discrete so pragmatically this is just one more “guess an epsilon” problem.
    </p>
    <h2>
Idea 2: <span id="index_basis_functions">basis functions</span>
    </h2>
    <p>
We can now turn points into functions. That's awesome. But with inverse weights, the interpolating function always makes a plateau near the <i>x<sub>i</sub></i> points. What if we want it to have a slope instead?
    </p>
    <p>
The idea of <b>basis functions</b> is: we can interpolate functions instead of points.
    </p>
    <table class="formula">
    <tr>
    <td rowspan=2>
    F(x) = &nbsp;
    </td>
    <td style="border-bottom: 1px solid black">
    f<sub>i</sub>(x) * k(x - x<sub>i</sub>) + f<sub>i+1</sub>(x) * k(x<sub>i+1</sub> - x)
    </td>
    </tr>
    <tr>
    <td>
    k(x - x<sub>i</sub>) + k(x<sub>i+1</sub> - x)
    </td>
    </tr>
    </table>
    <p>
And we can switch values to basis functions for the extrapolation as well.
    </p>
    <p>
Technically, every continuous function <i>f(x)</i> such as <i>f(x<sub>i</sub>) = y<sub>i</sub></i> can be a basis function. Let's try things out with a few selected types of polynomial functions: the constant (which is a 0-polynomial in a way), the linear function, and the quadratic function.
    </p>
    <table class="formula">
    <tr>
    <td style="padding-bottom: 18pt;">
    f<sub>i</sub>(x) = y<sub>i</sub>
    </td>
    </tr>
    <tr>
    <td style="padding-bottom: 18pt;">
    f<sub>i</sub>(x) = ax + b<span style="color: #777">; ax<sub>i</sub> + b = y<sub>i</sub></span>
    </td>
    </tr>
    <tr>
    <td>
    f<sub>i</sub>(x) = ax<sup>2</sup> + bx + c<span style="color: #777">; ax<sub>i</sub><sup>2</sup> + bx<sub>i</sub> + c = y<sub>i</sub></span>
    </td>
    </tr>
    </table>
    <p>
The magic of inverse weights is in their indifference. They can work with any basis functions and it's easy to mix them up in a single formula to get something you want.
    </p>
    <p>
On this interactive plot, you can see how different types of basis functions work together in different configurations.
    </p>
    <canvas id="canvas2d2" width=640 height=640></canvas>
    <form>
    <span style="line-height: 1.42;">
    Please select one of the following configurations:
    <br>
    <input type="radio" name="basis" id="cccc" value="cccc" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="cccc">constant-constant-constant-constant</label>;
    <br>
    <input type="radio" name="basis" id="cllc" value="cllc" checked="true" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="cllc">constant-linear-linear-constant</label>;
    <br>
    <input type="radio" name="basis" id="llll" value="llll" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="llll">linear-linear-linear-linear</label>;
    <br>
    <input type="radio" name="basis" id="cqqc" value="cqqc" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="cqqc">constant-quadratic-quadratic-constant</label>;
    <br>
    <input type="radio" name="basis" id="lqql" value="lqql" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="lqql">linear-quadratic-quadratic-linear</label>;
    <br>
    <input type="radio" name="basis" id="qqqq" value="qqqq" onclick="recalculate_basis2d();draw_canvas2d2(0, 0, false);"><label for="qqqq">quadratic-quadratic-quadratic-quadratic</label>.
    </span>
    <br><br>
    And the weight coefficient:
    <button type="button" onclick="dec('weight2d2')">-</button>
    <input type="text" style="width: 32pt;" id="weight2d2" value="2" oninput="change_weight2d2();">
    <button type="button" onclick="inc('weight2d2')">+</button>
    </form>
    <p>
With inverse weights and basis functions, we have almost too much freedom. We can have our function smooth on some interval, and sharp at one particular point. Or we can make it lay on a plateau near some point, and then fit some curvature in an interval.
    </p>
    <p>
But so far it only concerns single variable functions. If we want to generalize weight interpolation to the n-dimensional case, we have to use an n-dimensional interval generalization.
    </p>
    <h2>
Idea 3: self-referential n-<span id="index_simplex">simplex</span> data structure
    </h2>
    <p>
A point is a 0-simplex. A line segment, a piece of line between two points, is a 1-simplex. A triangle, a region on a plane inside three line segments, is a 2-simplex. A tetrahedron is a 3-simplex. And if you can imagine how tetrahedron becomes a point while traveling through the 4-th dimension, that would be a 4-simplex. I hope you see a pattern here.
    </p>
    <p>
An <b><span id="index_n_simplex">n-simplex</span></b> is the space between n+1 (n-1)-simplices.
    </p>
    <p>
This makes it a <span id="index_self_referential_data_structure">self-referential data structure</span>. If we want to define an interpolating function F<sub>1</sub> on a line, F<sub>2</sub> on a triangle, and F<sub>3</sub> on a tetrahedron, we only have to define F<sub>n</sub> once on an n-simplex.
    </p>
    <p>
With basis functions weight interpolation, you already have your interpolating function defined in the basis points.
    <p>

    <table class="formula">
    <tr>
    <td colspan=2 style="padding-bottom: 18pt;">
        F(<b>x</b>) = F<sub>n</sub>(<b>x</b>)
    </td>
    </tr>
    <tr>
    <td colspan=2 style="padding-bottom: 18pt;">
        <b>x</b> = <b>x<sub>i</sub></b> &rArr; F<sub>n</sub>(<b>x</b>) = f<sub>i</sub>(<b>x</b>)
    </td>
    </tr>
    </table>
    <p>
Consequently, this defines <i>F<sub>0</sub>(<b>x</b>)</i>. For all the other n-simplices, the self-referential formula <i>F<sub>n</sub>(<b>x</b>)</i> looks like this.
    </p>

    <table class="formula">
    <td rowspan=2>
        &forall; <b>x</b>, <b>x</b> &ne; <b>x<sub>i</sub></b> &nbsp; F<sub>n</sub>(<b>x</b>) = &nbsp;
    </td>
    <td style="border-bottom: 1px solid black">
        <table border=0 colspan=0 rowspan=0><tr><td style="font-size: 10pt;">n+1</td><td rowspan=3>k(|<b>x<sub>j</sub></b> - <b>x</b>|) F<sub>n-1</sub>(<b>x<sub>j</sub></b>)</font></td></tr><tr><td style="font-size: 28pt;">&Sigma;</td></tr><tr><td style="font-size: 10pt;">j=1</td></tr></table>
    </td>
    </tr>
    <tr>
    <td>
        <table border=0 colspan=0 rowspan=0><tr><td style="font-size: 10pt;">n+1</td><td rowspan=3>k(|<b>x<sub>j</sub></b> - <b>x</b>|) </font></td></tr><tr><td style="font-size: 28pt;">&Sigma;</td></tr><tr><td style="font-size: 10pt;">j=1</td></tr></table>
    </td>
    </tr>
    </table>
    <p>
    </p>
    <p>
The formula looks almost like the one with the basis functions except now all the variables in bold are points: <i><b>x</b></i>, <i><b>x<sub>i</sub></b></i>, <i><b>x<sub>j</sub></b></i>.
    </p>
    <p>
Speaking of which, since we want to interpolate basis functions in an n-simplex, we should compute our basis functions out of distances to (n-1)-simplices. The <i><b>x</b><sub>j</sub></i> is the projection of <i><b>x</b></i> onto the j-th (n-1)-simplex. The <i>|<b>x<sub>j</sub></b> - <b>x</b>|</i> is then the distance from a point to its projection.
    </p>
    <p>
Weight functions, basis functions, and now the (n-1)-simplex projections. This is enough to define an interpolation function on a triangle or a tetrahedron. But what about more complex shapes?
    </p>
    <p>
When we have a bunch of simplices that touch each other but never overlap, this is a simplicial complex. If you're ok with some representation error, you can cover any shape with a simplicial complex.
    </p>
    <p>
And what we can't cover with a complex, we can cover with spatial extrapolation.
    </p>
    <p>
With weight and basis functions, you can mix your interpolating function in n-simplices with interpolating functions on (n-1)-simplices. Now if a point isn't in an n-simplex but has a projection on an (n-1)-simplex, then computing the weights on this projection and applying them to the basis functions will make an extrapolation that will seamlessly merge with the interpolation.
    </p>
    <p>
The same goes to (n-2)-simplices, (n-3) or (n-k) ones. Let's devise an algorithm by dividing interpolation and extrapolation into 3 cases.
    </p>
    <ol>
<li>If a point is in a triangle, then the <i>F<sub>2</sub></i> applies; </li>
<li>if a point has a projection on the complex border line segments, then the <i>F<sub>1</sub></i> works instead; </li>
<li>if a point doesn't have the projection, then the basis function of the nearest point <i>f<sub>i</sub></i> is the extrapolation function.</li>
    </ol>
    <p>
Well, this particular algorithm doesn't work with concave shapes. Technically, we can still turn any concave simplicial complex into a convex one by adding more simplices. That's just more coding.
    </p>
    <p>
Here is an interactive plot. It has 6 triangles combined in a complex. Every point carries its own shade of gray, and the rest of the picture is the result of simplicial weight interpolation and extrapolation. The points are moveable, but the relations between triangles are hard-coded.
    </p>

    <canvas id="canvas3d" width=640 height=640></canvas>
    <form>
Do:
    <input type="radio" name="ie3d" id="i3d" onclick="compute_edges_and_z_field();draw_canvas3d(0, 0, false);"><label for="i3d">interpolation</label>,
    <input type="radio" name="ie3d" id="e3d" onclick="compute_edges_and_z_field();draw_canvas3d(0, 0, false);"><label for="e3d">extrapolation</label>,
    <input type="radio" name="ie3d" id="ie3d" checked="true" onclick="compute_edges_and_z_field();draw_canvas3d(0, 0, false);"><label for="ie3d">both</label>.
    <br>
    <br>
With basis function:
    <input type="radio" name="basis3d" id="basis3d_constant" value="basis3d_constant" onclick="change_weight3d();"><label for="basis3d_constant">constant</label>;
    <input type="radio" name="basis3d" checked="true" id="basis3d_linear" value="basis3d_linear" onclick="change_weight3d();"><label for="basis3d_linear">linear</label>.
    <br>
    <br>
And the weight coefficient:
    <button type="button" onclick="dec('weight3d')">-</button>
    <input type="text" style="width: 32pt;" id="weight3d" value="2" oninput="change_weight3d();">
    <button type="button" onclick="inc('weight3d')">+</button>
    </form>
    <p>
And that's how we got from a pair of points to Simplicial Weight Interpolation and Extrapolation. Just as promised in the title.
    </p>
    <h2>
P. S.
    </h2>
    <p>
The code for all the plots on GitHub:
    </p>
    <ul>
    <li><a href="https://github.com/akalenuk/wordsandbuttons/blob/bc623519665c63ca324bd54ef468fbe95b22c32f/pages/swine_simplicial_weight_interpolation_and_extrapolation.html#L165">inverse weights interpolation</a>;</li>
    <li><a href="https://github.com/akalenuk/wordsandbuttons/blob/bc623519665c63ca324bd54ef468fbe95b22c32f/pages/swine_simplicial_weight_interpolation_and_extrapolation.html#L183">basis functions interpolation</a>;</li>
    <li><a href="https://github.com/akalenuk/wordsandbuttons/blob/bc623519665c63ca324bd54ef468fbe95b22c32f/pages/swine_simplicial_weight_interpolation_and_extrapolation.html#L498">simplicial interpolation and extrapolation</a>.</li>
    </ul>
    </div>
    <script language="JavaScript">
    init_canvas2d1();
    init_canvas2d2();
    init_canvas3d();
    </script>


    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
	<tr>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
		<a href="index.html"><img src="favicon.svg"></a> 
	</td>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
		&nbsp;&larr; there's more.
	</td>
	<td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
		+
		<a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
		<a href="https://wordsandbuttons.online/rss"><span style="letter-spacing: 1pt;">RSS</span></a>
	</td>
	</tr>
	</table>
    </center>
  </body>
</html>
