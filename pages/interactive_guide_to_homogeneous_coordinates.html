<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Interactive guide to homogeneous coordinates</title>
    <meta name="description" content="This interactive guide shows how homogeneous coordinates actually make geometry simpler and not more complicated. It explains the extra coordinate, the matrices, the generalized transformations. Most of what you need to know about projective geometry as a practicing programmer is here.">
    <meta name="keywords" content="mathematics, algorithms, tutorials">
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico" />
    <style>
body{
    margin: 0 0 0 0;
}

a{
    text-decoration: none;
}

h1 {
    padding-top: 36pt;
    font-size: 24pt;
    width: 600pt;
    text-align: left;
}

h2 {
    padding-top: 20pt;
    font-size: 20pt;
    width: 555pt;
    text-align: left;
}

p {
    line-height: 1.42;
    font-size: 16pt;
    width: 505pt;
    text-align: left;
}

.formula {
    font-family: sans-serif;
    font-size: 15pt;
    font-style: italic;
    text-align: center;
    padding-top: 6pt;
    padding-bottom: 6pt;
}

table.footer {
    padding: 64pt 0pt 32pt 0pt;
    background-color: transparent;
    width: 505pt;
}

td.footer {
    font-family: sans-serif;
    font-size: 16pt;
    font-style: normal;
    padding: 0;
    margin: 0;
    border: 0;
}

pre {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: left;
    width: 505pt;
}

table {
    border-width: 0pt;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    font-family: monospace;
    text-align: center;
}

table td {
    padding: 0pt 4pt 0pt 4pt;
    margin: 0 0 0 0;
    border-width: 0pt;
}

.brackets {
    font-size:48pt;
    padding-bottom:8pt;
    font-family: sans-serif;
    font-weight: 100;
    font-style: normal;
}

form {
    margin: 0 0 0 0;
    padding-top: 12pt;
    padding-left: 12pt;
    padding-right: 12pt;
    padding-bottom: 12pt;
    font-size: 16pt;
    text-align: center;
    font-family: sans-serif;
    width: 505pt;
    background-color: #eeee99;
    color: #000;
}

input[type="text"] {
    width: 100pt;
    height: 22pt;
    margin: 8pt 8pt 8pt 8pt;
    padding-left: 3pt;
    font-size: 16pt;
}

.incdec{
    width: 32pt;
    height: 26pt;
    margin: 0 0 0 0;
    font-size: 16pt;
    text-align: center;
}

button {
    width: 150pt;
    height: 26pt;
    margin-left:8pt;
    margin-right:8pt;
    font-size: 16pt;
}

input[type="radio"]{
    margin: 4pt 4pt 4pt 4pt;
}
    </style>
    <script language="JavaScript">
var w = 640;
var h = 640;
var d = 128.0;

function client_to_x(client_x){
    return (client_x - w / 2.0) / d;
}

function client_to_y(client_y){
    return (h / 2.0 - client_y) / d;
}

function x_to_client(x){
    return x * d + w / 2.0;
}

function y_to_client(y){
    return h / 2.0 - y * d;
}

var point_x = 1.5;
var point_y = 2;

var pick_a_point = null;
var slide_a_w = null;
var translation = null;

function draw_arrow(context, x1, y1, x2, y2, color) {
    const d = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    context.moveTo(x2 - (y2 - y1) * 4.5 / d - (x2 - x1) * 16.5 / d, y2 - (y2 - y1) * 16.5 / d + (x2 - x1) * 4.5 / d);
    context.lineTo(x2, y2);
    context.moveTo(x2 + (y2 - y1) * 4.5 / d - (x2 - x1) * 16.5 / d, y2 - (y2 - y1) * 16.5 / d - (x2 - x1) * 4.5 / d);
    context.lineTo(x2, y2);
    context.strokeStyle = color;
    context.stroke();
    context.closePath();
}

function draw_grid_on(context){
    // grid
    context.beginPath();
    context.moveTo(0,           h / 2.0);
    context.lineTo(w,           h / 2.0);
    context.lineTo(w-12,        h / 2.0 - 5);
    context.moveTo(w,           h / 2.0);
    context.lineTo(w-12,        h / 2.0 + 5);
    context.moveTo(w / 2.0,     h);
    context.lineTo(w / 2.0,     0);
    context.lineTo(w / 2.0 - 5, 12);
    context.moveTo(w / 2.0,     0);
    context.lineTo(w / 2.0 + 5, 12);
    context.fillStyle="#000000";
    for(var i = -3; i <= 3; i++){
        context.moveTo(     w / 2.0 + i*d,      h / 2.0);
        context.lineTo(     w / 2.0 + i*d,      h / 2.0 - 5);
        context.fillText(i, w / 2.0 + i*d + 4,  h / 2.0 + 16);
        context.moveTo(     w / 2.0,            h / 2.0 - i*d);
        context.lineTo(     w / 2.0 + 5,        h / 2.0 - i*d);
        context.fillText(i, w / 2.0 + 5,        h / 2.0 - i*d + 16);
    }
    context.strokeStyle="#000000";
    context.stroke();
    context.closePath();
}

function write_the_point_value(){
    document.getElementById("to_fill_with_numbers").innerHTML =
    "The point (" + point_x + ", " + point_y + ") is the same as " +
    "(" + point_x + ", " + point_y + ", 1). <br>" +
    "Or (" + point_x*2 + ", " + point_y*2 + ", 2).<br>" +
    "Or (" + point_x*0.5 + ", " + point_y*0.5 + ", 0.5). <br>" +
    "Or even (" + point_x*1000 + ", " + point_y*1000 + ", 1000). <br>";
}

function init_w(){
    document.getElementById("w").addEventListener('submit', function(e) {
        transform();
        e.preventDefault();
    }, false);
}

function init_pick_a_point(){
    pick_a_point = document.getElementById("pick_a_point");
    var canvas_rect = pick_a_point.getBoundingClientRect();
    client_x = canvas_rect.left + point_x * 64 + 256;
    client_y = canvas_rect.top + 256 - point_y * 64;
    pick_a_point_draw(0, 0, false);

    pick_a_point.addEventListener('mousemove', function(e){
        var canvas_rect = pick_a_point.getBoundingClientRect();
        if(e.buttons == 1){ // drag
            point_x = Math.round(client_to_x(e.clientX - canvas_rect.left)*10)/10;
            point_y = Math.round(client_to_y(e.clientY - canvas_rect.top)*10)/10;
            pick_a_point_draw(0, 0, false);
        }else{  // move
            pick_a_point_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        }
    }, false);

    pick_a_point.addEventListener('mousedown', function(e){
        var canvas_rect = pick_a_point.getBoundingClientRect();
        point_x = Math.round(client_to_x(e.clientX - canvas_rect.left)*10)/10;
        point_y = Math.round(client_to_y(e.clientY - canvas_rect.top)*10)/10;
        pick_a_point_draw(0, 0, false);
        write_the_point_value();
        transform();
        slide_a_w_draw(e.clientX);
    }, false);
}

function pick_a_point_draw(client_x, client_y, do_guides){
    var context = pick_a_point.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // selection
    context.beginPath();
    context.lineWidth = 1;
    context.setLineDash([4, 4]);
    context.moveTo(x_to_client(point_x), h / 2.0);
    context.lineTo(x_to_client(point_x), y_to_client(point_y));
    context.moveTo(w / 2.0, y_to_client(point_y));
    context.lineTo(x_to_client(point_x), y_to_client(point_y));
    context.strokeStyle="#8c2c3e";
    context.stroke();
    context.fillStyle="#8c2c3e";
    context.fillText(point_x.toFixed(1) + ", " + point_y.toFixed(1), x_to_client(point_x) + 4, y_to_client(point_y) + 16);
    context.setLineDash([]);
    context.closePath();

    if(do_guides){
        context.lineWidth = 2;
        draw_arrow(context, x_to_client(point_x), y_to_client(point_y), client_x, client_y, "#d64562");
        context.lineWidth = 1;
    }
    
    // point
    context.arc(x_to_client(point_x), y_to_client(point_y), 3, 0, 2*Math.PI);
    context.fill();
    
    // grid
    draw_grid_on(context);
}

function transform(){
    var w = Number(document.getElementById("proposed_w").value);
    if(w == NaN)
        w = 1;
    if(w == 0){
        document.getElementById("after_the_w_proposed").style.display = "block";
        document.getElementById("transformed").innerHTML = "<br>No transformation available!"
        document.getElementById("to_hide_on_transform").style.display = "none";
    }else{
        document.getElementById("transformed").innerHTML =
            "<br>(" + point_x + ", " + point_y + ") = " +
            "(" + parseFloat((point_x * w).toFixed(3)) + ", " + parseFloat((point_y * w).toFixed(3)) + ", " + parseFloat((w).toFixed(3)) + ")";
    }
}

var slide_w = 1.0;

function init_slide_a_w(){
    var slide_a_w = document.getElementById("slide_a_w");
    var canvas_rect = slide_a_w.getBoundingClientRect();
    slide_a_w_draw(0, 0, false);

    slide_a_w.addEventListener('mousemove', function(e){
        var canvas_rect = slide_a_w.getBoundingClientRect();
        slide_a_w_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        if(e.buttons == 1){
            var mouse_x = client_to_x(e.clientX - canvas_rect.left);
            var mouse_y = client_to_y(e.clientY - canvas_rect.top);
            var t = (point_x * mouse_x + point_y * mouse_y) / (point_x * point_x + point_y * point_y);
            slide_w = 1.0 / t;
            slide_a_w_draw(0, 0, false);
        }
    }, false);

    slide_a_w.addEventListener('mousedown', function(e){
        var canvas_rect = slide_a_w.getBoundingClientRect();
        slide_w = point_x / client_to_x(e.clientX - canvas_rect.left);
        slide_a_w_draw(0, 0, false);
    }, false);

    slide_a_w.addEventListener('mouseleave', function(e){
        var canvas_rect = slide_a_w.getBoundingClientRect();
        slide_a_w_draw(0, 0, false);
    }, false);
}

function slide_a_w_draw(client_x, client_y, is_moving){
    var slide_a_w = document.getElementById("slide_a_w");
    var context = slide_a_w.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // selection
    var w_;
    if(is_moving){
        var mouse_x = client_to_x(client_x);
        var mouse_y = client_to_y(client_y);
        var t = (point_x * mouse_x + point_y * mouse_y) / (point_x * point_x + point_y * point_y);
        w_ = 1.0 / t;
    }else{
        w_ = slide_w;
    }

    context.beginPath();
    context.moveTo(x_to_client(point_x * 100), y_to_client(point_y * 100));
    context.lineTo(x_to_client(point_x * -100), y_to_client(point_y * -100));
    context.strokeStyle="#8c2c3e";
    context.stroke();
    context.closePath();

    if(is_moving){
        context.lineWidth = 2;
        draw_arrow(context, x_to_client(point_x / slide_w), y_to_client(point_y / slide_w), x_to_client(point_x / w_), y_to_client(point_y / w_), "#d64562");
        context.lineWidth = 1;
    }

    // point
    context.fillStyle="#8c2c3e";
    context.arc(x_to_client(point_x / slide_w), y_to_client(point_y / slide_w), 3, 0, 2*Math.PI);
    context.fill();

    // coordinates
    context.fillText(point_x.toFixed(1) + ", " + point_y.toFixed(1) + ", " + slide_w.toFixed(3), x_to_client(point_x / slide_w) + 4, y_to_client(point_y / slide_w) + 16);

    // grid
    draw_grid_on(context);
}


function draw_original_cube_on(context){
    // original cube
    context.beginPath();
    context.moveTo(x_to_client(1), y_to_client(1));
    context.lineTo(x_to_client(1 + 1), y_to_client(1));
    context.lineTo(x_to_client(1 + 1), y_to_client(1 + 1));
    context.lineTo(x_to_client(1), y_to_client(1 + 1));
    context.lineTo(x_to_client(1), y_to_client(1));
    context.strokeStyle="#999999";
    context.stroke();
    context.closePath();
}

var dx = 0.5;
var dy = 0.3;

function init_translation(){
    translation = document.getElementById("translation");
    translation_draw(0, 0, false);

    translation.addEventListener('mousedown', function(e){
        var canvas_rect = translation.getBoundingClientRect();
        dx = client_to_x(e.clientX - canvas_rect.left);
        dy = client_to_y(e.clientY - canvas_rect.top);
        translation_draw(0, 0, false);
    }, false);

    translation.addEventListener('mousemove', function(e){
        var canvas_rect = translation.getBoundingClientRect();
        if(e.buttons == 1){
            dx = client_to_x(e.clientX - canvas_rect.left);
            dy = client_to_y(e.clientY - canvas_rect.top);
            translation_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        }else{
            translation_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
        }
    }, false);

    translation.addEventListener('mouseleave', function(e){
        var canvas_rect = translation.getBoundingClientRect();
        translation_draw(0, 0, false);
    }, false);
}

function translation_draw(client_x, client_y, do_new){
    if(do_new){
        var x = client_to_x(client_x);
        var y = client_to_y(client_y);
    }else{
        var x = dx;
        var y = dy;
    }

    var context = translation.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // original cube
    draw_original_cube_on(context);

    context.lineWidth = 2;
    if(do_new){
        // the connection
        context.beginPath();
        context.setLineDash([4, 4]);
        context.moveTo(x_to_client(1), y_to_client(1));
        context.lineTo(x_to_client(x), y_to_client(y));
        context.moveTo(x_to_client(1 + 1), y_to_client(1));
        context.lineTo(x_to_client(x + 1), y_to_client(y));
        context.moveTo(x_to_client(1 + 1), y_to_client(1 + 1));
        context.lineTo(x_to_client(x + 1), y_to_client(y + 1));
        context.moveTo(x_to_client(1), y_to_client(1 + 1));
        context.lineTo(x_to_client(x), y_to_client(y + 1));
        context.strokeStyle="#d64562";
        context.stroke();
        context.setLineDash([]);
        context.closePath();
    }
    // dx-dy cube
    context.beginPath();
    context.moveTo(x_to_client(dx), y_to_client(dy));
    context.lineTo(x_to_client(dx + 1), y_to_client(dy));
    context.lineTo(x_to_client(dx + 1), y_to_client(dy + 1));
    context.lineTo(x_to_client(dx), y_to_client(dy + 1));
    context.lineTo(x_to_client(dx), y_to_client(dy));
    context.strokeStyle="#8c2c3e";
    context.stroke();
    context.closePath();
    context.lineWidth = 1;

    // translation
    context.beginPath();
    context.moveTo(x_to_client(x), y_to_client(y));
    context.lineTo(x_to_client(x + 1), y_to_client(y));
    context.lineTo(x_to_client(x + 1), y_to_client(y + 1));
    context.lineTo(x_to_client(x), y_to_client(y + 1));
    context.lineTo(x_to_client(x), y_to_client(y));
    context.strokeStyle="#d64562";
    context.stroke();
    context.closePath();
    context.fillStyle="#8c2c3e";
    context.fillText("x' = x + a, where a = " + (x-1).toFixed(1), 32, 560);
    context.fillText("y' = y + b, where b = " + (y-1).toFixed(1), 32, 580);

    // grid
    draw_grid_on(context);
}

function rotated_x(a, x, y){
    return Math.sin(a) * x - Math.cos(a) * y;
}

function rotated_y(a, x, y){
    return Math.cos(a) * x + Math.sin(a) * y;
}

var rotation_a = Math.PI / 2 + 0.2;

function in_2_pi(x) {
    while(x < 0.0)
        x += 2*Math.PI;
    while(x >= 2*Math.PI)
        x -= 2*Math.PI;
    return x;
}

function rotation_for(x, y) {
    if (x > 0)
        return in_2_pi(Math.PI * 3 / 4 - Math.atan(y / x));
    else
        return in_2_pi(Math.PI * 7 / 4 - Math.atan(y / x));
}

function init_rotation(){
    rotation_draw(rotation_a, false);

    var rotation = document.getElementById("rotation");

    rotation.addEventListener('mousemove', function(e){
        var canvas_rect = rotation.getBoundingClientRect();
        var client_x = e.clientX - canvas_rect.left;
        var client_y = e.clientY - canvas_rect.top;
        var a = rotation_for(client_to_x(client_x), client_to_y(client_y));
        if(e.buttons == 1)
            rotation_a = a;
        rotation_draw(a, true);
    }, false);

    rotation.addEventListener('mousedown', function(e){
        var canvas_rect = rotation.getBoundingClientRect();
        var client_x = e.clientX - canvas_rect.left;
        var client_y = e.clientY - canvas_rect.top;
        rotation_a = rotation_for(client_to_x(client_x), client_to_y(client_y));
        rotation_draw(rotation_a, false);
    }, false);

    rotation.addEventListener('mouseleave', function(e){
        var canvas_rect = translation.getBoundingClientRect();
        rotation_draw(rotation_a, false);
    }, false);
}

function rotation_draw(a, do_new){
    var context = rotation.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    var xs = [1., 2., 2., 1.];
    var ys = [1., 1., 2., 2.];
    var new_xs = [0, 0, 0, 0];
    var new_ys = [0, 0, 0, 0];
    for(var i = 0; i < 4; i++){
        new_xs[i] = rotated_x(a, xs[i], ys[i]);
        new_ys[i] = rotated_y(a, xs[i], ys[i]);
    }

    var new_saved_xs = [0, 0, 0, 0];
    var new_saved_ys = [0, 0, 0, 0];
    for(var i = 0; i < 4; i++){
        new_saved_xs[i] = rotated_x(rotation_a, xs[i], ys[i]);
        new_saved_ys[i] = rotated_y(rotation_a, xs[i], ys[i]);
    }

    // original cube
    draw_original_cube_on(context);
    
    context.lineWidth = 2;
    if(do_new){
        // the connection
        for(var i = 0; i < 4; i++){
            context.beginPath();
            context.setLineDash([4, 4]);
            var r = x_to_client(Math.sqrt(xs[i]*xs[i] + ys[i]*ys[i])) - x_to_client(0);
            var a1 = in_2_pi(rotation_for(xs[i], ys[i]) - Math.PI * 3 / 4);
            var a2 = in_2_pi(rotation_for(new_xs[i], new_ys[i]) - Math.PI * 3 / 4);
            if(a1 < a2)
                context.arc(x_to_client(0), y_to_client(0), r, a1, a2);
            else
                context.arc(x_to_client(0), y_to_client(0), r, a2, a1);
            context.strokeStyle="#d64562";
            context.stroke();
            context.setLineDash([]);
            context.closePath();
        }
    }

    // draw a saved cube
    context.beginPath();
    context.moveTo(x_to_client(new_saved_xs[3]), y_to_client(new_saved_ys[3]));
    for(var i = 0; i < 4; i++){
        context.lineTo(x_to_client(new_saved_xs[i]), y_to_client(new_saved_ys[i]));
    }
    context.strokeStyle="#8c2c3e";
    context.stroke();
    context.closePath();
    context.lineWidth = 1;
    
    // rotation
    context.beginPath();
    context.moveTo(x_to_client(new_xs[3]), y_to_client(new_ys[3]));
    for(var i = 0; i < 4; i++){
        context.lineTo(x_to_client(new_xs[i]), y_to_client(new_ys[i]));
    }
    context.strokeStyle="#d64562";
    context.stroke();
    context.closePath();
    context.fillStyle="#8c2c3e";
    context.fillText("x' = sin(a) * x + cos(a) * y", 32, 540);
    context.fillText("y' = cos(a) * x - sin(a) * y", 32, 560);
    context.fillText("where a = " + (a - Math.PI/2).toFixed(2), 32, 580);

    // grid
    draw_grid_on(context);
}

var scale_x = 0.8;
var scale_y = 1.2;

function init_scale(){
    scale = document.getElementById("scale");
    scale_draw(scale_x, scale_y, false);

    scale.addEventListener('mousemove', function(e){
        var canvas_rect = scale.getBoundingClientRect();
        var new_scale_x = client_to_x(e.clientX - canvas_rect.left);
        var new_scale_y = client_to_y(e.clientY - canvas_rect.top);
        if(e.buttons == 1){
            scale_x = new_scale_x;
            scale_y = new_scale_y;
            scale_draw(scale_x, scale_y, true);
        }else{
            scale_draw(new_scale_x, new_scale_y, true);
        }
    }, false);

    scale.addEventListener('mousedown', function(e){
        var canvas_rect = scale.getBoundingClientRect();
        scale_x = client_to_x(e.clientX - canvas_rect.left);
        scale_y = client_to_y(e.clientY - canvas_rect.top);
        scale_draw(scale_x, scale_y, false);
    }, false);

    scale.addEventListener('mouseleave', function(e){
        scale_draw(scale_x, scale_y, false);
    }, false);
}

function scale_draw(a, b, do_new){
    var context = scale.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    var xs = [1., 2., 2., 1.];
    var ys = [1., 1., 2., 2.];
    var new_xs = [0, 0, 0, 0];
    var new_ys = [0, 0, 0, 0];
    for(var i = 0; i < 4; i++){
        new_xs[i] = a * xs[i];
        new_ys[i] = b * ys[i];
    }

    var new_saved_xs = [0, 0, 0, 0];
    var new_saved_ys = [0, 0, 0, 0];
    for(var i = 0; i < 4; i++){
        new_saved_xs[i] = scale_x * xs[i];
        new_saved_ys[i] = scale_y * ys[i];
    }

    // original cube
    draw_original_cube_on(context);
    
    context.lineWidth = 2;
    if(do_new){
        // the connection
        context.beginPath();
        context.setLineDash([4, 4]);
        for(var i = 0; i < 4; i++){
            context.moveTo(x_to_client(xs[i]), y_to_client(ys[i]));
            context.lineTo(x_to_client(new_xs[i]), y_to_client(new_ys[i]));
        }
        context.strokeStyle="#8c2c3e";
        context.stroke();
        context.setLineDash([]);
        context.closePath();
    }

    // draw a saved cube
    context.beginPath();
    context.moveTo(x_to_client(new_saved_xs[3]), y_to_client(new_saved_ys[3]));
    for(var i = 0; i < 4; i++){
        context.lineTo(x_to_client(new_saved_xs[i]), y_to_client(new_saved_ys[i]));
    }
    context.strokeStyle="#8c2c3e";
    context.stroke();
    context.closePath();
    context.lineWidth = 1;

    // scale
    context.beginPath();
    context.moveTo(x_to_client(new_xs[3]), y_to_client(new_ys[3]));
    for(var i = 0; i < 4; i++){
        context.lineTo(x_to_client(new_xs[i]), y_to_client(new_ys[i]));
    }
    context.strokeStyle="#d64562";
    context.stroke();
    context.closePath();
    context.fillStyle="#8c2c3e";
    context.fillText("x' = a * x, where a = " + a.toFixed(2), 32, 560);
    context.fillText("y' = b * y, where b = " + b.toFixed(2), 32, 580);

    // grid
    draw_grid_on(context);
}

function init_affine(){
    affine = document.getElementById("affine");
    affine_draw(0, 0, false);

    affine.addEventListener('mousemove', function(e){
        if(e.buttons == 1){
            var canvas_rect = affine.getBoundingClientRect();
            var client_x = e.clientX - canvas_rect.left;
            var client_y = e.clientY - canvas_rect.top;
            affine_xs[affine_i] = client_to_x(client_x);
            affine_ys[affine_i] = client_to_y(client_y);
            affine_draw(0, 0, false);
        }else{
            affine_draw(e.clientX, e.clientY, true);
        }
    }, false);

    affine.addEventListener('mouseup', function(e){
        var canvas_rect = affine.getBoundingClientRect();
        var client_x = e.clientX - canvas_rect.left;
        var client_y = e.clientY - canvas_rect.top;
        var x = client_to_x(client_x);
        var y = client_to_y(client_y);
        affine_xs[affine_i] = x;
        affine_ys[affine_i] = y;
        affine_xs[3] = affine_xs[0] + affine_xs[2] - affine_xs[1];
        affine_ys[3] = affine_ys[0] + affine_ys[2] - affine_ys[1];
        affine_i = (affine_i + 1) % 3;
        affine_draw(e.clientX, e.clientY, true);
    }, false);

    affine.addEventListener('mouseleave', function(e){
        affine_draw(0, 0, false);
    }, false);
}

var affine_xs = [0.75, 2.0, 2.25, 1.0];
var affine_ys = [0.75, 1.0, 2.25, 2.0];
var affine_i = 0;

function affine_draw(client_x, client_y, do_new){
    // coordiantes correction
    var canvas_rect = affine.getBoundingClientRect();
    client_x -= canvas_rect.left;
    client_y -= canvas_rect.top;
    var x = client_to_x(client_x);
    var y = client_to_y(client_y);

    var context = affine.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // original cube
    draw_original_cube_on(context);

    // affine
    context.lineWidth = 2;
    context.beginPath();
    context.moveTo(x_to_client(affine_xs[3]), y_to_client(affine_ys[3]));
    for(var i = 0; i < 4; i++){
        context.lineTo(x_to_client(affine_xs[i]), y_to_client(affine_ys[i]));
    }
    context.strokeStyle="#8c2c3e";
    context.stroke();
    context.closePath();
    context.lineWidth = 1;

    if(do_new){
        // link
        context.lineWidth = 2;
        draw_arrow(context, x_to_client(affine_xs[affine_i]), y_to_client(affine_ys[affine_i]), x_to_client(x), y_to_client(y), "#d64562");
        context.lineWidth = 1;
    }

    // x
    context.beginPath();
    context.fillStyle="#8c2c3e";
    context.arc(x_to_client(affine_xs[affine_i]), y_to_client(affine_ys[affine_i]), 3, 0, 2*Math.PI);
    context.fill();
    context.closePath();
    
    // grid
    draw_grid_on(context);
}

function init_projective(){
    projective = document.getElementById("projective");
    projective_draw(0, 0, false);

    projective.addEventListener('mousemove', function(e){
        if(e.buttons == 1){
            var canvas_rect = projective.getBoundingClientRect();
            var client_x = e.clientX - canvas_rect.left;
            var client_y = e.clientY - canvas_rect.top;
            projective_xs[projective_i] = client_to_x(client_x);
            projective_ys[projective_i] = client_to_y(client_y);
            projective_draw(0, 0, false);
        }else{
            projective_draw(e.clientX, e.clientY, true);
        }
    }, false);

    projective.addEventListener('mouseup', function(e){
        var canvas_rect = projective.getBoundingClientRect();
        client_x = e.clientX - canvas_rect.left;
        client_y = e.clientY - canvas_rect.top;
        var x = client_to_x(client_x);
        var y = client_to_y(client_y);
        projective_xs[projective_i] = x;
        projective_ys[projective_i] = y;
        projective_i = (projective_i + 1) % 4;
        projective_draw(e.clientX, e.clientY, true);
    }, false);

    projective.addEventListener('mouseleave', function(e){
        projective_draw(0, 0, false);
    }, false);
}

var projective_xs = [0.5, 2.0, 1.5, 0.5];
var projective_ys = [0.5, 0.5, 2.0, 1.0];
var projective_i = 0;

function projective_draw(client_x, client_y, do_new){
    // coordiantes correction
    var canvas_rect = projective.getBoundingClientRect();
    client_x -= canvas_rect.left;
    client_y -= canvas_rect.top;
       var x = client_to_x(client_x);
       var y = client_to_y(client_y);

    var context = projective.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // original cube
    draw_original_cube_on(context);

    // projective
    context.lineWidth = 2;
    context.beginPath();
    context.moveTo(x_to_client(projective_xs[3]), y_to_client(projective_ys[3]));
    for(var i = 0; i < 4; i++){
        context.lineTo(x_to_client(projective_xs[i]), y_to_client(projective_ys[i]));
    }
    context.strokeStyle="#8c2c3e";
    context.stroke();
    context.closePath();
    context.lineWidth = 1;

    if(do_new){
        // link
        context.lineWidth = 2;
        draw_arrow(context, x_to_client(projective_xs[projective_i]), y_to_client(projective_ys[projective_i]), x_to_client(x), y_to_client(y), "#d64562");
        context.lineWidth = 1;
    }

    // x
    context.beginPath();
    context.fillStyle="#8c2c3e";
    context.arc(x_to_client(projective_xs[projective_i]), y_to_client(projective_ys[projective_i]), 3, 0, 2*Math.PI);
    context.fill();
    context.closePath();

    // grid
    draw_grid_on(context);
}

var composable_reference_x = 0.0;
var composable_reference_y = 0.0;

function recalculate_composable(client_x, client_y){
    const x = client_to_x(client_x);
    const y = client_to_y(client_y);

    // new cube
    var new_xs = [1., 2., 2., 1.];
    var new_ys = [1., 1., 2., 2.];
    if(document.getElementById("radio_p").checked){
        for(var i = 0; i < 4; i++){
            new_xs[i] = composable_xs[i];
            new_ys[i] = composable_ys[i];
        }
        new_xs[composable_i] = x;
        new_ys[composable_i] = y;
    }else if(document.getElementById("radio_t").checked){
        for(var i = 0; i < 4; i++){
            new_xs[i] = composable_xs[i] + x;
            new_ys[i] = composable_ys[i] + y;
        }
    }else if(document.getElementById("radio_r").checked){
        for(var i = 0; i < 4; i++){
            new_xs[i] = rotated_x(rotation_for(x, y), composable_xs[i], composable_ys[i]);
            new_ys[i] = rotated_y(rotation_for(x, y), composable_xs[i], composable_ys[i]);
        }
    }else if(document.getElementById("radio_s").checked){
        for(var i = 0; i < 4; i++){
            new_xs[i] = composable_xs[i] * x;
            new_ys[i] = composable_ys[i] * y;
        }
    }
    for(var i = 0; i < 4; i++){
        composable_xs[i] = new_xs[i];
        composable_ys[i] = new_ys[i];
    }

    // calculate a matrix
    x0 = new_xs[0];     y0 = new_ys[0];
    x1 = new_xs[1];     y1 = new_ys[1];
    x2 = new_xs[2];     y2 = new_ys[2];
    x3 = new_xs[3];     y3 = new_ys[3];
    var A = (-x0*x2*y1 + x0*x2*y3 + x0*x3*y1 - x0*x3*y2 + x1*x2*y0 - x1*x2*y3 - x1*x3*y0 + x1*x3*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
    var D = (x0*x1*y2 - x0*x1*y3 - x0*x2*y1 + x0*x2*y3 + x1*x3*y0 - x1*x3*y2 - x2*x3*y0 + x2*x3*y1)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
    var a = (-2*x0*x1*y2 + 2*x0*x1*y3 + 3*x0*x2*y1 - 3*x0*x2*y3 - 2*x0*x3*y1 + 2*x0*x3*y2 - x1*x2*y0 + x1*x2*y3 + x2*x3*y0 - x2*x3*y1)/
        (x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
    var B = (-x0*y1*y2 + x0*y1*y3 + x1*y0*y2 - x1*y0*y3 + x2*y0*y3 - x2*y1*y3 - x3*y0*y2 + x3*y1*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
    var E = (-x0*y1*y3 + x0*y2*y3 + x1*y0*y2 - x1*y2*y3 - x2*y0*y1 + x2*y1*y3 + x3*y0*y1 - x3*y0*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
    var b = (x0*y1*y2 - x0*y2*y3 - 3*x1*y0*y2 + 2*x1*y0*y3 + x1*y2*y3 + 2*x2*y0*y1 - 2*x2*y0*y3 - 2*x3*y0*y1 + 3*x3*y0*y2 - x3*y1*y2)/
        (x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
    var C = (-x0*y2 + x0*y3 + x1*y2 - x1*y3 + x2*y0 - x2*y1 - x3*y0 + x3*y1)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
    var F = (-x0*y1 + x0*y2 + x1*y0 - x1*y3 - x2*y0 + x2*y3 + x3*y1 - x3*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
    var c = 1.;
    document.getElementById("matrix_col1").innerHTML = parseFloat(A.toFixed(3)) + "<br>" + parseFloat(B.toFixed(3)) + "<br>" + parseFloat(C.toFixed(3));
    document.getElementById("matrix_col2").innerHTML = parseFloat(D.toFixed(3)) + "<br>" + parseFloat(E.toFixed(3)) + "<br>" + parseFloat(F.toFixed(3));
    document.getElementById("matrix_col3").innerHTML = parseFloat(a.toFixed(3)) + "<br>" + parseFloat(b.toFixed(3)) + "<br>" + parseFloat(c.toFixed(3));
}

function init_composable(){
    composable = document.getElementById("composable");
    composable_draw(0, 0, false);

    composable.addEventListener('mousemove', function(e){
        var canvas_rect = composable.getBoundingClientRect();
        client_x = e.clientX - canvas_rect.left;
        client_y = e.clientY - canvas_rect.top;
        if(e.buttons == 1){
            if(document.getElementById("radio_p").checked){
                recalculate_composable(client_x, client_y);
                composable_draw(client_x, client_y, false);
            }else if(document.getElementById("radio_s").checked){
                composable_draw(client_x, client_y, true);
            }else if(document.getElementById("radio_r").checked){
                composable_draw(client_x, client_y, true);
            }else{  // rotation
                var new_client_x = x_to_client(client_to_x(client_x) - composable_reference_x);
                var new_client_y = y_to_client(client_to_y(client_y) - composable_reference_y);
                recalculate_composable(new_client_x, new_client_y);
                composable_draw(new_client_x, new_client_y, false);
                composable_reference_x = client_to_x(client_x);
                composable_reference_y = client_to_y(client_y);
            }
        }else{
            if(document.getElementById("radio_p").checked){
                composable_draw(client_x, client_y, true);
            }else{
                var new_client_x = x_to_client(client_to_x(client_x) - composable_reference_x);
                var new_client_y = y_to_client(client_to_y(client_y) - composable_reference_y);
                composable_draw(new_client_x, new_client_y, true);
            }
        }
    }, false);

    composable.addEventListener('mouseup', function(e){
        var canvas_rect = composable.getBoundingClientRect();
        client_x = e.clientX - canvas_rect.left;
        client_y = e.clientY - canvas_rect.top;
        if(document.getElementById("radio_p").checked){
            recalculate_composable(client_x, client_y);
            composable_i = (composable_i + 1) % 4;
            composable_draw(client_x, client_y, false);
        }else if(document.getElementById("radio_s").checked){
            recalculate_composable(client_x, client_y);
            composable_draw(client_x, client_y, false);
        }else if(document.getElementById("radio_r").checked){
            recalculate_composable(client_x, client_y);
            composable_draw(client_x, client_y, false);
        }else{ // translation
            var new_client_x = x_to_client(client_to_x(client_x) - composable_reference_x);
            var new_client_y = y_to_client(client_to_y(client_y) - composable_reference_y);
            recalculate_composable(new_client_x, new_client_y);
            composable_draw(new_client_x, new_client_y, false);
            composable_reference_x = client_to_x(client_x);
            composable_reference_y = client_to_y(client_y);
        }
    }, false);

    composable.addEventListener('mouseleave', function(e){
        composable_draw(0, 0, false);
    }, false);
}

var composable_xs = [1., 2., 2., 1.];
var composable_ys = [1., 1., 2., 2.];
var composable_i = 0;

function composable_draw(client_x, client_y, do_new){
    var x = client_to_x(client_x);
    var y = client_to_y(client_y);

    var context = composable.getContext("2d");
    context.font = "16px sans-serif";
    // background
    context.fillStyle="#eeeeee";
    context.fillRect(0, 0, w, h);

    // original cube
    draw_original_cube_on(context);

    // composable
    context.lineWidth = 2;
    context.beginPath();
    context.moveTo(x_to_client(composable_xs[3]), y_to_client(composable_ys[3]));
    for(var i = 0; i < 4; i++){
        context.lineTo(x_to_client(composable_xs[i]), y_to_client(composable_ys[i]));
    }
    context.strokeStyle="#8c2c3e";
    context.stroke();
    context.closePath();
    context.lineWidth = 1;

    if(do_new){
        // new cube
        var new_xs = [1., 2., 2., 1.];
        var new_ys = [1., 1., 2., 2.];
        if(document.getElementById("radio_p").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = composable_xs[i];
                new_ys[i] = composable_ys[i];
            }
            new_xs[composable_i] = x;
            new_ys[composable_i] = y;
        }else if(document.getElementById("radio_t").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = composable_xs[i] + x;
                new_ys[i] = composable_ys[i] + y;
            }
        }else if(document.getElementById("radio_r").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = rotated_x(rotation_for(x, y), composable_xs[i], composable_ys[i]);
                new_ys[i] = rotated_y(rotation_for(x, y), composable_xs[i], composable_ys[i]);
            }
        }else if(document.getElementById("radio_s").checked){
            for(var i = 0; i < 4; i++){
                new_xs[i] = composable_xs[i] * x;
                new_ys[i] = composable_ys[i] * y;
            }
        }

        context.lineWidth = 2;
        context.beginPath();
        context.setLineDash([4, 4]);
        context.moveTo(x_to_client(new_xs[3]), y_to_client(new_ys[3]));
        for(var i = 0; i < 4; i++){
            context.lineTo(x_to_client(new_xs[i]), y_to_client(new_ys[i]));
        }
        context.strokeStyle="#d64562";
        context.stroke();
        context.setLineDash([]);
        context.closePath();
        context.lineWidth = 1;
    }
    // grid
    draw_grid_on(context);

    // x
    if(document.getElementById("radio_p").checked){
        context.beginPath();
        context.fillStyle="#8c2c3e";
        context.arc(x_to_client(composable_xs[composable_i]), y_to_client(composable_ys[composable_i]), 3, 0, 2*Math.PI);
        context.fill();
        context.closePath();
            
        // guide
        if(do_new){
            context.lineWidth = 2;
            draw_arrow(context, x_to_client(composable_xs[composable_i]), y_to_client(composable_ys[composable_i]), x_to_client(x), y_to_client(y), "#d64562");
            context.lineWidth = 1;
        }
    }
}

function setup_reference_for_translation(){
    composable_reference_x = composable_xs[0];
    composable_reference_y = composable_ys[0];
}

function setup_reference_for_rotation(){
    composable_reference_x = 0.0;
    composable_reference_y = 0.0;
}

function setup_reference_for_scale(){
    composable_reference_x = 0.0;
    composable_reference_y = 0.0;
}

function revert_composable(){
    composable_xs = [1., 2., 2., 1.];
    composable_ys = [1., 1., 2., 2.];
    document.getElementById("matrix_col1").innerHTML = "1<br>0<br>0";
    document.getElementById("matrix_col2").innerHTML = "0<br>1<br>0";
    document.getElementById("matrix_col3").innerHTML = "0<br>0<br>1";
    if(document.getElementById("radio_t").checked){
        setup_reference_for_translation();
    }else if(document.getElementById("radio_r").checked){
        setup_reference_for_rotation();
    }else if(document.getElementById("radio_s").checked){
        setup_reference_for_scale();
    }
    composable_draw(0, 0, false);
}

function inc(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) + 1;
    draw_series();
}

function dec(counter_name) {
    var counter = document.getElementById(counter_name);
    counter.value = Number(counter.value) - 1;
    draw_series();
}
    </script>
  </head>
  <body>
    <center>
    <h1>
Interactive guide to homogeneous coordinates
    </h1>
    <p>
Why would you care about homogeneous coordinates, whatever they are? Well, if you work with geometry: <nobr>3D-graphics</nobr>, image processing, physical simulation, — the answer is obvious. Knowing the mathematics behind your framework enables you to write more efficient code.
    </p>
    <p>
But even if you don’t work with geometry at all, you still might enjoy learning about projective space and its link to linear algebra. It is an outstanding example of mathematical magic: you pay with a small complication, you gain an enormous simplification in return.
    </p>
    <p>
I think, learning this particular piece of mathematics is a valuable experience in its own right. And you know how it works. More experience, higher level, better loot.
    </p>
    <h2>
The complication
    </h2>
    <p>
In a Cartesian coordinate system, a point on a plane is set by a pair of numbers <i>(x<sub>c</sub>, y<sub>c</sub>)</i>. Here is a plot you can choose a point on. Just click or tap anywhere you want.
    </p>
    <canvas id="pick_a_point" width=640 height=640></canvas>
    <script language="JavaScript">
    init_pick_a_point();
    </script>
    <p>
In homogeneous coordinates, a point on a plane is set by a tuple of 3 numbers <i>(x<sub>h</sub>, y<sub>h</sub>, w<sub>h</sub>)</i>.
    </p>
    <p>
This is a bit unusual and it seems excessive since every Cartesian point can be obtained from the homogeneous tuple just like this:
    </p>
    <p class="formula">
x<sub>c</sub> = x<sub>h</sub> / w<sub>h</sub>
        <br>
y<sub>c</sub> = y<sub>h</sub> / w<sub>h</sub>
    </p>
    <p>
There isn't a single correct way to translate a point back. You can pick (almost) any value for <i>w<sub>h</sub></i> and it will still work.
    </p>
    <p>
    <span id="to_fill_with_numbers">
    </span>
    <script language="JavaScript">
    write_the_point_value();
    </script>
    </p>
    <p>
Here is a coordinate translater. It will translate your point into homogeneous coordinates for the (almost) every w<sub>h</sub> you propose.
    </p>
    <form id="w">
Please enter w<sub>h</sub>:
    <button type="button" class="incdec" onclick="dec('proposed_w')">-</button>
    <input type="text" class="incdec" id="proposed_w" value="1" style="width: 36pt;">
    <button type="button" class="incdec" onclick="inc('proposed_w')">+</button>
    <button type="button" onclick="transform()">Transform</button>
    <span id="transformed">
    </span>
    <script language="JavaScript">
    init_w();
    </script>
    </form>
    <p id="to_hide_on_transform">
But it wouldn't work for all the possible numbers. There is one and only one exception.
    </p>
    <div id="after_the_w_proposed" style="display:none;">
        <p>
Exactly! There is no transformation between affine and Cartesian coordinates when w<sub>h</sub> is 0. Kudos for finding this by yourself!
        </p>
     </div>
    <p>
Usually, Cartesian coordinates are just the first two of homogeneous coordinates divided by the third. So when the third one is 1, homogeneous coordinates are the same as Cartesian.
    </p>
    <p>
The smaller <i>w<sub>h</sub></i> gets, the further the point in Cartesian coordinates “travels” from the null. You can slide the point along its axis on the plot. The first two coordinates will remain intact, the whole sliding is dine by only altering the <i>w<sub>h</sub></i>.
    </p>
    <canvas id="slide_a_w" width=640 height=640></canvas>
    <script language="JavaScript">
    init_slide_a_w();
    </script>
    <p>
That’s all rather simple until one moment. What if the third coordinate is <i>0</i> after all?
    </p>
    <p>
Intuition tells that the point with its <i>w<sub>h</sub> = 0</i> should be further from the beginning of the coordinates than every other point with <i>w<sub>h</sub> != 0</i>. But all the points in the Euclidean space can have their third coordinate infinitely small, so this point should be somewhere other than in Euclidean space.
    </p>
    <p>
And that's when it gets fascinating. Homogeneous coordinates denote points not only in Euclidean (or, more generally, <i>affine</i> space) but in the <i>projective</i> space that includes and expands the affine one. There is more geometry that fits our Cartesian system. There is the Euclidean space, and there is also an infinite number of points that are infinitely far from it.
    </p>
    <p>
You can imagine a point from this projective extension as a direction and not a specific point in space. A ray that starts at null and has no length, no end, only the direction.
    </p>
    <p>
This representation is often used in 3D graphics. With homogeneous coordinates, we can compose a 3D-scene so that every object that can be possibly reached, like a house, a tree or a cat, remains in the affine space with the coordinates like <i>(x, y, z, 1)</i>. All the objects that can never be reached, like the moon or the stars, go to the projective extension with the coordinates like <i>(x, y, z, 0)</i>. Both types of objects share the same space.
    </p>
    <p>
Living in a projective space gives you the benefit of being unreachable. But that’s not all it is good for. In fact, we are only starting to get into the benefits.
    </p>
    <h2>
1. In projective space, central and parallel projections are the same
    </h2>
    <p>
There are two kinds of projection in Euclidean space: central and parallel. Central projection is what makes the perspective, so things closer to a viewer seem bigger. That’s what we use in video games to render a 3D scene into a flat picture on a screen. The parallel projection preserves proportions. That’s what we usually use in CAD systems to show bolts and nuts on technical drawings.
    </p>
    <p>
In projective space, these two projections are the same.
    </p>
    <p>
In affine space, you can set a center for a central projection very-very far away from the scene you want to render. This will make disproportion very small. But in projective space, you can hurl a center infinitely far — further away than any point in affine space at all, and the disproportion will disappear completely.
    </p>
    <p>
So bear in mind, if you want to make a game about zombies who happen to be CAD engineers, you don’t have to implement both kinds of projections, only the central one. Just set the central point to <i>(x, y, z, 0)</i>, and this will automatically turn it into the parallel projection with no aditional programming.
    </p>
    <h2>
2. All the surfaces described as equations of degree <i>n</i> are the same
    </h2>
    <p>
I remember my first year in college. We were studying quadric surfaces and one of the exercises was to make an album with their classification. 17 sheets of paper with different graphics and formulas all drawn in hand. The main purpose of this album was to be briefly examined by the professor and thrown away a day after. What a waste!
    </p>
    <p>
Now in projective space, this exercise would have been much more environmentally friendly. In homogeneous coordinates, all the algebraic surfaces are homogeneous too. This means that every piece of a polynomial that defines the surface has the same degree. It may contain different variables with different degrees of their own, but they all magically add up to the very same degree for every element in the sum.
    </p>
    <p>
And this means only one drawing with one formula to be drawn and thrown away instead of 17. That should sum up to a couple of dead trees over the years.
    </p>
    <h2>
3. All projective transformations are matrices
    </h2>
    <p>
Geometric transformations are something that happens to a point. They are functions <i>(x', y') = f(x, y)</i>. If you want to apply a transformation to some object, most of the time you would have to represent it with points and then apply a transformation to each and every one of them.
    </p>
    <p>
This may get computationally heavy. For instance, transforming a picture 3 000 x 4 000 pixels requires 12 000 000 transformations. And transforming a 512 x 512 x 1024 3D-image requires 268 435 456 transformations. If we want to see holographic television anytime soon, we should learn to do these transformations really-really fast.
    </p>
    <p>
Some of the most common transformations are called translation;
    </p>
    <canvas id="translation" width=640 height=640></canvas>
    <script language="JavaScript">
    init_translation();
    </script>
    <p>
rotation;
    </p>
    <canvas id="rotation" width=640 height=640></canvas>
    <script language="JavaScript">
    init_rotation();
    </script>
    <p>
and scale.
    </p>
    <canvas id="scale" width=640 height=640></canvas>
    <script language="JavaScript">
    init_scale();
    </script>
    <p>
They are generalized by the affine transformation that can do translations, and rotations, and scales simultaneously:
    </p>
    <canvas id="affine" width=640 height=640></canvas>
    <script language="JavaScript">
    init_affine();
    </script>
    <p>
The affine transformation is quite powerful but it has its noticeable constraint. It preserves parallelism, which limits it in a way. If you want to do perspective, you should do a projective transformation that looks like this:
    </p>
    <canvas id="projective" width=640 height=640></canvas>
    <script language="JavaScript">
    init_projective();
    </script>
    <h2>
Formulas in Cartesian coordinates
    </h2>
    <p>
The formula for projective transformations in Cartesian coordinates looks like this:
    </p>
    <p class="formula">
x' = (Ax + By + C) / (ax + by +c)
        <br>
y' = (Dx + Ey + F) / (ax + by +c)
    </p>
    <p>
It is a simple geometric transformation just like all the others we have seen before. It also works for one point at a time. It preserves the degree of curves and surfaces so every straight line gets transformed into a straight line, and each plane into a plane. Since all the second-degree surfaces are the same surface, and it also preserves the degree but not the classification from the affine space, an ellipsoid may become a paraboloid or a hyperboloid.
    </p>
    <p>
It also generalizes the affine transformations that have a simpler formula:
    </p>
    <p class="formula">
x' = (Ax + By + C)
        <br>
y' = (Dx + Ey + F)
    </p>
    <p>
It's just a special case of projective transformation when <i>a = 0</i>, <i>b = 0</i>, and <i>c = 1</i>.
    </p>
    <p>
And the affine transformations, in its turn, generalize translations, rotations, and scales. A translation is:
    </p>
    <p class="formula">
x' = x + C &nbsp;&nbsp; (A = 1, B = 0)
        <br>
y' = y + F &nbsp;&nbsp; (D = 0, E = 1)
    </p>
    <p>
A rotation is:
    </p>
    <p class="formula">
x' = sin(r) x + cos(r) y   (A = sin(r), B = cos(r), C = 0)
        <br>
y' = cos(r) x - sin(r) y   (D = cos(r), E = -sin(r), F = 0)
    </p>
    <p>
And a scale is:
    </p>
    <p class="formula">
x' = Ax   (B = 0, C = 0)
        <br>
y' = Ey   (D = 0, F = 0)
    </p>
    <p>
They are all special cases of projective transformations.
    </p>
    <h2>
The matrix in homogeneous coordinates
    </h2>
    <p>
Let's multimpy a square matrix by a point in homogeneous coordinates?
    </p>
    <table class="formula">
    <tr>
    <td class="brackets">[</td>
    <td>A B C<br>D E F<br>a b c</td>
    <td class="brackets">][</td>
    <td>x<br>y<br>w</td>
    <td class="brackets">]</td>
    <td> = </td>
    <td class="brackets">[</td>
    <td>Ax + By + Cw<br>Dx + Ey + Fw<br>ax + by + cw</td>
    <td class="brackets">]</td>
    </tr>
    </table>
    <p>
If the point we took came from Cartesian coordinates then <i>w<sub>h</sub> = 1</i>. Now we see that:
    </p>
    <p class="formula">
x' = Ax + By + C
        <br>
y' = Dx + Ey + F
        <br>
w' = ax + by + c
    </p>
    <p>
To get back to the Cartesian coordinates, let's make our <i>w' = 1</i>. We can do this by dividing everything by <i>w'</i>.
    </p>
    <p class="formula">
x' = (Ax + By + C) / (ax + by + c)
        <br>
y' = (Dx + Ey + F) / (ax + by + c)
        <br>
w' = 1
    </p>
    <p>
Doesn't it look familiar? Well, of course, it does! It's a projective transformation. Or it may be even an affine one with the right coefficients. Or it could be a translation, or a rotation, or a scale. Every one of these transformations can be written down as a matrix multiplication.
    </p>
    <p>
It gets better. Matrices are composable. You can compose your own transformation like: (translation + rotation + another translation + scale + projection), — and it will still be a single matrix multiplication!
    </p>
    <form style="margin-bottom: 6pt;">
    <input type="radio" name="transformation_type" id="radio_t" onclick="setup_reference_for_translation()"><label for="radio_t">Translation</label>&nbsp;&nbsp;
    <input type="radio" name="transformation_type" id="radio_r" onclick="setup_reference_for_rotation()"><label for="radio_r">Rotation</label>&nbsp;&nbsp;
    <input type="radio" name="transformation_type" id="radio_s" onclick="setup_reference_for_scale()"><label for="radio_s">Scale</label>&nbsp;&nbsp;
    <input type="radio" name="transformation_type" id="radio_p" checked="true"><label for="radio_p">Projection</label><br>
    </form>
    <canvas id="composable" width=640 height=640></canvas>
    <table class="formula">
    <tr><td>
Matrix:
    </td>
    <td class="brackets">[</td>
    <td id="matrix_col1">
1<br>0<br>0
    </td><td id="matrix_col2">
0<br>1<br>0
    </td><td id="matrix_col3">
0<br>0<br>1
    </td>
    <td class="brackets">]</td>
    </tr>
    </table>

    <button class="button" id="revert_composable" onclick="revert_composable()">Revert to E</button>
    <script language="JavaScript">
    init_composable();
    </script>
    <p>
This is particularly important because whatever you do: animation, image processing, physics simulation, you always want to do as little computation as possible. Composability allows you to squeeze a series of transformations into a single matrix multiplication which is in turn very super-scalar friendly. With matrices, not only you do fewer calculations, you also benefit from vectorization both on CPU and GPU so you do them faster. Ultra-fast transformations everywhere!
    </p>
    <h2>
Conclusion
    </h2>
    <p>
Pragmatically, you can save a lot of processor time transforming points with one single matrix multiplication instead of applying all the transformations separately. And you can also write less code by unifying all the transformations. But this is not the whole point yet.
    </p>
    <p>
Usually, we lose performance not because of some small computational inefficiencies but because of all the needless layering. And the needless layering occurs when programmers don’t understand and don’t trust the beauty of plain mathematics.
    </p>
    <p>
I hope this page reveals some of it. I hope it makes it a little more trustworthy.
    </p>


    <table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
    <tr>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
        <a href="index.html"><img src="favicon.ico"></a> 
    </td>
    <td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
        &nbsp;&larr; there's more.
    </td>
    <td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
        +
        <a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
        <a href="https://twitter.com/wordsandbuttons">Twitter</a> &
        <a href="https://wordsandbuttons.online/rss"><span style="letter-spacing: 1pt;">RSS</span></a>
    </td>
    </tr>
    </table>
    </center>
  </body>
</html>
