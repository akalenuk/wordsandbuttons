<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<meta name="color-scheme" content="light dark">
	<title>Interactive guide to homogeneous coordinates</title>
	<meta name="description" content="This interactive guide shows how homogeneous coordinates actually make programming geometry simpler and not more complicated. The page explains the extra coordinate, matrices, and generalized transformations. Most of what you need to know about projective geometry as a practicing programmer is here.">
	<meta name="keywords" content="mathematics, tutorials">
	<link rel="shortcut icon" type="image/x-icon" href="favicon.svg" />
	<style>
body {
	margin: 2em;
}

a {
	text-decoration: none;
}

a:link, a:visited {
	color: blue;
}

h1 {
	padding-top: 36pt;
	font-size: 24pt;
	width: 600pt;
	text-align: left;
}

h2 {
	padding-top: 20pt;
	font-size: 20pt;
	width: 600pt;
	text-align: left;
}

h3 {
	font-size: 18pt;
	width: 600pt;
	text-align: left;
}

p {
	line-height: 1.42;
	font-size: 16pt;
	width: 600pt;
	text-align: left;
}

.formula {
	font-family: sans-serif;
	font-size: 15pt;
	font-style: italic;
	text-align: center;
	line-height: 1.8;
	padding-top: 6pt;
	padding-bottom: 6pt;
}

.comment {
	font-family: sans-serif;
	font-size: 12pt;
	text-align: center;
	padding-bottom: 6pt;
}

.plot {
	font-family: sans-serif;
	font-size: 12pt;
	text-align: center;
}

i {
	font-family: sans-serif;
	font-size: 15pt;
	font-style: italic;
}

table.footer {
	padding: 64pt 0pt 32pt 0pt;
	background-color: transparent;
	width: 600pt;
}

td.footer {
	font-family: sans-serif;
	font-size: 16pt;
	font-style: normal;
	padding: 0;
	margin: 0;
	border: 0;
}

pre {
	margin: 0 0 0 0;
	padding-top: 12pt;
	padding-left: 12pt;
	padding-right: 12pt;
	padding-bottom: 12pt;
	font-size: 16pt;
	text-align: left;
	width: 600pt;
}

table {
	border-width: 0pt;
	padding-top: 12pt;
	padding-left: 12pt;
	padding-right: 12pt;
	padding-bottom: 12pt;
	font-size: 16pt;
	font-family: monospace;
	text-align: center;
}

table td {
	padding: 0pt 4pt 0pt 4pt;
	margin: 0 0 0 0;
	border-width: 0pt;
}

.open_matrix {
	width: 2pt;
	border-bottom: 2px solid black;
	border-top: 2px solid black;
	border-left: 2px solid black;
}

.close_matrix {
	width:2pt;
	border-bottom: 2px solid black;
	border-top: 2px solid black;
	border-right: 2px solid black;
}

.fact {
	background-color: #f7cbd3;
	width: 600pt;
	padding-top: 3pt;
	padding-left: 3pt;
	padding-right: 3pt;
	padding-bottom: 3pt;
}

form {
	margin: 0 0 0 0;
	padding-top: 9pt;
	padding-left: 3pt;
	padding-right: 3pt;
	padding-bottom: 9pt;
	font-size: 16pt;
	text-align: center;
	font-family: sans-serif;
	width: 600pt;
	background-color: #eeee99;
	color: #000;
}

input[type="text"] {
	font-size: 16pt;
	font-family: sans-serif;
}

button {
	font-size: 16pt;
	font-family: monospace;
}

input[type="radio"]{
	margin: 4pt 4pt 4pt 4pt;
}

.u {
	border-bottom: 2px dotted #000;
	text-decoration: none;
	cursor: pointer;
	color: blue;
}

svg { touch-action: none; }
	</style>
	<script language="JavaScript">
var w = 600;
var h = 480;
var cx = 220;
var cy = 380;
var d = 128.0;

function svg_to_x(client_x){
	return (client_x - cx) / d;
}

function svg_to_y(client_y){
	return (cy - client_y) / d;
}

function x_to_svg(x){
	return x * d + cx;
}

function y_to_svg(y){
	return cy - y * d;
}

var point_x = 1.5;
var point_y = 2;

var pick_a_point = null;
var slide_a_w = null;
var translation = null;


function svg_grid() {
	var grid = '';
	grid += '<line x1="0" y1="'+cy+'" x2="'+w+'" y2="'+cy+'" stroke="black" />';
	grid += '<line x1="'+(w-14)+'" y1="'+(cy-4)+'" x2="'+w+'" y2="'+cy+'" stroke="black" />';
	grid += '<line x1="'+(w-14)+'" y1="'+(cy+4)+'" x2="'+w+'" y2="'+cy+'" stroke="black" />';
	grid += '<line x1="'+cx+'" y1="0" x2="'+cx+'" y2="'+h+'" stroke="black" />';
	grid += '<line x1="'+cx+'" y1="0" x2="'+(cx-4)+'" y2="14" stroke="black" />';
	grid += '<line x1="'+cx+'" y1="0" x2="'+(cx+4)+'" y2="14" stroke="black" />';
	for(var x = -1.; x <= 2.; x += 1.) {
		const sx = x_to_svg(x).toString();
		const tx = (x_to_svg(x)+4).toString();
		if(x != 0)
			grid += '<line x1="' + sx + '" y1="'+(cy-4)+'" x2="' + sx + '" y2="'+(cy+4)+'" stroke="black" />';
		grid += '<text x="' + tx +'" y="'+(cy-7)+'" class="plot">'+ x.toString() + '</text>';
	}
	for(var y = 0.; y <= 2.; y += 1.) {
		const sy = y_to_svg(y).toString();
		const ty = (y_to_svg(y)-6).toString();
		if(y != 0) {
			grid += '<line x1="'+(cx-4)+'" y1="' + sy + '" x2="'+(cx+4)+'" y2="' + sy + '" stroke="black" />';
			grid += '<text x="'+(cx+4)+'" y="' + ty + '" class="plot">'+ y.toString() + '</text>';
		}
	}
	return grid;
}

function write_the_point_value(){
	document.getElementById("to_fill_with_numbers").innerHTML =
	"The point <i>(" + point_x.toFixed(1) + ", " + point_y.toFixed(1) + ")</i> is the same as " +
	"<i>(" + point_x.toFixed(1) + ", " + point_y.toFixed(1) + ", 1)</i>. <br>" +
	"Or <i>(" + point_x.toFixed(1)*2 + ", " + point_y.toFixed(1)*2 + ", 2)</i>.<br>" +
	"Or <i>(" + point_x.toFixed(1)*0.5 + ", " + point_y.toFixed(1)*0.5 + ", 0.5)</i>. <br>" +
	"Or even <i>(" + point_x.toFixed(1)*1000 + ", " + point_y.toFixed(1)*1000 + ", 1000)</i>. <br>";
}

function init_w(){
	document.getElementById("w").addEventListener('submit', function(e) {
		transform();
		e.preventDefault();
	}, false);
}

function round000000(x) {
	return Math.round(1000000.*x) / 1000000.;
}

function init_pick_a_point(){
	pick_a_point = document.getElementById("pick_a_point");
	var canvas_rect = pick_a_point.getBoundingClientRect();
	pick_a_point_draw(0, 0, false);

	pick_a_point.addEventListener('pointermove', function(e){
		var canvas_rect = pick_a_point.getBoundingClientRect();
		if(e.buttons == 1){ // drag
			point_x = svg_to_x((e.clientX - canvas_rect.left) * 3/4);
			point_y = svg_to_y((e.clientY - canvas_rect.top) * 3/4);
			pick_a_point_draw(0, 0, false);
			write_the_point_value();
			transform();
			slide_a_w_draw(e.clientX);
		}else{  // move
			pick_a_point_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		}
	}, false);

	pick_a_point.addEventListener('pointerdown', function(e){
		var canvas_rect = pick_a_point.getBoundingClientRect();
		point_x = svg_to_x((e.clientX - canvas_rect.left) * 3/4);
		point_y = svg_to_y((e.clientY - canvas_rect.top) * 3/4);
		pick_a_point_draw(0, 0, false);
		write_the_point_value();
		transform();
		slide_a_w_draw(e.clientX);
		pick_a_point.releasePointerCapture(e.pointerId);
	}, false);

	pick_a_point.addEventListener('pointerleave', function(e){
		pick_a_point_draw(0, 0, false);
	}, false);
}

function pick_a_point_draw(client_x, client_y, do_guides){
	var svg = document.getElementById("pick_a_point");
	svg.innerHTML = '';
	svg.innerHTML += '<rect stroke="#eeeeee" fill="#eeeeee" width="'+w+'" height="'+h+'" rx="12"/>';
	svg.innerHTML += svg_grid();
	svg.innerHTML += '<line stroke="#d64562" stroke-dasharray="10,10" x1="'+x_to_svg(point_x)+'" y1="'+cy+'" x2="'+x_to_svg(point_x)+'" y2="'+y_to_svg(point_y)+'" />';
	svg.innerHTML += '<line stroke="#d64562" stroke-dasharray="10,10" x1="'+cx+'" y1="'+y_to_svg(point_y)+'" x2="'+x_to_svg(point_x)+'" y2="'+y_to_svg(point_y)+'" />';
	svg.innerHTML += '<circle stroke="#d64562" fill="#d64562" cx="'+x_to_svg(point_x)+'" cy="'+y_to_svg(point_y)+'" r="2" />';
	const px = (x_to_svg(point_x)+4).toString();
	const py = (y_to_svg(point_y)+19).toString();
	const p_text = point_x.toFixed(1).toString() + ", " + point_y.toFixed(1).toString();
	svg.innerHTML += '<text fill="#d64562" x="'+px+'" y="'+py+'" class="plot">'+ p_text + '</text>';
}

function transform(){
	var w = Number(document.getElementById("proposed_w").value);
	if(w == NaN)
		w = 1;
	if(w == 0){
		document.getElementById("after_the_w_proposed").style.display = "block";
		document.getElementById("transformed").innerHTML = "<br>No transformation available!"
		document.getElementById("to_hide_on_transform").style.display = "none";
	}else{
		document.getElementById("transformed").innerHTML =
			"<br>(" + point_x.toFixed(1) + ", " + point_y.toFixed(1) + ") = " +
			"(" + round000000(point_x.toFixed(1) * w) + ", " + round000000(point_y.toFixed(1) * w) + ", " + parseFloat(w) + ")";
	}
}

var slide_w = 1.0;

function init_slide_a_w(){
	var slide_a_w = document.getElementById("slide_a_w");
	var canvas_rect = slide_a_w.getBoundingClientRect();
	slide_a_w_draw();

	slide_a_w.addEventListener('pointermove', function(e){
		const canvas_rect = slide_a_w.getBoundingClientRect();
		if(e.buttons == 1){
			const mouse_x = svg_to_x((e.clientX - canvas_rect.left) * 3/4);
			const mouse_y = svg_to_y((e.clientY - canvas_rect.top) * 3/4);
			const t = (point_x * mouse_x + point_y * mouse_y) / (point_x * point_x + point_y * point_y);
			slide_w = 1.0 / t;
			slide_a_w_draw();
		}
	}, false);

	slide_a_w.addEventListener('pointerdown', function(e){
		const canvas_rect = slide_a_w.getBoundingClientRect();
		const mouse_x = svg_to_x((e.clientX - canvas_rect.left) * 3/4);
		const mouse_y = svg_to_y((e.clientY - canvas_rect.top) * 3/4);
		const t = (point_x * mouse_x + point_y * mouse_y) / (point_x * point_x + point_y * point_y);
		slide_w = 1.0 / t;
		slide_a_w_draw();
		slide_a_w.releasePointerCapture(e.pointerId);
	}, false);

	slide_a_w.addEventListener('pointerleave', function(e){
		slide_a_w_draw();
	}, false);
}

function slide_a_w_draw(){
	var svg = document.getElementById("slide_a_w");
	svg.innerHTML = '';
	svg.innerHTML += '<rect stroke="#eeeeee" fill="#eeeeee" width="'+w+'" height="'+h+'" rx="12"/>';
	const d = Math.sqrt(point_y*point_y + point_x*point_x);
	const point_outside_x = point_x / d * 7;
	const point_outside_y = point_y / d * 7;
	svg.innerHTML += '<line stroke-dasharray="10,10" stroke="#d64562" x1="'+x_to_svg(-point_outside_x)+'" y1="'+y_to_svg(-point_outside_y)
		+'" x2="'+x_to_svg(point_outside_x)+'" y2="'+y_to_svg(point_outside_y)+'"/>';
	svg.innerHTML += svg_grid();
	svg.innerHTML += '<circle stroke="#d64562" fill="#d64562" cx="'+x_to_svg(point_x/slide_w)+'" cy="'+y_to_svg(point_y/slide_w)+'" r="2" />';
	const px = (x_to_svg(point_x/slide_w)+4).toString();
	const py = (y_to_svg(point_y/slide_w)+19).toString();
	const p_text = point_x.toFixed(1) + ", " + point_y.toFixed(1) + ", " + slide_w.toFixed(2);
	svg.innerHTML += '<text fill="#d64562" x="'+px+'" y="'+py+'" class="plot">'+ p_text + '</text>';
}


var dx = 1.2;
var dy = 1.4;
var drag_x = 0.;
var drag_y = 0.;
function init_translation(){
	var translation = document.getElementById("translation");
	translation_draw(0, 0, false);

	translation.addEventListener('pointerdown', function(e){
		var canvas_rect = translation.getBoundingClientRect();
		drag_x = svg_to_x((e.clientX - canvas_rect.left) * 3/4);
		drag_y = svg_to_y((e.clientY - canvas_rect.top) * 3/4);
		translation_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		translation.releasePointerCapture(e.pointerId);
	}, false);

	translation.addEventListener('pointermove', function(e){
		var canvas_rect = translation.getBoundingClientRect();
		if(e.buttons == 1){
			x = svg_to_x((e.clientX - canvas_rect.left) * 3/4);
			y = svg_to_y((e.clientY - canvas_rect.top) * 3/4);
			dx = dx + x - drag_x;
			dy = dy + y - drag_y;
			drag_x = x;
			drag_y = y;
			translation_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		}
	}, false);

	translation.addEventListener('pointerup', function(e){
		translation_draw(0, 0, false);
	}, false);

	translation.addEventListener('pointerleave', function(e){
		translation_draw(0, 0, false);
	}, false);
}

function source_square() {
	var square = '';
	square += '<line stroke="#999999" x1="'+x_to_svg(1)+'" y1="'+y_to_svg(1) +'" x2="'+x_to_svg(2)+'" y2="'+y_to_svg(1)+'"/>';
	square += '<line stroke="#999999" x1="'+x_to_svg(2)+'" y1="'+y_to_svg(1) +'" x2="'+x_to_svg(2)+'" y2="'+y_to_svg(2)+'"/>';
	square += '<line stroke="#999999" x1="'+x_to_svg(2)+'" y1="'+y_to_svg(2) +'" x2="'+x_to_svg(1)+'" y2="'+y_to_svg(2)+'"/>';
	square += '<line stroke="#999999" x1="'+x_to_svg(1)+'" y1="'+y_to_svg(2) +'" x2="'+x_to_svg(1)+'" y2="'+y_to_svg(1)+'"/>';
	return square;
}

function translation_draw(client_x, client_y, do_new){
	var x = dx;
	var y = dy;

	var svg = document.getElementById("translation");
	svg.innerHTML = '';
	svg.innerHTML += '<rect stroke="#eeeeee" fill="#eeeeee" width="'+w+'" height="'+h+'" rx="12"/>';
	svg.innerHTML += svg_grid();
	svg.innerHTML += source_square();
	if(do_new){
		// the connection
		svg.innerHTML += '<line stroke="#d64562" stroke-dasharray="10,10" x1="'+x_to_svg(1)+'" y1="'+y_to_svg(1) +'" x2="'+x_to_svg(x)+'" y2="'+y_to_svg(y)+'"/>';
		svg.innerHTML += '<line stroke="#d64562" stroke-dasharray="10,10" x1="'+x_to_svg(1+1)+'" y1="'+y_to_svg(1) +'" x2="'+x_to_svg(x+1)+'" y2="'+y_to_svg(y)+'"/>';
		svg.innerHTML += '<line stroke="#d64562" stroke-dasharray="10,10" x1="'+x_to_svg(1+1)+'" y1="'+y_to_svg(1+1) +'" x2="'+x_to_svg(x+1)+'" y2="'+y_to_svg(y+1)+'"/>';
		svg.innerHTML += '<line stroke="#d64562" stroke-dasharray="10,10" x1="'+x_to_svg(1)+'" y1="'+y_to_svg(1+1) +'" x2="'+x_to_svg(x)+'" y2="'+y_to_svg(y+1)+'"/>';
	}
	svg.innerHTML += '<line stroke="#d64562" x1="'+x_to_svg(x)+'" y1="'+y_to_svg(y) +'" x2="'+x_to_svg(x+1)+'" y2="'+y_to_svg(y)+'"/>';
	svg.innerHTML += '<line stroke="#d64562" x1="'+x_to_svg(x+1)+'" y1="'+y_to_svg(y) +'" x2="'+x_to_svg(x+1)+'" y2="'+y_to_svg(y+1)+'"/>';
	svg.innerHTML += '<line stroke="#d64562" x1="'+x_to_svg(x+1)+'" y1="'+y_to_svg(y+1) +'" x2="'+x_to_svg(x)+'" y2="'+y_to_svg(y+1)+'"/>';
	svg.innerHTML += '<line stroke="#d64562" x1="'+x_to_svg(x)+'" y1="'+y_to_svg(y+1) +'" x2="'+x_to_svg(x)+'" y2="'+y_to_svg(y)+'"/>';
	svg.innerHTML += '<text fill="#d64562" x="280" y="440" class="plot">'+ "x' = x + a, where a = " + (x-1).toFixed(1) + '</text>';
	svg.innerHTML += '<text fill="#d64562" x="280" y="460" class="plot">'+ "y' = y + b, where b = " + (y-1).toFixed(1) + '</text>';
}

function rotated_y(a, x, y){
	return Math.sin(a) * x + Math.cos(a) * y;
}

function rotated_x(a, x, y){
	return Math.cos(a) * x - Math.sin(a) * y;
}

var rotation_a = -0.1;

function in_2_pi(x) {
	while(x < -Math.PI)
		x += 2*Math.PI;
	while(x >= Math.PI)
		x -= 2*Math.PI;
	return x;
}

function rotation_for(x, y) {
	return in_2_pi(Math.atan(y / x)
		+ ((x < 0) ? Math.PI : 0.)
		- Math.PI / 4.);
}

function init_rotation(){
	rotation_draw(rotation_a, false);

	var rotation = document.getElementById("rotation");

	rotation.addEventListener('pointermove', function(e){
		if(e.buttons == 1) {
			var canvas_rect = rotation.getBoundingClientRect();
			var client_x = (e.clientX - canvas_rect.left) * 3/4;
			var client_y = (e.clientY - canvas_rect.top) * 3/4;
			rotation_a = rotation_for(svg_to_x(client_x), svg_to_y(client_y))
			rotation_draw(rotation_a, true);
		}
	}, false);

	rotation.addEventListener('pointerdown', function(e){
		var canvas_rect = rotation.getBoundingClientRect();
		var client_x = (e.clientX - canvas_rect.left) * 3/4;
		var client_y = (e.clientY - canvas_rect.top) * 3/4;
		rotation_a = rotation_for(svg_to_x(client_x), svg_to_y(client_y));
		rotation_draw(rotation_a, true);
		rotation.releasePointerCapture(e.pointerId);
	}, false);

	rotation.addEventListener('pointerup', function(e){
		rotation_draw(rotation_a, false);
	}, false);

	rotation.addEventListener('pointerleave', function(e){
		rotation_draw(rotation_a, false);
	}, false);
}

function rotation_draw(a, do_new){
	var xs = [1., 2., 2., 1.];
	var ys = [1., 1., 2., 2.];
	var new_xs = [0, 0, 0, 0];
	var new_ys = [0, 0, 0, 0];
	for(var i = 0; i < 4; i++){
		new_xs[i] = rotated_x(a, xs[i], ys[i]);
		new_ys[i] = rotated_y(a, xs[i], ys[i]);
	}

	var svg = document.getElementById("rotation");
	svg.innerHTML = '';
	svg.innerHTML += '<rect stroke="#eeeeee" fill="#eeeeee" width="'+w+'" height="'+h+'" rx="12"/>';
	svg.innerHTML += source_square();
	if(do_new){
		// the connection
		var r = x_to_svg(Math.sqrt(2.)) - x_to_svg(0.);
		const a1 = - Math.PI / 4.;
		const a2 = - Math.PI / 4. - a;
		if(a < 0.) {
		var r = x_to_svg(Math.sqrt(2.)) - x_to_svg(0.);
			svg.innerHTML += '<path stroke-dasharray="10,10" d="M '+cx+' '+cy+' L '
				+x_to_svg(new_xs[0])+' '+y_to_svg(new_ys[0])+'" stroke="#d64562" fill="none">';
			svg.innerHTML += '<path stroke-dasharray="10,10" d="M '
				+x_to_svg(new_xs[0])+' '+y_to_svg(new_ys[0])+' A '+r+' '+r+' 0 0 0 '
				+x_to_svg(1)+' '+y_to_svg(1)+'" stroke="#d64562" fill="none">';
		} else {
			var r = x_to_svg(Math.sqrt(2.)) - x_to_svg(0.);
			svg.innerHTML += '<path stroke-dasharray="10,10" d="M '+cx+' '+cy+' L '
				+x_to_svg(new_xs[0])+' '+y_to_svg(new_ys[0])+'" stroke="#d64562" fill="none">';
			svg.innerHTML += '<path stroke-dasharray="10,10" d="M '
				+x_to_svg(new_xs[0])+' '+y_to_svg(new_ys[0])+' A '+r+' '+r+' 0 0 1 '
				+x_to_svg(1)+' '+y_to_svg(1)+'" stroke="#d64562" fill="none">';
		}
		svg.innerHTML += '<path d="A '+r+' '+r+' 0 0 0 '+x_to_svg(0)+' '+y_to_svg(0)+'"/>';
	}
	svg.innerHTML += svg_grid();
	for(var i = 0; i < 4; ++i) {
		const j = (i+1)%4;
		svg.innerHTML += '<line stroke="#d64562" x1="'+x_to_svg(new_xs[i])+'" y1="'+y_to_svg(new_ys[i])
			+'" x2="'+x_to_svg(new_xs[j])+'" y2="'+y_to_svg(new_ys[j])+'"/>';
	}
	svg.innerHTML += '<text fill="#d64562" x="280" y="420" class="plot">'+"x' = cos(a) * x + sin(a) * y"+'</text>';
	svg.innerHTML += '<text fill="#d64562" x="280" y="440" class="plot">'+"y' = -sin(a) * x + cos(a) * y" + '</text>';
	svg.innerHTML += '<text fill="#d64562" x="280" y="460" class="plot">'+"where a = " + a.toFixed(2) + '</text>';
}

var scale_x = 0.8;
var scale_y = 1.1;

function init_scale(){
	scale = document.getElementById("scale");
	scale_draw(scale_x, scale_y, false);

	scale.addEventListener('pointermove', function(e){
		if(e.buttons == 1){
			var canvas_rect = scale.getBoundingClientRect();
			var new_scale_x = svg_to_x((e.clientX - canvas_rect.left)*3/4);
			var new_scale_y = svg_to_y((e.clientY - canvas_rect.top)*3/4);
			scale_x = new_scale_x;
			scale_y = new_scale_y;
			scale_draw(scale_x, scale_y, true);
		}
	}, false);

	scale.addEventListener('pointerdown', function(e){
		var canvas_rect = scale.getBoundingClientRect();
		scale_x = svg_to_x((e.clientX - canvas_rect.left)*3/4);
		scale_y = svg_to_y((e.clientY - canvas_rect.top)*3/4);
		scale_draw(scale_x, scale_y, true);
		scale.releasePointerCapture(e.pointerId);
	}, false);

	scale.addEventListener('pointerup', function(e){
		scale_draw(scale_x, scale_y, false);
	}, false);

	scale.addEventListener('pointerleave', function(e){
		scale_draw(scale_x, scale_y, false);
	}, false);
}

function scale_draw(a, b, do_new){
	var xs = [1., 2., 2., 1.];
	var ys = [1., 1., 2., 2.];
	var new_xs = [0, 0, 0, 0];
	var new_ys = [0, 0, 0, 0];
	for(var i = 0; i < 4; i++){
		new_xs[i] = a * xs[i];
		new_ys[i] = b * ys[i];
	}

	var new_saved_xs = [0, 0, 0, 0];
	var new_saved_ys = [0, 0, 0, 0];
	for(var i = 0; i < 4; i++){
		new_saved_xs[i] = scale_x * xs[i];
		new_saved_ys[i] = scale_y * ys[i];
	}

	var svg = document.getElementById("scale");
	svg.innerHTML = '';
	svg.innerHTML += '<rect stroke="#eeeeee" fill="#eeeeee" width="'+w+'" height="'+h+'" rx="12"/>';
	svg.innerHTML += source_square();
	if(do_new){
		svg.innerHTML += '<line stroke="#d64562" stroke-dasharray="10,10" x1="'
			+x_to_svg(new_saved_xs[0])+'" y1="'+y_to_svg(new_saved_ys[0]) +'" x2="'
			+x_to_svg(new_saved_xs[0])+'" y2="'+y_to_svg(0)+'"/>';
		svg.innerHTML += '<line stroke="#d64562" stroke-dasharray="10,10" x1="'
			+x_to_svg(new_saved_xs[0])+'" y1="'+y_to_svg(new_saved_ys[0]) +'" x2="'
			+x_to_svg(0)+'" y2="'+y_to_svg(new_saved_ys[0])+'"/>';
	}
	svg.innerHTML += svg_grid();
	for(var i = 0; i < 4; ++i) {
		const j = (i+1)%4;
		svg.innerHTML += '<line stroke="#d64562" x1="'+x_to_svg(new_xs[i])+'" y1="'+y_to_svg(new_ys[i])
			+'" x2="'+x_to_svg(new_xs[j])+'" y2="'+y_to_svg(new_ys[j])+'"/>';
	}
	svg.innerHTML += '<text fill="#d64562" x="280" y="440" class="plot">'+"x' = a * x, where a = " + a.toFixed(2)+'</text>';
	svg.innerHTML += '<text fill="#d64562" x="280" y="460" class="plot">'+"y' = b * y, where b = " + b.toFixed(2)+'</text>';
}

function nearest_i(x, y, xs, ys) {
	var best_i = 0;
	var best_d = (x-xs[0])*(x-xs[0]) + (y-ys[0])*(y-ys[0]);
	for(var i = 1; i < xs.length; ++i) {
		const d = (x-xs[i])*(x-xs[i]) + (y-ys[i])*(y-ys[i]);
		if(d < best_d) {
			best_d = d;
			best_i = i;
		}
	}
	return best_i;
}

function is_convex(xs, ys) {
	// split the quadrilateral into 2 triangles in 2 ways.
	// If the sum of triangle's areas are equal both ways, it looks convex
	function area_but_not_really(x1, y1, x2, y2, x3, y3) { // cross of triangle's sides
		return Math.abs((x2-x1) * (y3-y1) - (x3-x1) * (y2-y1));
	}
	return Math.abs(
		area_but_not_really(xs[0], ys[0], xs[1], ys[1], xs[2], ys[2])
		+ area_but_not_really(xs[0], ys[0], xs[2], ys[2], xs[3], ys[3])
		- area_but_not_really(xs[1], ys[1], xs[2], ys[2], xs[3], ys[3])
		- area_but_not_really(xs[1], ys[1], xs[3], ys[3], xs[0], ys[0])) < 1e-5;
}

var affine_xs = [1.5, 2.3, 1.5, 0.7];
var affine_ys = [0.9, 1.8, 2.1, 1.2];
var affine_i = 0;

function init_affine(){
	const affine = document.getElementById("affine");
	affine_draw(0, 0, false);

	affine.addEventListener('pointerdown', function(e){
		const canvas_rect = affine.getBoundingClientRect();
		const x = svg_to_x((e.clientX - canvas_rect.left)*3/4);
		const y = svg_to_y((e.clientY - canvas_rect.top)*3/4);
		affine_i = nearest_i(x, y, affine_xs, affine_ys);
		affine_xs[affine_i] = x;
		affine_ys[affine_i] = y;
		affine_xs[(affine_i + 3) % 4] = affine_xs[(affine_i + 2) % 4] + affine_xs[(affine_i + 0) % 4] - affine_xs[(affine_i + 1) % 4];
		affine_ys[(affine_i + 3) % 4] = affine_ys[(affine_i + 2) % 4] + affine_ys[(affine_i + 0) % 4] - affine_ys[(affine_i + 1) % 4];
		affine_draw(e.clientX, e.clientY, true);
		affine.releasePointerCapture(e.pointerId);
	}, false);

	affine.addEventListener('pointermove', function(e){
		const canvas_rect = affine.getBoundingClientRect();
		const x = svg_to_x((e.clientX - canvas_rect.left)*3/4);
		const y = svg_to_y((e.clientY - canvas_rect.top)*3/4);
		if(e.buttons == 1){
			affine_xs[affine_i] = x;
			affine_ys[affine_i] = y;
			affine_xs[(affine_i + 3) % 4] = affine_xs[(affine_i + 2) % 4] + affine_xs[(affine_i + 0) % 4] - affine_xs[(affine_i + 1) % 4];
			affine_ys[(affine_i + 3) % 4] = affine_ys[(affine_i + 2) % 4] + affine_ys[(affine_i + 0) % 4] - affine_ys[(affine_i + 1) % 4];
			affine_draw(0, 0, false);
		}else{
			affine_i = nearest_i(x, y, affine_xs, affine_ys);
			affine_draw(e.clientX, e.clientY, true);
		}
	}, false);

	affine.addEventListener('pointerup', function(e){
		var canvas_rect = affine.getBoundingClientRect();
		const x = svg_to_x((e.clientX - canvas_rect.left)*3/4);
		const y = svg_to_y((e.clientY - canvas_rect.top)*3/4);
		affine_xs[affine_i] = x;
		affine_ys[affine_i] = y;
		affine_xs[(affine_i + 3) % 4] = affine_xs[(affine_i + 2) % 4] + affine_xs[(affine_i + 0) % 4] - affine_xs[(affine_i + 1) % 4];
		affine_ys[(affine_i + 3) % 4] = affine_ys[(affine_i + 2) % 4] + affine_ys[(affine_i + 0) % 4] - affine_ys[(affine_i + 1) % 4];
		affine_draw(e.clientX, e.clientY, true);
	}, false);

	affine.addEventListener('pointerleave', function(e){
		affine_draw(0, 0, false);
	}, false);
}

function affine_draw(client_x, client_y, do_new){
	var svg = document.getElementById("affine");
	svg.innerHTML = '';
	svg.innerHTML += '<rect stroke="#eeeeee" fill="#eeeeee" width="'+w+'" height="'+h+'" rx="12"/>';
	svg.innerHTML += svg_grid();
	svg.innerHTML += source_square();
	for(var i = 0; i < 4; ++i) {
		const j = (i+1)%4;
		svg.innerHTML += '<line stroke="#d64562" x1="'+x_to_svg(affine_xs[i])+'" y1="'+y_to_svg(affine_ys[i])
			+'" x2="'+x_to_svg(affine_xs[j])+'" y2="'+y_to_svg(affine_ys[j])+'"/>';
		svg.innerHTML += '<circle stroke="#d64562" fill="#d64562" cx="'+x_to_svg(affine_xs[i])+'" cy="'+y_to_svg(affine_ys[i])+'" r="2" />';
	}
}

function init_projective(){
	const projective = document.getElementById("projective");
	projective_draw(0, 0, false);

	projective.addEventListener('pointerdown', function(e){
		const canvas_rect = projective.getBoundingClientRect();
		const x = svg_to_x((e.clientX - canvas_rect.left)*3/4);
		const y = svg_to_y((e.clientY - canvas_rect.top)*3/4);
		projective_i = nearest_i(x, y, projective_xs, projective_ys);
		const dx = x - projective_xs[projective_i];
		const dy = y - projective_ys[projective_i];
		projective_xs[projective_i] = x;
		projective_ys[projective_i] = y;
		if(!is_convex(projective_xs, projective_ys)) {
			document.getElementById("after_the_concave").style.display = "block";
			for(var i = 0; i < 4; ++i) {
				if(i != projective_i) {
					projective_xs[i] += dx;
					projective_ys[i] += dy;
				}
			}
		}
		projective_draw(e.clientX, e.clientY, true);
		projective.releasePointerCapture(e.pointerId);
	}, false);

	projective.addEventListener('pointermove', function(e){
		const canvas_rect = projective.getBoundingClientRect();
		const x = svg_to_x((e.clientX - canvas_rect.left)*3/4);
		const y = svg_to_y((e.clientY - canvas_rect.top)*3/4);
		if(e.buttons == 1){
			const dx = x - projective_xs[projective_i];
			const dy = y - projective_ys[projective_i];
			projective_xs[projective_i] = x;
			projective_ys[projective_i] = y;
			if(!is_convex(projective_xs, projective_ys)) {
				document.getElementById("after_the_concave").style.display = "block";
				for(var i = 0; i < 4; ++i) {
					if(i != projective_i) {
						projective_xs[i] += dx;
						projective_ys[i] += dy;
					}
				}
			}
			projective_draw(0, 0, false);
		}else{
			projective_i = nearest_i(x, y, projective_xs, projective_ys);
			projective_draw(e.clientX, e.clientY, true);
		}
	}, false);

	projective.addEventListener('pointerup', function(e){
		var canvas_rect = projective.getBoundingClientRect();
		const x = svg_to_x((e.clientX - canvas_rect.left)*3/4);
		const y = svg_to_y((e.clientY - canvas_rect.top)*3/4);
		const dx = x - projective_xs[projective_i];
		const dy = y - projective_ys[projective_i];
		projective_xs[projective_i] = x;
		projective_ys[projective_i] = y;
		if(!is_convex(projective_xs, projective_ys)) {
			document.getElementById("after_the_concave").style.display = "block";
			for(var i = 0; i < 4; ++i) {
				if(i != projective_i) {
					projective_xs[i] += dx;
					projective_ys[i] += dy;
				}
			}
		}
		projective_draw(e.clientX, e.clientY, true);
	}, false);

	projective.addEventListener('pointerleave', function(e){
		projective_draw(0, 0, false);
	}, false);
}

var projective_xs = [  1.55859375,  1.93359375,  1.787109375,  0.521484375];
var projective_ys = [  2.44921875,  2.349609375,  0.50390625,  1.04296875];
var projective_i = 0;

function projective_draw(client_x, client_y, do_new){
	var svg = document.getElementById("projective");
	svg.innerHTML = '';
	svg.innerHTML += '<rect stroke="#eeeeee" fill="#eeeeee" width="'+w+'" height="'+h+'" rx="12"/>';
	svg.innerHTML += svg_grid();
	svg.innerHTML += source_square();
	for(var i = 0; i < 4; ++i) {
		const j = (i+1)%4;
		svg.innerHTML += '<line stroke="#d64562" x1="'+x_to_svg(projective_xs[i])+'" y1="'+y_to_svg(projective_ys[i])
			+'" x2="'+x_to_svg(projective_xs[j])+'" y2="'+y_to_svg(projective_ys[j])+'"/>';
		svg.innerHTML += '<circle stroke="#d64562" fill="#d64562" cx="'
			+x_to_svg(projective_xs[i])+'" cy="'+y_to_svg(projective_ys[i])+'" r="2" />';
	}
}

var composable_mousedown_x = 0;
var composable_mousedown_y = 0;

var composable_transformation = function(x, y) {	// just a placeholder to be filled below
	return [x, y];
}

function recalculate_composable(client_x, client_y){
	const x = svg_to_x(client_x);
	const y = svg_to_y(client_y);

	// new cube
	var new_xs = [1., 2., 2., 1.];
	var new_ys = [1., 1., 2., 2.];
	if(document.getElementById("radio_p").checked){
		for(var i = 0; i < 4; i++){
			new_xs[i] = composable_xs[i];
			new_ys[i] = composable_ys[i];
		}
		new_xs[composable_i] = x;
		new_ys[composable_i] = y;
		if(!is_convex(new_xs, new_ys)) {
			for(var i = 0; i < 4; i++) {
				if(i != composable_i) {
					new_xs[i] += x - composable_xs[composable_i];
					new_ys[i] += y - composable_ys[composable_i];
				}
			}
		}
	}else if(document.getElementById("radio_t").checked){
		for(var i = 0; i < 4; i++){
			new_xs[i] = composable_xs[i] + x - svg_to_x(composable_mousedown_x);
			new_ys[i] = composable_ys[i] + y - svg_to_y(composable_mousedown_y);
		}
	}else if(document.getElementById("radio_r").checked){
		const a_new = rotation_for(x, y);
		const a_increment = a_new - rotation_for(svg_to_x(composable_mousedown_x), svg_to_y(composable_mousedown_y));
		for(var i = 0; i < 4; i++){
			new_xs[i] = rotated_x(a_increment, composable_xs[i], composable_ys[i]);
			new_ys[i] = rotated_y(a_increment, composable_xs[i], composable_ys[i]);
		}
	}else if(document.getElementById("radio_s").checked){
		var x_div = svg_to_x(composable_mousedown_x);
		var y_div = svg_to_y(composable_mousedown_y);
		if(Math.abs(x_div) < 1e-4) x_div = 1e-4;
		if(Math.abs(y_div) < 1e-4) y_div = 1e-4;
		var sx = x / x_div;
		var sy = y / y_div;
		if(Math.abs(x) < 1e-2) {
			sx = 1e-6;
			document.getElementById("after_the_scale0").style.display = "block";
		}
		if(Math.abs(y) < 1e-2) {
			sy = 1e-6;
			document.getElementById("after_the_scale0").style.display = "block";
		}
		for(var i = 0; i < 4; i++){
			new_xs[i] = composable_xs[i] * sx;
			new_ys[i] = composable_ys[i] * sy;
		}
	}

	for(var i = 0; i < 4; i++){
		composable_xs[i] = new_xs[i];
		composable_ys[i] = new_ys[i];
	}

	recalculate_composable_matrix();
	}

// Hidden fact #3.
//
// Yes, there is a hidden fact #3 but it's not even on the page, it's right here in the code.
// The fact is, the matrix can be indeed composed as a series of transformations,
// but sometimes it's easier to compute it from the 4-points translations instead.
//
// We form equations from the projective transformation formula like this:
// For i in 1..4:
// (Ax_i + By_i + C) / (ax_i + bx_i + c) = x_i'
// (Dx_i + Ey_i + F) / (ax_i + bx_i + c) = y_i'
// Then we multiply both sides by (ax_i + bx_i + c), and subtract the right side from the left:
// Ax_i + By_i + C) - (ax_i + bx_i + c)x_i' = 0
// Dx_i + Ey_i + F) - (ax_i + bx_i + c)y_i' = 0
// This forms a system of 8 linear equations. We can solve it and get 8 coefficients.
// But not 9. And we need nine. So for the last one, the little 'c', we just pick a number.
// 1 is the most convenient number, but remember, we're in homogeneous coordinates where
// (1,2,3) and (2,4,6) is the exact same point. So with any c != 0, the system will give us all
// the coefficients we need.
//
// The ready made solution for this system is proposed in the function below.
//
// For more info on linear systems, look here:
// https://wordsandbuttons.online/programmers_introduction_to_linear_equations.html
// And to learn how to solve them symbolically but not manually:
// https://wordsandbuttons.online/sympy_makes_math_fun_again.html
//
// Kudos for looking into the code!
//
function recalculate_composable_matrix() {
	x0 = composable_xs[0];	y0 = composable_ys[0];
	x1 = composable_xs[1];	y1 = composable_ys[1];
	x2 = composable_xs[2];	y2 = composable_ys[2];
	x3 = composable_xs[3];	y3 = composable_ys[3];
	// calculate the matrix
	var A = (-x0*x2*y1 + x0*x2*y3 + x0*x3*y1 - x0*x3*y2 + x1*x2*y0 - x1*x2*y3 - x1*x3*y0 + x1*x3*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
	var D = (x0*x1*y2 - x0*x1*y3 - x0*x2*y1 + x0*x2*y3 + x1*x3*y0 - x1*x3*y2 - x2*x3*y0 + x2*x3*y1)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
	var a = (-2*x0*x1*y2 + 2*x0*x1*y3 + 3*x0*x2*y1 - 3*x0*x2*y3 - 2*x0*x3*y1 + 2*x0*x3*y2 - x1*x2*y0 + x1*x2*y3 + x2*x3*y0 - x2*x3*y1)/
		(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
	var B = (-x0*y1*y2 + x0*y1*y3 + x1*y0*y2 - x1*y0*y3 + x2*y0*y3 - x2*y1*y3 - x3*y0*y2 + x3*y1*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
	var E = (-x0*y1*y3 + x0*y2*y3 + x1*y0*y2 - x1*y2*y3 - x2*y0*y1 + x2*y1*y3 + x3*y0*y1 - x3*y0*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
	var b = (x0*y1*y2 - x0*y2*y3 - 3*x1*y0*y2 + 2*x1*y0*y3 + x1*y2*y3 + 2*x2*y0*y1 - 2*x2*y0*y3 - 2*x3*y0*y1 + 3*x3*y0*y2 - x3*y1*y2)/
		(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
	var C = (-x0*y2 + x0*y3 + x1*y2 - x1*y3 + x2*y0 - x2*y1 - x3*y0 + x3*y1)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
	var F = (-x0*y1 + x0*y2 + x1*y0 - x1*y3 - x2*y0 + x2*y3 + x3*y1 - x3*y2)/(x0*y1 - x0*y3 - x1*y0 - 2*x1*y2 + 3*x1*y3 + 2*x2*y1 - 2*x2*y3 + x3*y0 - 3*x3*y1 + 2*x3*y2);
	var c = 1.;

	composable_transformation = function(x, y) {
		const x_ = A*x + D*y + a;
		const y_ = B*x + E*y + b;
		const w_ = C*x + F*y + c;
		return [x_/w_, y_/w_];
	};

	document.getElementById("matrix_col1").innerHTML = parseFloat(A.toFixed(3)) + "<br>" + parseFloat(B.toFixed(3)) + "<br>" + parseFloat(C.toFixed(3));
	document.getElementById("matrix_col2").innerHTML = parseFloat(D.toFixed(3)) + "<br>" + parseFloat(E.toFixed(3)) + "<br>" + parseFloat(F.toFixed(3));
	document.getElementById("matrix_col3").innerHTML = parseFloat(a.toFixed(3)) + "<br>" + parseFloat(b.toFixed(3)) + "<br>" + parseFloat(c.toFixed(3));
}

function init_composable(){
	composable = document.getElementById("composable");
	composable_draw(0, 0, false);

	composable.addEventListener('pointerdown', function(e){
		const canvas_rect = composable.getBoundingClientRect();
		composable_mousedown_x = (e.clientX - canvas_rect.left)*3/4;
		composable_mousedown_y = (e.clientY - canvas_rect.top)*3/4;
		const x = svg_to_x( composable_mousedown_x);
		const y = svg_to_y( composable_mousedown_y);
		composable_i = nearest_i(x, y, composable_xs, composable_ys);
		recalculate_composable(composable_mousedown_x, composable_mousedown_y);
		composable_draw(0, 0, false);
		composable.releasePointerCapture(e.pointerId);
	}, false);

	composable.addEventListener('pointermove', function(e){
		var canvas_rect = composable.getBoundingClientRect();
		const client_x = (e.clientX - canvas_rect.left)*3/4;
		const client_y = (e.clientY - canvas_rect.top)*3/4;
		if(e.buttons == 1){
			recalculate_composable(client_x, client_y);
			composable_mousedown_x = client_x;
			composable_mousedown_y = client_y;
			composable_draw(client_x, client_y, true);
		}else{
			if(document.getElementById("radio_p").checked){
				const x = svg_to_x( client_x );
				const y = svg_to_y( client_y );
				composable_i = nearest_i(x, y, composable_xs, composable_ys);
				composable_draw(client_x, client_y, true);
			}
		}
	}, false);

	composable.addEventListener('pointerup', function(e){
		var canvas_rect = composable.getBoundingClientRect();
		client_x = (e.clientX - canvas_rect.left)*3/4;
		client_y = (e.clientY - canvas_rect.top)*3/4;
		recalculate_composable(client_x, client_y);
		composable_draw(client_x, client_y, false);
	}, false);

	composable.addEventListener('pointerleave', function(e){
		composable_draw(0, 0, false);
	}, false);
}

var composable_xs = [1., 2., 2., 1.];
var composable_ys = [1., 1., 2., 2.];
var composable_i = 0;

function composable_draw(client_x, client_y, do_new){
	var svg = document.getElementById("composable");
	svg.innerHTML = '';
	svg.innerHTML += '<rect stroke="#eeeeee" fill="#eeeeee" width="'+w+'" height="'+h+'" rx="12"/>';
	svg.innerHTML += svg_grid();
	svg.innerHTML += source_square();
	for(var t = 1.125; t < 2.; t += 0.125) {
		const xy1 = composable_transformation(t, 1.);
		const xy2 = composable_transformation(t, 2.);
		svg.innerHTML += '<line stroke="#d64562" stroke-width="0.5" x1="'+x_to_svg(xy1[0])+'" y1="'+y_to_svg(xy1[1])
			+'" x2="'+x_to_svg(xy2[0])+'" y2="'+y_to_svg(xy2[1])+'"/>';
		const xy3 = composable_transformation(1., t);
		const xy4 = composable_transformation(2., t);
		svg.innerHTML += '<line stroke="#d64562" stroke-width="0.5" x1="'+x_to_svg(xy3[0])+'" y1="'+y_to_svg(xy3[1])
			+'" x2="'+x_to_svg(xy4[0])+'" y2="'+y_to_svg(xy4[1])+'"/>';
	}
	for(var i = 0; i < 4; ++i) {
		const j = (i+1)%4;
		svg.innerHTML += '<line stroke="#d64562" x1="'+x_to_svg(composable_xs[i])+'" y1="'+y_to_svg(composable_ys[i])
			+'" x2="'+x_to_svg(composable_xs[j])+'" y2="'+y_to_svg(composable_ys[j])+'"/>';
		svg.innerHTML += '<circle stroke="#d64562" fill="#d64562" cx="'
			+x_to_svg(composable_xs[i])+'" cy="'+y_to_svg(composable_ys[i])+'" r="2" />';
	}
}

function revert_composable(){
	composable_xs = [1., 2., 2., 1.];
	composable_ys = [1., 1., 2., 2.];
	recalculate_composable_matrix();
	composable_draw(0, 0, false);
}

function inc(counter_name) {
	var counter = document.getElementById(counter_name);
	counter.value = Number(counter.value) + 1;
}

function dec(counter_name) {
	var counter = document.getElementById(counter_name);
	counter.value = Number(counter.value) - 1;
}
	</script>
</head>
<body>
	<center>
	<p style="width: 600pt; padding: 36pt 0pt 64pt 0pt;">This is <a href="index.html">Words and Buttons Online</a> — a collection of&nbsp;interactive <a href="all_tutorials.html">#tutorials</a>, <a href="all_demos.html">#demos<a/>, and <a href="all_quizzes.html">#quizzes</a> about <a href="all_mathematics.html">#mathematics</a>, <a href="all_algorithms.html">#algorithms</a> and <a href="all_programming.html">#programming</a>.</p>
	<h1>
Interactive guide to homogeneous coordinates
	</h1>
	<p>
Why would you care about homogeneous coordinates, whatever they are? Well, if you work with geometry: <nobr>3D graphics</nobr>, image processing, physical simulation, — the answer is obvious. Knowing the mathematics behind your framework helps you write more efficient code.
	</p>
	<p>
But even if you don’t work with geometry at all, you still might enjoy learning about homogeneous coordinates, projective space, and their link to linear algebra. This topic is a great example of mathematical investment in programming: you pay with a small complication, and you gain an enormous simplification in return.
	</p>
	<p>
I think, learning this particular piece of mathematics is a valuable experience in its own right. And you know how the game works: more experience, higher level, better loot.
	</p>
	<h2>
The investment
	</h2>
	<p>
In a <span id="index_cartesian_coordinate_system">Cartesian coordinate system</span>, a point on a plane is set by a pair of numbers: <nobr><i>(x<sub>c</sub>, y<sub>c</sub>)</i></nobr>. Here is a plot you can choose a point on. Just click or tap anywhere you want.
	</p>
	<svg id="pick_a_point" width="600pt" height="480pt" viewBox="0 0 600 480" cursor="pointer" xmlns="http://www.w3.org/2000/svg">
	</svg>
	<p class="comment">
&uarr; You can also drag the point. All the plots on this page are interactive.
	</p>
	<script language="JavaScript">
	init_pick_a_point();
	</script>
	<p>
In <span id="index_homogeneous_coordinates">homogeneous coordinates</span>, a point on a plane is set by a tuple of not just 2 but 3 numbers: <nobr><i>(x<sub>h</sub>, y<sub>h</sub>, w<sub>h</sub>)</i></nobr>.
	</p>
	<p>
That’s the complication. That’s the investment. The third number feels unusual and seems excessive. Especially, since every Cartesian point can be obtained from the homogeneous tuple just like this:
	</p>
	<table class="formula"><tr><td rowspan=2>
x<sub>c</sub> =
	</td><td style="border-bottom: 1px solid black">
x<sub>h</sub>
	</td></tr><tr><td>
w<sub>h</sub>
	</td></tr></table>
	<table class="formula"><tr><td rowspan=2>
y<sub>c</sub> =
	</td><td style="border-bottom: 1px solid black">
y<sub>h</sub>
	</td></tr><tr><td>
w<sub>h</sub>
	</td></tr></table>
	<p>
To translate a point from Cartesian to homogeneous coordinates, you can simply say:
	</p>
	<p class="formula">
x<sub>h</sub> = x<sub>c</sub>, y<sub>h</sub> = y<sub>c</sub>, w<sub>h</sub> = 1
	</p>
	<p>Or, if you're feeling adventurous, you can pick (almost) any value for <nobr><i>w<sub>h</sub></i></nobr>. Then you just multiply your <i>x</i> and <i>y</i> by <i>w</i> and here you go!
	</p>
	<p>
	<span id="to_fill_with_numbers">
	</span>
	<script language="JavaScript">
	write_the_point_value();
	</script>
	</p>
	<p>
Here is a coordinate translator. It will translate the point you chose on a plot from above into homogeneous coordinates for (almost) every <nobr><i>w<sub>h</sub></i></nobr> you propose.
	</p>
	<form id="w">
Please enter <i>w<sub>h</sub></i>:
	<button type="button" onclick="dec('proposed_w')">&nbsp;-&nbsp;</button>
	<input type="text" id="proposed_w" value="1" style="width: 36pt;">
	<button type="button" onclick="inc('proposed_w')">&nbsp;+&nbsp;</button>
	<button type="button" onclick="transform()">&nbsp;Transform&nbsp;</button>
	<br>
	<span id="transformed">
	</span>
	<script language="JavaScript">
	init_w();
	</script>
	</form>
	<p id="to_hide_on_transform">
But it wouldn't work for all the possible numbers. There is one and only one exception.
	</p>
	<div id="after_the_w_proposed" style="display:none;" class="fact">
	<script language="JavaScript">
	transform();
	</script>
		<h3>Hidden fact #1</h3>
		<p>
There is no transformation between homogeneous and Cartesian coordinates <nobr>when <i>w<sub>h</sub></i> is 0.</nobr> Kudos for finding this by yourself!
		</p>
		<p style="text-align: right;">
<span onclick="document.getElementById('after_the_w_proposed').style.display = 'none';" class="u">Hide the hidden fact</span>.
		</p>
	 </div>
	<p>
Usually, Cartesian coordinates are just the first two homogeneous coordinates divided by the third. So when the third one is 1, homogeneous coordinates are the same as Cartesian.
	</p>
	<p>
The smaller <nobr><i>w<sub>h</sub></i></nobr> gets, the further the point in Cartesian coordinates “travels” from the null. To see this effect, you can slide the point along its personal axis on the plot. Note that the first two coordinates remain intact all the time, you make the point slide by only altering the <nobr><i>w<sub>h</sub></i></nobr>.
	</p>
	<svg id="slide_a_w" width="600pt" height="480pt" viewBox="0 0 600 480" cursor="pointer" xmlns="http://www.w3.org/2000/svg">
	<script language="JavaScript">
	init_slide_a_w();
	</script>
	<p>
That third coordinate still seems rather unnecessary until one moment. What if the third coordinate is <i>0</i> after all?
	</p>
	<p>
Intuition tells us that the point with its <nobr><i>w<sub>h</sub> = 0</i></nobr> should be further from the beginning of the coordinates than every other point with <nobr><i>w<sub>h</sub> &ne; 0</i></nobr>. All the points in Euclidean space have <nobr><i>w<sub>h</sub> &ne; 0</i></nobr>, so this point should be somewhere other than in Euclidean space.
	</p>
	<p>
And that's when it gets fascinating. Homogeneous coordinates denote points not only in Euclidean (or, more generally, <i><span id="index_affine_space">affine space</span></i>) but in <i><span id="index_projective_space">projective space</span></i> that includes and expands the affine one. There is more geometry that fits in our cozy Cartesian system. There is the Euclidean space, and there is also an infinite number of points that are infinitely far from it.
	</p>
	<p>
If you have trouble imagining infinitely far points, you can also imagine a triplet <nobr><i>(x, y, 0)</i></nobr> from this projective extension as a direction and not a specific point in space. Not a point per se, but a ray that starts at null and has no length, no end, only the direction.
	</p>
	<p>
This representation is often used in <nobr>3D graphics</nobr>. With homogeneous coordinates, we can compose <nobr>a 3D scene</nobr> so that every object that can be possibly reached, like a house, a tree, or a cat, remains in the affine space with coordinates like <nobr><i>(x, y, z, 1)</i></nobr>. All the objects that can not be reached by design, like the Sun, the Moon, or financial stability by the age of thirty, go to the projective extension with coordinates like <nobr><i>(x, y, z, 0)</i></nobr>. Both types of objects share the same space.
	</p>
	<p>
Living in a projective space gives you the benefit of being unreachable if you desire to. But that’s not all it is good for. In fact, we are only starting to enjoy our returns of investment.
	</p>
	<h2>
ROI 1. Central and parallel projections are the same
	</h2>
	<p>
There are two kinds of projections in Euclidean space: central and parallel. The <span id="index_central_projection">central projection</span> creates a perspective. It makes things closer to the viewer seem larger. We use central projection in video games to render a graphic 3D scene into a flat picture on a screen.
	</p>
	<p>
The <span id="index_parallel_projection">parallel projection</span> preserves proportions. Things of the same size look the same size however far from or close to the viewer they are. That’s what we usually use in CAD systems to show bolts and nuts on technical drawings so an engineer would see that an M8 bolt is indeed an M8 bolt and not an M32 far away.
	</p>
	<p>
In projective space, these two projections are the same.
	</p>
	<p>
In affine space, you can set the central point for a central projection very far away from the scene you want to render. This will make the discrepancy between the two kinds of projections minuscule. But in projective space, you can yeet the projection central point infinitely far — further away than any point in the affine space at all, and the discrepancy will disappear completely.
	</p>
	<p>
So bear in mind, if you want to make a game about zombies who happen to be CAD engineers, you don’t have to implement both kinds of projections. A central projection should be enough. Just set the central point to <nobr><i>(x, y, z, 0)</i></nobr>, and this will automatically turn a central projection into a parallel projection with no additional programming.
	</p>
	<h2>
ROI 2. All the quadric surfaces are the same
	</h2>
	<p>
I remember my first year in college. We were studying quadric surfaces and one of the exercises was to make an album with all of them. 17 sheets of paper with different graphics and formulas all drawn by hand. The main purpose of this album was to be briefly examined by the professor and thrown away a day later. What a waste!
	</p>
	<p>
Now in projective space, this exercise would have been much more environmentally friendly. In homogeneous coordinates, all the algebraic surfaces are homogeneous too. This means that every piece of a polynomial that defines the surface has the same degree. It may contain different variables with different degrees of their own, but they all magically add up to the very same degree for every element in the sum.
	</p>
	<p>
And this means only one drawing with one formula to be drawn and thrown away instead of 17. That should sum up to a couple of dead trees over the years.
	</p>
	<h2>
ROI 3. All the projective transformations are matrices
	</h2>
	<p>
Geometric transformations are something that happens to points. They are functions <nobr><i>(x', y') = f(x, y)</i></nobr>. If you want to apply a transformation to some object, most of the time you would have to represent it with points and then apply a transformation to each and every one of them.
	</p>
	<p>
This may get computationally heavy. For instance, transforming a picture <nobr>3&thinsp;000&thinsp;&times;&thinsp;4&thinsp;000</nobr> pixels requires <nobr>12,000,000</nobr> transformations. And transforming a <nobr>1024&thinsp;&times;&thinsp;1024&thinsp;&times;&thinsp;1024</nobr> <nobr>3D image</nobr> requires exactly <nobr>1,073,741,824</nobr>. That's a billion with a &ldquo;B&rdquo;. If we want to see holographic television anytime soon, we should learn to do these transformations really-really fast.
	</p>
	<p>
Some of the most common transformations are:
	</p>
	<p>
1. <span id="index_translation">translation</span>;
	</p>
	<svg id="translation" width="600pt" height="480pt" viewBox="0 0 600 480" cursor="pointer" xmlns="http://www.w3.org/2000/svg">
	</svg>
	<script language="JavaScript">
	init_translation();
	</script>
	<p>
2. <span id="index_rotation">rotation</span>;
	</p>
	<svg id="rotation" width="600pt" height="480pt" viewBox="0 0 600 480" cursor="pointer" xmlns="http://www.w3.org/2000/svg">
	</svg>
	<script language="JavaScript">
	init_rotation();
	</script>
	<p>
3. <span id="index_scaling">scaling</span>.
	</p>
	<svg id="scale" width="600pt" height="480pt" viewBox="0 0 600 480" cursor="pointer" xmlns="http://www.w3.org/2000/svg">
	</svg>
	<script language="JavaScript">
	init_scale();
	</script>
	<p>
They are generalized by the <span id="index_affine_transformation">affine transformation</span> that can do translations, and rotations, and scales simultaneously:
	</p>
	<svg id="affine" width="600pt" height="480pt" viewBox="0 0 600 480" cursor="pointer" xmlns="http://www.w3.org/2000/svg">
	</svg>
	<p class="comment">
&uarr; Just a reminder, you can drag the points. Try it, feel the affine limitation.
	</p>
	<script language="JavaScript">
	init_affine();
	</script>
	<p>
The affine transformation is quite powerful but it has its noticeable constraint. It preserves parallelism, which is in a way limiting. If you want to go beyond this limitation, you should do a <span id="index_projective_transformation">projective transformation</span> that, for example, may look like this:
	</p>
	<svg id="projective" width="600pt" height="480pt" viewBox="0 0 600 480" cursor="pointer" xmlns="http://www.w3.org/2000/svg">
	</svg>
	<p class="comment">
This is a 4-point transformation. All 4 points are (almost) independent now.
	</p>
	<script language="JavaScript">
	init_projective();
	</script>
	<div id="after_the_concave" style="display:none;" class="fact">
		<h3>Hidden fact #2</h3>
		<p>
Ah, yes! This transformation is also limited. For instance, you can't transform a square into a concave quadrilateral. Kudos for finding this out by yourself!
		</p>
		<p style="text-align: right;">
<span onclick="document.getElementById('after_the_concave').style.display = 'none';" class="u">Hide the hidden fact</span>.
		</p>
	 </div>
	<h2>
Formulas in Cartesian coordinates
	</h2>
	<p>
The formula for projective transformations in Cartesian coordinates is:
	</p>
	<table class="formula"><tr><td rowspan=2>
x' =
	</td><td style="border-bottom: 1px solid black">
A&hairsp;x + B&hairsp;y + C
	</td></tr><tr><td>
a&hairsp;x + b&hairsp;y + c
	</td></tr></table>
	<table class="formula"><tr><td rowspan=2>
y' =
	</td><td style="border-bottom: 1px solid black">
D&hairsp;x + E&hairsp;y + F
	</td></tr><tr><td>
a&hairsp;x + b&hairsp;y + c
	</td></tr></table>
	<p>
This is a geometric transformation just like rotation, translation, or scaling. This transformation, however, doesn’t preserve the shape of the input entity, like translation does, it only preserves the degree of curves and surfaces so every straight line gets transformed into a straight line, and in 3D, each plane into a plane. Since all the second-degree surfaces are the same surface, it also preserves the degree but not the classification from the affine space. An ellipsoid may become a paraboloid or a hyperboloid.
	</p>
	<p>
Projective transformation also generalizes affine transformation which has a simpler formula:
	</p>
	<p class="formula">
x' = A&hairsp;x + B&hairsp;y + C
		<br>
y' = D&hairsp;x + E&hairsp;y + F
	</p>
	<p>
So affine transformation is a special case of projective transformation when <nobr><i>a = 0</i></nobr>, <nobr><i>b = 0</i></nobr>, <nobr>and <i>c = 1</i></nobr>.
	</p>
	<p>
Affine transformation, in turn, generalizes translation, rotation, and scaling. A translation is:
	</p>
	<p class="formula">
x' = x + C <span style="font-size: 12pt; color: #777; padding-left: 2pt;">(A = 1, B = 0)</span>
		<br>
y' = y + F <span style="font-size: 12pt; color: #777; padding-left: 2pt;">(D = 0, E = 1)</span>
	</p>
	<p>
A rotation is:
	</p>
	<p class="formula">
x' = sin(r)&hairsp;x + cos(r)&hairsp;y <span style="font-size: 12pt; color: #777; padding-left: 2pt;">(A = sin(r), B = cos(r), C = 0)</span>
		<br>
y' = cos(r)&hairsp;x - sin(r)&hairsp;y <span style="font-size: 12pt; color: #777; padding-left: 2pt;">(D = cos(r), E = -sin(r), F = 0)</span>
	</p>
	<p>
And a scale is:
	</p>
	<p class="formula">
x' = A&hairsp;x <span style="font-size: 12pt; color: #777; padding-left: 2pt;">(B = 0, C = 0)</span>
		<br>
y' = E&hairsp;y <span style="font-size: 12pt; color: #777; padding-left: 2pt;">(D = 0, F = 0)</span>
	</p>
	<p>
Of course, since translation, rotation, and scaling are special cases of affine transformation, they are all special cases of projective transformation too.
	</p>
	<h2>
The matrix multiplication in homogeneous coordinates
	</h2>
	<p>
Let's multiply a square matrix by a point in homogeneous coordinates.
	</p>
	<table class="formula">
	<tr>
	<td class="open_matrix">
	</td>
	<td style="width:24pt;">A<br>D<br>a</td>
	<td style="width:24pt;">B<br>E<br>b</td>
	<td style="width:24pt;">C<br>F<br>c</td>
	<td class="close_matrix"></td>
	<td></td>
	<td class="open_matrix"></td>
	<td>x<br>y<br>w</td>
	<td class="close_matrix"></td>
	<td> = </td>
	<td class="open_matrix"></td>
	<td>Ax + By + Cw<br>Dx + Ey + Fw<br>ax + by + cw</td>
	<td class="close_matrix"></td>
	</tr>
	</table>
	<p>
If our point comes from the Cartesian coordinates then <nobr><i>w<sub>h</sub> = 1</i></nobr>. Now we see that:
	</p>
	<p class="formula">
x' = A&hairsp;x + B&hairsp;y + C
		<br>
y' = D&hairsp;x + E&hairsp;y + F
		<br>
w' = a&hairsp;x + b&hairsp;y + c
	</p>
	<p>
To get back to the Cartesian coordinates, let's make our <nobr><i>w' = 1</i></nobr>. We can do this by dividing everything by <nobr><i>w'</i></nobr>.
	</p>
	<p class="formula">
x' = (A&hairsp;x + B&hairsp;y + C) / (a&hairsp;x + b&hairsp;y + c)
		<br>
y' = (D&hairsp;x + E&hairsp;y + F) / (a&hairsp;x + b&hairsp;y + c)
		<br>
w' = 1
	</p>
	<p>
Doesn't it look familiar? Well, of course, it does! It's a projective transformation. Or, with the specific coefficients, it could even be an affine one. Or it could be a translation, or a rotation, or a scale. Every one of these transformations can be conducted by mere matrix multiplication.
	</p>
	<p>
It gets better. Matrices are composable. You can compose your own transformation like this: translation, and then rotation, and another translation, and then scale, and projection, — and it will all fit into a single matrix multiplication!
	</p>
	<form style="margin-bottom: 6pt;">
	<input type="radio" name="transformation_type" id="radio_t"><label for="radio_t">Translation</label>&nbsp;&nbsp;
	<input type="radio" name="transformation_type" id="radio_r"><label for="radio_r">Rotation</label>&nbsp;&nbsp;
	<input type="radio" name="transformation_type" id="radio_s"><label for="radio_s">Scale</label>&nbsp;&nbsp;
	<input type="radio" name="transformation_type" id="radio_p" checked="true"><label for="radio_p">Projection</label><br>
	</form>
	<svg id="composable" width="600pt" height="480pt" viewBox="0 0 600 480" cursor="pointer" xmlns="http://www.w3.org/2000/svg">
	</svg>
	<div id="after_the_scale0" style="display:none;" class="fact">
		<h3>Hidden fact #4</h3>
		<p>
Forgot to tell you! These transformations are not necessarily revertable. For instance, when you scale your square into a segment by making one of the scales 0, you can't &ldquo;unscale&rdquo; it back anymore. Please use the revert button instead &darr;
		</p>
		<p>
Also, kudos for finding this out by yourself!
		</p>
		<p style="text-align: right;">
<span onclick="document.getElementById('after_the_scale0').style.display = 'none';" class="u">Hide the hidden fact</span>.
		</p>
	 </div>
	<table class="formula">
	<tr>
	<td class="open_matrix"></td>
	<td id="matrix_col1" style="width:64pt;">
1<br>0<br>0
	</td><td id="matrix_col2" style="width:64pt;">
0<br>1<br>0
	</td><td id="matrix_col3" style="width:64pt;">
0<br>0<br>1
	</td>
	<td class="close_matrix"></td>
	</tr>
	</table>

	<button class="button" id="revert_composable" onclick="revert_composable()"><nobr>&nbsp;Revert to E&nbsp;</nobr></button>
	<script language="JavaScript">
	init_composable();
	</script>
	<p>
This is particularly important because whatever you do: animation, image processing, physics simulation, you always want to do as little computation as possible. Composability allows you to squeeze a series of transformations into a single matrix multiplication which is in turn very super-scalar friendly. With matrices, not only do you do fewer calculations, you also benefit from vectorization both on CPU and GPU so you do them faster. Ultra-fast transformations everywhere!
	</p>
	<h2>
Conclusion
	</h2>
	<p>
Pragmatically, you can save a lot of processor time transforming points with one single matrix multiplication instead of applying all the transformations separately. And you can also write fewer lines of code by exploiting the common nature of all the transformations. But this is not the whole point yet.
	</p>
	<p>
Usually, we lose performance not because of some small computational inefficiencies but because of all the code that shouldn't be there in the first place. One time I made a piece of code run 200 times faster by simply replacing a transformation provided by the framework with a simple matrix multiplication on the spot. The original transformation was designed like this:
	</p>
	<pre>
Drawing.Drawing2D.Matrix.TransformPoints:
 &#x02520;Drawing.SafeNativeMethods.Gdip.ConvertPointToMemory,
 &#x02517;Drawing.SafeNativeMethods.Gdip.ConvertGPPOINTFArrayF:
   &#x02517;Drawing.UnsafeNativeMethods.PtrToStructure:
     &#x02520;Drawing.Internal.GPPOINTF..ctor,
     &#x02517;RuntimeType.CreateInstanceSlow:
       &#x02517;Runtime.InteropServices.Marshal.PtrToStructure.</pre>
	<p>
Conversions between identical structures, copying data with no good reason, constructors that do no essential work, — all of this costs time but gives nothing of value in return. The good news is, that all of this is also avoidable. It only occurs when programmers don’t understand and don’t trust the beauty of plain mathematics.
	</p>
	<p>
And I hope this page reveals some of that beauty. I hope it makes plain mathematics a little more trustworthy. Thank you!
	</p>


	<table class="footer" style="width: 600pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
	<tr>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
		<a href="index.html">Index</a>
		<a href="all_mathematics.html">#mathematics</a> <a href="all_tutorials.html">#tutorials</a>
	</td>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
		&nbsp;&larr; there's more.
	</td>
	<td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
			<nobr>+
		<a href="https://wordsandbuttons.online/SYTYKC.pdf">So You Think You Know C</a> <span style="color:#888; font-size: 12pt;">(free book)</span></nobr><br>
			<nobr>+
		<a href="https://www.amazon.com/Geometry-Programmers-Oleksandr-Kaleniuk/dp/1633439607">Geometry for Programmers</a> <span style="color:#888; font-size: 12pt;">(paid book)</span></nobr><br>
			+
		<a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &

		<a href="https://wordsandbuttons.online/rss.rss"><span style="letter-spacing: 1pt;">RSS</span></a>
	</td>
	</tr>
	</table>
	</center>
</body>
</html>
