<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
	<title>Rational interpolation</title>
	<meta name="description" content="Rational interpolation is a step forward from polynomial interpolation towards rational splines. With rational interpolation, you can build functions that run through a set of points and also have vertical asymptotes whenever you want. With this capability, you can now model functions like logarithms better.">
	<meta name="keywords" content="mathematics, demos">
	<link rel="shortcut icon" type="image/x-icon" href="favicon.svg" />
	<style>
body {
	margin: 12pt;
}

a {
	text-decoration: none;
}

a:link, a:visited {
	color: blue;
}

h1 {
	padding-top: 36pt;
	font-size: 24pt;
	width: 600pt;
	text-align: left;
}

h2 {
	padding-top: 20pt;
	font-size: 20pt;
	width: 600pt;
	text-align: left;
}

p {
	line-height: 1.42;
	font-size: 16pt;
	width: 600pt;
	text-align: left;
}

.formula {
	font-family: sans-serif;
	font-size: 15pt;
	font-style: italic;
	text-align: center;
	padding-top: 6pt;
	padding-bottom: 6pt;
}

.comment {
	font-size: 12pt;
	text-align: center;
	font-family: sans-serif;
	padding-bottom: 12pt;
}

form {
	margin: 0 0 0 0;
	padding-top: 12pt;
	padding-left: 12pt;
	padding-right: 12pt;
	padding-bottom: 12pt;
	font-size: 16pt;
	text-align: left;
	width: 600pt;
	background-color: #eeee99;
	color: #000;
}

button {
	width: 600pt;
	height: 26pt;
	font-size: 16pt;
	text-align: center;
}

input[type="radio"] {
	height: 16pt;
	width: 16pt;
	margin-top: 12pt;
}

label {
	font-size: 16pt;
}

.code {
	width: 600pt;
	text-align: left;
	font-size: 16pt;
	font-family: monospace;
	font-weight: bold;
}

canvas { touch-action: none; }
	</style>
	<script language="JavaScript">
function init_atan_plot(i_canvas, i_fs, i_colors, i_verticals, i_x, i_y, i_scale, i_do_atan, i_w, i_h, i_do_side_panel, i_do_cross, i_do_animations) {
	const w = i_w;
	const h = i_h;
	const panel_w = i_do_side_panel ? 158 : 0;
	var mousedown_sx;
	var mousedown_sy;
	var mousemove_sx;
	var mousemove_sy;

	const button_bg_color = "#e0e8b5";
	const button_color = "#161712";
	const button_high_color = "#838769";

	const buttons_x = w + 16;
	const buttons_h = 16;

	const x_y = 14;	var x_value = i_x;
	const y_y = 34;	var y_value = i_y;
	const reset_xy_y = 54;	var reset_xy_over = false;	var reset_xy_down = false;

	const scale_y = 94;	var scale_value = i_scale;
	const linear_scale_y = 114;	var linear_scale_over = false;	var linear_scale_down = false;	var linear_scale_checked = !i_do_atan;
	const atan_scale_y = 134;	var atan_scale_over = false;	var atan_scale_down = false;	var atan_scale_checked = i_do_atan;
	const scale_dec_y = 154;	var scale_dec_over = false;	var scale_dec_down = false;
	const scale_inc_y = 174;	var scale_inc_over = false;	var scale_inc_down = false;
	const reset_scale_y = 194;	var reset_scale_over = false;	var reset_scale_down = false;

	const snap_to_f_y = 234;	var snap_to_f_over = false;	var snap_to_f_down = false;

	function all_not_over() {
		linear_scale_over = false;
		atan_scale_over = false;
		scale_dec_over = false;
		scale_inc_over = false;
		reset_xy_over = false;
		reset_scale_over = false;
		snap_to_f_over = false;
	}

	function all_not_down() {
		linear_scale_down = false;
		atan_scale_down = false;
		scale_dec_down = false;
		scale_inc_down = false;
		reset_xy_down = false;
		reset_scale_down = false;
		snap_to_f_down = false;
	}

	function linear_real_to_screen (x, dx, scale, w) {
		return (w / 2) + ((x - dx) / scale) * (w / 2);
	}

	function linear_screen_to_real (x, dx, scale, w) {
		return ((x - (w / 2)) / (w / 2) * scale + dx);
	}

	function atan_real_to_screen (x, dx, scale, w) {
		return Math.atan((x - dx) / scale) / Math.PI * (w - 1.) + (w / 2);
	}

	function atan_screen_to_real (x, dx, scale, w) {
		return scale * Math.tan((x - (w / 2)) * Math.PI / (w - 1.)) + dx;
	}

	// returns 4 translation functions from/to screen and real coordinates
	function s2x_x2s_s2y_y2s(center_x, center_y, scale) {
		if(linear_scale_checked)
			return [
				function(i) {return linear_screen_to_real(i, x_value, scale_value, w);},
				function(x) {return linear_real_to_screen(x, x_value, scale_value, w);},
				function(i) {return linear_screen_to_real(h - i, y_value, scale_value, h);},
				function(y) {return h - linear_real_to_screen(y, y_value, scale_value, h);}
			];
		else
			return [
				function(i) {return atan_screen_to_real(i, x_value, scale_value, w);},
				function(x) {return atan_real_to_screen(x, x_value, scale_value, w);},
				function(i) {return atan_screen_to_real(h - i, y_value, scale_value, h);},
				function(y) {return h - atan_real_to_screen(y, y_value, scale_value, h);}
			];
	}

	i_canvas.width = w + panel_w;
	i_canvas.height = h;

	function draw_canvas() {
		function draw_arrow(context, x1, y1, x2, y2, color) {
			const d = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(y2-y1, 2));
			context.beginPath();
			context.moveTo(x1, y1);
			context.lineTo(x2, y2);
			context.moveTo(x2 - (y2 - y1) * 4.3 / d - (x2 - x1) * 16.7 / d, y2 - (y2 - y1) * 16.7 / d + (x2 - x1) * 4.3 / d);
			context.lineTo(x2, y2);
			context.moveTo(x2 + (y2 - y1) * 4.3 / d - (x2 - x1) * 16.7 / d, y2 - (y2 - y1) * 16.7 / d - (x2 - x1) * 4.3 / d);
			context.lineTo(x2, y2);
			context.strokeStyle = color;
			context.stroke();
			context.closePath();
		}
		var context = i_canvas.getContext("2d");

		// background
		context.fillStyle="#eeeeee";
		context.fillRect(0, 0, w, h);

		// translation functions
		const functions = s2x_x2s_s2y_y2s();
		const s2x = functions[0];
		const x2s = functions[1];
		const s2y = functions[2];
		const y2s = functions[3];

		// the grid
		const scale = scale_value;
		const step = scale < 16 ? 1 : Math.floor(scale / 8);
		const stepped = function(x) {return Math.floor(x / step) * step;}

		context.beginPath();
		context.setLineDash([2, 3]);
		if(linear_scale_checked) {
			// horizontal
			for(var j = stepped(s2x(0)); j <= stepped(s2x(w)); j += step) {
				if(j != 0) {
					context.moveTo(sharp(x2s(j)), 0);
					context.lineTo(sharp(x2s(j)), h);
				}
			}
			// vertical
			for(var i = stepped(s2y(h)); i <= stepped(s2y(0)); i += step) {
				if(i != 0) {
					context.moveTo(0, sharp(y2s(i)));
					context.lineTo(w, sharp(y2s(i)));
				}
			}
		} else if(atan_scale_checked) {
			// horizontal
			const x_from = s2x(20);
			const x_to = s2x(w-20);
			for(var i = Math.sign(x_from) * Math.floor(Math.log2(Math.abs(x_from))) - 1; i <= Math.sign(x_to) * Math.ceil(Math.log2(Math.abs(x_to))); ++i) {
				if(i == 0)
					continue;
				const x_i = Math.sign(i) * Math.pow(2, Math.abs(i) - 1);
				context.moveTo(sharp(x2s(x_i)), 0);
				context.lineTo(sharp(x2s(x_i)), h);
			}
			// vertical
			const y_from = s2y(20);
			const y_to = s2y(h-20);
			for(var i = Math.sign(y_from) * Math.floor(Math.log2(Math.abs(y_from))) - 1; i <= Math.sign(y_to) * Math.ceil(Math.log2(Math.abs(y_to))); ++i) {
				if(i == 0)
					continue;
				const y_i = Math.sign(i) * Math.pow(2, Math.abs(i) - 1);
				context.moveTo(0, sharp(y2s(y_i)));
				context.lineTo(w, sharp(y2s(y_i)));
			}
		}
		context.strokeStyle = "#AAA";
		context.lineWidth = 1;
		context.stroke();
		context.setLineDash([]);
		context.closePath();

		// verticals
		context.strokeStyle = "#333";
		context.lineWidth = 1;
		context.setLineDash([4, 4]);
		for(var i = 0; i < i_verticals.length; ++i) {
			context.beginPath();
			context.moveTo(sharp(x2s(i_verticals[i])), 0);
			context.lineTo(sharp(x2s(i_verticals[i])), h+1);
			context.stroke();
			context.closePath();
		}
		context.setLineDash([]);


		// axis lines (come before functions for better readability)
		context.font = "14px Arial";
		context.fillStyle = "#444444";
		context.textAlign = "center";
		context.textBaseline = "middle";
		context.strokeStyle = "#000000";
		context.lineWidth = 1;
		context.beginPath();
		if(linear_scale_checked) {
			draw_arrow(context, 0, sharp(y2s(0)), w, sharp(y2s(0)), "#000000");
			draw_arrow(context, sharp(x2s(0)), h, sharp(x2s(0)), 0, "#000000");
		} else {
			context.moveTo(20.5, sharp(y2s(0)));
			context.lineTo(w - 20.5, sharp(y2s(0)));
			context.moveTo(sharp(x2s(0)), h - 20.5);
			context.lineTo(sharp(x2s(0)), 20.5);
			context.stroke();
			context.closePath();

			context.beginPath();
			context.setLineDash([3, 2]);
			context.moveTo(20.5, sharp(y2s(0)));
			context.lineTo(-0.5, sharp(y2s(0)));
			context.moveTo(w - 20.5, sharp(y2s(0)));
			context.lineTo(w + 0.5, sharp(y2s(0)));
			context.moveTo(sharp(x2s(0)), h - 20.5);
			context.lineTo(sharp(x2s(0)), h + 0.5);
			context.moveTo(sharp(x2s(0)), 20.5);
			context.lineTo(sharp(x2s(0)), -0.5);
			context.stroke();
			context.closePath();
			context.setLineDash([]);
		}

		// functions
		for(var i = 0; i < i_fs.length; ++i) {
			const f = i_fs[i];
			const color = i_colors[i];
			// draw
			context.beginPath();
			var the_gap = true;
			var old_i;
			for(var j = -0.5 + atan_scale_checked; j < w + 0.5 - atan_scale_checked; j += 2.) {
				const x = s2x(j);
				const y = f(x);
				const i = y2s(y);
				if(the_gap) {
					context.moveTo(j, i)
					the_gap = false;
				} else {
					if(Math.abs(i - old_i) >= h)
						the_gap = true;
					else
						context.lineTo(j, i);
				}
				old_i = i;
			}
			context.strokeStyle = color;
			context.lineWidth = 1.5;
			context.stroke();
			context.closePath();
		}


		// the grid
		function sharp(x) {return Math.floor(x) + 0.5;}
		context.font = "14px Arial";
		context.fillStyle = "#444444";
		context.textAlign = "center";
		context.textBaseline = "middle";
		context.strokeStyle = "#000000";
		context.lineWidth = 1;
		context.beginPath();
		if(linear_scale_checked) {
			// horizontal
			for(var j = stepped(s2x(0)); j <= stepped(s2x(w)); j += step) {
				if(j != 0) {
					context.moveTo(sharp(x2s(j)), sharp(y2s(0)) + 2);
					context.lineTo(sharp(x2s(j)), sharp(y2s(0)) - 2);
				}
				context.fillText(j, sharp(x2s(j)) + 12, sharp(y2s(0)) - 12);
			}
			// vertical
			for(var i = stepped(s2y(h)); i <= stepped(s2y(0)); i += step) {
				if(i != 0) {
					context.moveTo(sharp(x2s(0)) - 2, sharp(y2s(i)));
					context.lineTo(sharp(x2s(0)) + 2, sharp(y2s(i)));
					context.fillText(i, sharp(x2s(0)) + 12, sharp(y2s(i)) - 12);
				}
			}
		} else if(atan_scale_checked) {
			// horizontal
			const x_from = s2x(20);
			const x_to = s2x(w-20);
			for(var i = Math.sign(x_from) * Math.floor(Math.log2(Math.abs(x_from))) - 1; i <= Math.sign(x_to) * Math.ceil(Math.log2(Math.abs(x_to))); ++i) {
				if(i == 0)
					continue;
				const x_i = Math.sign(i) * Math.pow(2, Math.abs(i) - 1);
				context.moveTo(sharp(x2s(x_i)), sharp(y2s(0)) + 2);
				context.lineTo(sharp(x2s(x_i)), sharp(y2s(0)) - 2);
				const to_print = (i < 0) ? "-" + String(Math.pow(2, Math.abs(i+1))) : String(Math.pow(2, i-1));
				if(i % 2 == 0)
					context.fillText(to_print, sharp(x2s(x_i)), sharp(y2s(0)) - 12);
				else
					context.fillText(to_print, sharp(x2s(x_i)), sharp(y2s(0)) + 12);
			}
			// vertical
			const y_from = s2y(h-20);
			const y_to = s2y(20);
			for(var i = Math.sign(y_from) * Math.floor(Math.log2(Math.abs(y_from))) - 1; i <= Math.sign(y_to) * Math.ceil(Math.log2(Math.abs(y_to))); ++i) {
				if(i == 0)
					continue;
				const y_i = Math.sign(i) * Math.pow(2, Math.abs(i) - 1);
				context.moveTo(sharp(x2s(0)) + 2, sharp(y2s(y_i)));
				context.lineTo(sharp(x2s(0)) - 2, sharp(y2s(y_i)));
				const to_print = (i < 0) ? "-" + String(Math.pow(2, Math.abs(i+1))) : String(Math.pow(2, i-1));
				if(i % 2 == 0)
					context.fillText(to_print, sharp(x2s(0)) - 12, sharp(y2s(y_i)) - 12);
				else
					context.fillText(to_print, sharp(x2s(0)) + 12, sharp(y2s(y_i)) + 12);
			}
		}
		context.stroke();
		context.closePath();


		// cross
		if(i_do_cross && (x2s(0) != w/2 || y2s(0) != h/2)) {
			context.beginPath();
			context.moveTo(sharp(w/2) - 14.5, sharp(h/2));
			context.lineTo(sharp(w/2) + 14.5, sharp(h/2));
			context.moveTo(sharp(w/2), sharp(h/2) - 14.5);
			context.lineTo(sharp(w/2), sharp(h/2) + 14.5);
			context.strokeStyle = "#222222";
			context.lineWidth = 1;
			context.stroke();
			context.closePath();
		}

		// side panel
		if(i_do_side_panel) {
			context.fillStyle = button_bg_color;
			context.fillRect(w, 0, panel_w, h);

			context.font = "14px monospace";
			context.textAlign = "left";
			context.textBaseline = "top";
			context.strokeStyle = "#000000";
			context.lineWidth = 1;

			context.fillStyle = button_color;
			context.fillText("x: " + (x_value >= 0 ? '+' : '') + x_value.toFixed(5), buttons_x, x_y);
			context.fillText("y: " + (y_value >= 0 ? '+' : '') + y_value.toFixed(5), buttons_x, y_y);

			context.fillStyle = linear_scale_over ? button_high_color :button_color;
			context.fillText(linear_scale_checked ? "(*) linear" : "( ) linear", buttons_x + linear_scale_down, linear_scale_y + linear_scale_down);
			context.fillStyle = atan_scale_over ? button_high_color : button_color;
			context.fillText(atan_scale_checked ? "(*) atan" : "( ) atan", buttons_x + atan_scale_down, atan_scale_y + atan_scale_down);

			context.fillStyle = scale_dec_over ? button_high_color : button_color;
			context.fillText("[ scale / 2 ]", buttons_x + scale_dec_down, scale_dec_y + scale_dec_down);
			context.fillStyle = "#444444";
			context.fillText("scale: " + scale.toFixed(3), buttons_x, scale_y);
			context.fillStyle = scale_inc_over ? button_high_color : button_color;
			context.fillText("[ scale * 2 ]", buttons_x + scale_inc_down, scale_inc_y + scale_inc_down);

			context.fillStyle = reset_xy_over ? button_high_color : button_color;
			context.fillText("[ reset x,y ]", buttons_x + reset_xy_down, reset_xy_y + reset_xy_down);
			context.fillStyle = reset_scale_over ? button_high_color : button_color;
			context.fillText("[reset scale]", buttons_x + reset_scale_down, reset_scale_y + reset_scale_down);
			context.fillStyle = snap_to_f_over ? button_high_color : button_color;
			context.fillText("[ snap to f ]", buttons_x + snap_to_f_down, snap_to_f_y + snap_to_f_down);
		}
	}

	function snap_focus_to_nearest() {
		// translation
		const functions = s2x_x2s_s2y_y2s();
		const s2x = functions[0];
		const x2s = functions[1];
		const s2y = functions[2];
		const y2s = functions[3];
		const x0 = s2x(w / 2);
		const y0 = s2y(h / 2);
		var y = null;
		// function
		for(var i = 0; i < i_fs.length; ++i) {
			try {
				if(!y || Math.abs(i_fs[i](x0) - y0) < Math.abs(y - y0))
					y = i_fs[i](x0);
			} catch (error) {
				y = 0;
			}
		}
		y_value = y;
		draw_canvas();
	}

	i_canvas.addEventListener('click', function(e) {
		const canvas_rect = i_canvas.getBoundingClientRect();
		const sx = e.clientX - canvas_rect.left;
		const sy = e.clientY - canvas_rect.top;
		if(sx >= w) {
			if(sy >= linear_scale_y && sy < linear_scale_y + buttons_h) {
				linear_scale_checked = true;
				atan_scale_checked = false;
			}
			if(sy >= atan_scale_y && sy < atan_scale_y + buttons_h) {
				linear_scale_checked = false;
				atan_scale_checked = true;
			}
			if(sy >= scale_dec_y && sy < scale_dec_y + buttons_h)
				scale_value /= 4.;
			if(sy >= scale_inc_y && sy < scale_inc_y + buttons_h)
				scale_value *= 4.;
			if(sy >= reset_xy_y && sy < reset_xy_y + buttons_h) {
				x_value = i_x;
				y_value = i_y;
			}
			if(sy >= reset_scale_y && sy < reset_scale_y + buttons_h)
				scale_value = i_scale;
			if(sy >= snap_to_f_y && sy < snap_to_f_y + buttons_h)
				snap_focus_to_nearest();
			draw_canvas();
		} else if(mousedown_sx == mousemove_sx && mousedown_sy == mousemove_sy) {
			const functions = s2x_x2s_s2y_y2s();
			const s2x = functions[0];
			const s2y = functions[2];
			x_value = s2x(sx);
			y_value = s2y(sy);
			draw_canvas();
		}
	}, false);

	i_canvas.addEventListener('dblclick', function(e) {
		x_value = i_x;
		y_value = i_y;
		scale_value = i_scale;
		draw_canvas();
	}, false);

	i_canvas.addEventListener('pointermove', function(e) {
		const canvas_rect = i_canvas.getBoundingClientRect();
		const sx = e.clientX - canvas_rect.left;
		const sy = e.clientY - canvas_rect.top;
		all_not_over();
		if(sx >= w) {
			if(sy >= linear_scale_y && sy < linear_scale_y + buttons_h)
				linear_scale_over = true;
			if(sy >= atan_scale_y && sy < atan_scale_y + buttons_h)
				atan_scale_over = true;
			if(sy >= scale_dec_y && sy < scale_dec_y + buttons_h)
				scale_dec_over = true;
			if(sy >= scale_inc_y && sy < scale_inc_y + buttons_h)
				scale_inc_over = true;
			if(sy >= reset_xy_y && sy < reset_xy_y + buttons_h)
				reset_xy_over = true;
			if(sy >= reset_scale_y && sy < reset_scale_y + buttons_h)
				reset_scale_over = true;
			if(sy >= snap_to_f_y && sy < snap_to_f_y + buttons_h)
				snap_to_f_over = true;
		} else if(e.buttons == 1) {
			all_not_over();
			all_not_down();
			const cx = w/2 - (sx - mousemove_sx);
			const cy = h/2 - (sy - mousemove_sy);
			const functions = s2x_x2s_s2y_y2s();
			const s2x = functions[0];
			const s2y = functions[2];
			x_value = s2x(cx);
			y_value = s2y(cy);
			mousemove_sx = sx;
			mousemove_sy = sy;
		}
		draw_canvas();
	}, false);

	i_canvas.addEventListener('pointerdown', function(e) {
		const canvas_rect = i_canvas.getBoundingClientRect();
		const sx = e.clientX - canvas_rect.left;
		const sy = e.clientY - canvas_rect.top;
		if(sx >= w) {
			all_not_down();
			if(sy >= linear_scale_y && sy < linear_scale_y + buttons_h)
				linear_scale_down = true;
			if(sy >= atan_scale_y && sy < atan_scale_y + buttons_h)
				atan_scale_down = true;
			if(sy >= scale_dec_y && sy < scale_dec_y + buttons_h)
				scale_dec_down = true;
			if(sy >= scale_inc_y && sy < scale_inc_y + buttons_h)
				scale_inc_down = true;
			if(sy >= reset_xy_y && sy < reset_xy_y + buttons_h)
				reset_xy_down = true;
			if(sy >= reset_scale_y && sy < reset_scale_y + buttons_h)
				reset_scale_down = true;
			if(sy >= snap_to_f_y && sy < snap_to_f_y + buttons_h)
				snap_to_f_down = true;
			draw_canvas();
		}
		mousedown_sx = sx;
		mousedown_sy = sy;
		mousemove_sx = mousedown_sx;
		mousemove_sy = mousedown_sy;
		i_canvas.releasePointerCapture(e.pointerId);
	}, false);

	i_canvas.addEventListener('pointerup', function(e) {
		all_not_down();
		draw_canvas();
	}, false);

	i_canvas.addEventListener('pointerleave', function(e) {
		all_not_over();
		all_not_down();
		draw_canvas();
	}, false);

	i_canvas.addEventListener('wheel', function(e) {
		const canvas_rect = i_canvas.getBoundingClientRect();
		const sx = e.clientX - canvas_rect.left;
		if(sx >= w)
			return;
		if(e.shiftKey) {
			if(e.deltaY < 0)
				scale_value /= 2;
			else
				scale_value *= 2;
			draw_canvas();
		}
	}, false);

	function redraw() {
		draw_canvas();
		setTimeout(redraw, 20);
	}
	if(i_do_animations)
		redraw();
	else
		draw_canvas();
}

var w = 640.0;
var h = 640.0;

var points_for_interpolation = [];


function nearest_i(xy, points) {
	var best_i = 0;
	var best_d = Math.pow((xy[0]-points[0][0]), 2) + Math.pow((xy[1]-points[0][1]), 2);
	for(var i = 1; i < points.length; ++i) {
		const d = Math.pow((xy[0]-points[i][0]), 2) + Math.pow((xy[1]-points[i][1]), 2);
		if(d < best_d) {
			best_d = d;
			best_i = i;
		}
	}
	return best_i;
}

// alrorithms
function sign_0_positive(x){ // Math.sign like with no 0 option
	if(x >= 0)
		return 1.0;
	return -1.0;
}

function underflow_padded(x){
	if(Math.abs(x) < 1.e-5) // pixel-size input error is ok, so we don't want much precision anyway
		return 1.e-5 * sign_0_positive(x);
	return x;
}

function solved_linear(A, B, n){
	var X = [];
	for (var i = 0; i < n; ++i)
		X.push(0.0);

	// triangulize
	for (var i = 0; i < n-1; ++i)
		for (var j = 0; j < i+1; ++j) {
			r = A[i+1][j] / underflow_padded(A[j][j]);
			A[i+1][j] = 0.;
			for (var b_j = j+1; b_j < n; ++b_j){
				A[i+1][b_j] -= A[j][b_j]*r;
			}
			B[i+1] -= B[j]*r;
		}

	// calculate xs
	X[n-1] = B[n-1] / underflow_padded(A[n-1][n-1]);
	for (var i = n-2; i >= 0; --i){
		var s = 0.0;
		for (var j = i; j < n; ++j){
			s = s + A[i][j]*X[j];
		}
		X[i] = (B[i] - s) / underflow_padded(A[i][i]);
	}
	return X;
}


function interpolation_of(points) {
	const N = points.length;
	const M1 = Math.floor(N/2) + 1;
	const M2 = N - M1;
	var A = [];
	var B = [];

	for (var i = 0; i < N; ++i){
		var Ai = []
		for (var j = 0; j < M1; ++j){
			Ai.push(Math.pow(points[i][0], j));
		}
		for (var j = 0; j < M2; ++j){
			Ai.push(-Math.pow(points[i][0], j+1) * points[i][1]);
		}
		A.push(Ai);
		B.push(points[i][1]);
	}
	var P = solved_linear(A, B, N);
	return function(x) {
		var n = 0;
		for(var i = 0; i < M1; ++i) {
			n += P[i] * Math.pow(x, i);
		}
		var d = 1;
		for(var i = 0; i < M2; ++i) {
			d += P[i+M1] * Math.pow(x, i+1);
		}
		return n/d;
	};
}

var interpolation_i = 0;
function init_interpolation_canvas(){
	var canvas = document.getElementById("interpolation_canvas");
	canvas.addEventListener('pointerdown', function(e){
		canvas_rect = canvas.getBoundingClientRect();
		const xy = [e.clientX - canvas_rect.left, e.clientY - canvas_rect.top];
		if(document.getElementById("i_1").checked) { // add
			points_for_interpolation.push(xy);
			interpolation_i = points_for_interpolation.length-1;
		} else { // move
			interpolation_i = nearest_i(xy, points_for_interpolation);
			points_for_interpolation[interpolation_i] = xy;
		}
		draw_canvas("interpolation_canvas");
		canvas.releasePointerCapture(e.pointerId);
	}, false);

	canvas.addEventListener('pointermove', function(e){
		if(e.buttons == 1){
			canvas_rect = canvas.getBoundingClientRect();
			points_for_interpolation[interpolation_i] = [e.clientX - canvas_rect.left, e.clientY - canvas_rect.top];
			draw_canvas("interpolation_canvas");
		}
	}, false);

	canvas.addEventListener('pointerup', function(e){
		canvas_rect = canvas.getBoundingClientRect();
		points_for_interpolation[interpolation_i] = [e.clientX - canvas_rect.left, e.clientY - canvas_rect.top];
		draw_canvas("interpolation_canvas");
	}, false);

	draw_canvas("interpolation_canvas");
}

function draw_canvas(canvas_name){
	var canvas = document.getElementById(canvas_name);
	var context = canvas.getContext("2d");
	context.font = "16px sans-serif";
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);


	var points = [];
	if(canvas_name == "approximation_canvas") {
		points = points_for_approximation;
	} else if(canvas_name == "interpolation_canvas") {
		points = points_for_interpolation;
	} else if(canvas_name == "both_canvas") {
		points = points_for_both;
	}

	context.lineWidth = 2;

	// draw interpolation
	if(canvas_name == "interpolation_canvas") {
		const eps = 1e-5;
		if(points.length > 0) {
			var polynomial = interpolation_of(points);

			context.beginPath();
			for(var j = 0; j < w; ++j){
				x = j;
				y = polynomial(x);
				dy = (polynomial(x+eps) - polynomial(x)) / eps;
				yn = polynomial(x + 1);
				if(j == 0)
					context.moveTo(x, y);
				else
					if(Math.abs(dy) > 1 && dy > 0 && yn < y) {
						context.lineTo(x, 640);
						context.moveTo(x, 0);
					} else if(Math.abs(dy) > 1 && dy < 0 && yn > y) {
						context.lineTo(x, 0);
						context.moveTo(x, 640);
					} else
						context.lineTo(x, y);
			}
			context.strokeStyle="#457fd6";
			context.stroke();
			context.closePath();
		}
	}


	context.lineWidth = 1;

	// points
	for (var i = 0; i < points.length; ++i) {
		if(canvas_name == "approximation_canvas") {
			context.fillStyle="#d64562";
		} else if(canvas_name == "interpolation_canvas") {
			context.fillStyle="#457fd6";
		} else if(canvas_name == "both_canvas") {
			if(i < ips)
				context.fillStyle="#457fd6";
			else
				context.fillStyle="#d64562";
		}
		context.beginPath();
		context.arc(points[i][0], points[i][1], 4, 0, 2*Math.PI);
		context.fill();
		context.closePath();
	}

	const N = Math.floor(points.length/2) + 1;
	const D = points.length - N;
	var numerator = 'a<sub>0</sub>';
	for(var i = 1; i < N; ++i) {
		if(i == 1)
			numerator = 'a<sub>1</sub>x + '+ numerator;
		else
			numerator = 'a<sub>' + i + '</sub>x<sup>' + i + '</sup> + ' + numerator;
	}
	var denominator = '';
	for(var i = 1; i < D+1; ++i) {
		if(i == 1)
			denominator = 'b<sub>1</sub>x'+ denominator;
		else
			denominator = 'b<sub>' + i + '</sub>x<sup>' + i + '</sup> + ' + denominator;
	}
	var table = "<table class='formula'><tr><td rowspan=2>R(x) = &nbsp;</td>";
	if(D > 0) {
		table += "<td style='border-bottom: 1px solid black'>" + numerator;
		table += "</td></tr><tr><td>" + denominator;
	} else {
		table += "<td rowspan=2>" + numerator;
	}
	table += "</td></tr></table>";
	document.getElementById("interpolation_formula").innerHTML = table;
}

// under
function reset_all_for_interpolation() {
	points_for_interpolation =
	[[37,195],[135.5,489.8666687011719],[325.5,400.8666687011719],[354.5,538.8666687011719],[465.5,391.8666687011719],[582.5,167.86666870117188]];
	interpolation_i = 0;
	draw_canvas("interpolation_canvas");
}

function undo_last_for_interpolation() {
	if(points_for_interpolation.length > 1)
		points_for_interpolation.splice(-1,1);
	draw_canvas("interpolation_canvas");
}

function colorized(text) {
	const separators = ['def ', ' for ', ' else', ' if ', ' break', 'return', 'class ', ' in ', 'global ',
		'\n', ' ', '\t', '.', ',', ':', '=', '[', ']', '(', ')', '+', '-', '*', '/'];
	const quotes = ['\'', '"'];
	const comments = [['#', '\n']];

	function painted_in(line, color) {
		return line.length == 0 ? "" : "<span style=\"color:#" + color + "\">" + line + "</span>";
	}

	function colorized(token) {
		var code_sum = 0;
		for(var i = 0; i < token.length; ++i)
			code_sum += ([1, 7, 11, 13][i % 4] * token.charCodeAt(i));
		var zero_channel = code_sum % 3;
		var color = '' + (zero_channel == 0 ? '3' : '') + (1 + (code_sum % 5) * 2)
			+ (zero_channel == 1 ? '3' : '') + (4 + (code_sum % 2) * 5)
			+ (zero_channel == 2 ? '3' : '');
		return painted_in(token, color);
	}

	function separated(line, i) {
		if(i == separators.length)
			return colorized(line);
		return line.split(separators[i]).map(function(subline) {
			return separated(subline, i + 1);}).join(separators[i]);
	}

	function unquoted(line, i) {
		if(i == quotes.length)
			return separated(line, 0);
		var chunk_no = 0;
		return line.split('\\' + quotes[i]).join('\0').split(quotes[i]).map(function (chunk) {
			return chunk.split('\0').join('\\' + quotes[i]);}).map(function (chunk) {
				return ++chunk_no % 2  == 1 ? unquoted(chunk, i + 1) : painted_in(quotes[i] + chunk + quotes[i], "555");}).join('');
	}

	function uncommented(line, i) {
		if(i == comments.length)
			return unquoted(line, 0);
		var chunks = line.split(comments[i][0]);
		return uncommented(chunks[0], i + 1) + chunks.slice(1).map( function(chunk) {
			var in_out_comment = chunk.split(comments[i][1]);
			return painted_in(comments[i][0] + in_out_comment[0] + (in_out_comment.length > 1 ? comments[i][1] : ''), "555")
				+ uncommented(in_out_comment.slice(1).join(comments[i][1]), i + 1);}).join('');
	}

	return uncommented(text, 0);
}
	</script>
</head>
<body>
	<center>
	<p style="width: 600pt; padding: 36pt 0pt 64pt 0pt;">This is <a href="index.html">Words and Buttons Online</a> — a collection of&nbsp;interactive <a href="all_tutorials.html">#tutorials</a>, <a href="all_demos.html">#demos<a/>, and <a href="all_quizzes.html">#quizzes</a> about <a href="all_mathematics.html">#mathematics</a>, <a href="all_algorithms.html">#algorithms</a> and <a href="all_programming.html">#programming</a>.</p>
	<h1>
<span id="index_rational_interpolation">Rational interpolation</span>
	</h1>
	<p>
Let’s presume you already know how polynomial interpolation works and how polynomials behave globally. If not, please see <a href="https://wordsandbuttons.online/polynomial_approximation_and_interpolation.html">Polynomial approximation and interpolation</a> and <a href="https://wordsandbuttons.online/trippy_polynomials_in_arctangent_scale.html">Trippy polynomials in arctangent scale</a>.
	</p>
	<p>
In “trippy polynomials”, there was an argument that while you can model continuous functions with polynomials locally, so on some specific interval with no discontinuities, modeling some functions globally, so on the whole numeric range is simply impossible due to the limited nature of polynomials themselves.
	</p>
	<p>
For instance, in computing, we normally model the sine function with a polynomial but only in the <span class="formula">[0, &pi;/2]</span> range. Then we use special formulas to replicate the model and make it periodic. Why do we have to do that? Because polynomials are not periodic. Sine is infinitely differentiable, it can have therefore afford infinite extremums, and polynomials are finite, they can not.
	</p>
	<p>
Another example is a logarithm function. We can build an approximation for a logarithm on any interval in <span class="formula">(0, &infin;]</span>. But not in 0. Logarithm has a vertical asymptote in 0, polynomials, by their nature, don’t have any.
	</p>
	<p>
We can’t do much about the first problem, besides, it’s not that much of a problem to begin with, but we can still model functions with asymptotes by going just one step away from polynomial interpolation and adopting a rational one.
	</p>
	<p>
The name “rational” comes from ratio. The formula we’re going to use to model things is a ratio of two polynomials.
	</p>
	<table class='formula'><tr><td rowspan=2>R(x) = &nbsp;</td><td style='border-bottom: 1px solid black'>P<sub>1</sub>(x)</td></tr><tr><td>P<sub>2</sub>(x)</td></tr></table>
	<p>
We already know how to build a <href="https://wordsandbuttons.online/polynomial_approximation_and_interpolation.html#index_polynomial_interpolation">polynomial that goes through N points</a>, but how do we do that with rational functions?
	</p>
	<p>
Well, ambiguously. Normally, there is only one polynomial of N-1 degree that goes through N points, but with rational interpolation, there are N-1 configurations too. E. g. for a set of four points, there could only be one cubic polynomial of 3rd degree:
	</p>
	<p class="formula">
P(x) = ax<sup>3</sup> + bx<sup>2</sup> +cx + d
	</p>
	<p>
But for the same four point rational interpolation, there are already 4 diffrent minimal degree configurations with of rational functions:
	</p>
	<table class='formula'><tr><td rowspan=2>R(x) = &nbsp;</td><td style='border-bottom: 1px solid black'>ax<sup>2</sup> + bx + c</td></tr><tr><td>d</td></tr></table>
	<table class='formula'><tr><td rowspan=2>R(x) = &nbsp;</td><td style='border-bottom: 1px solid black'>ax + b</td></tr><tr><td>cx + d</td></tr></table>
	<table class='formula'><tr><td rowspan=2>R(x) = &nbsp;</td><td style='border-bottom: 1px solid black'>a</td></tr><tr><td>bx<sup>2</sup> + cx + d</td></tr></table>
	<table class='formula'><tr><td rowspan=2>R(x) = &nbsp;</td><td style='border-bottom: 1px solid black'>1</td></tr><tr><td>ax<sup>3</sup> + bx<sup>2</sup> +cx + d</td></tr></table>
	</p>
	<p>
I’m saying “minimal degree configurations” because technically, this is a rational function too:
	</p>
	<table class='formula'><tr><td rowspan=2>R(x) = &nbsp;</td>
	<td style='border-bottom: 1px solid black'>ax<sup>234</sup> + b<sup>123</sup></td></tr><tr><td>cx<sup>456</sup> + d<sup>345</sup></td></tr></table>
	<p>
And it’s obviously different from:
	</p>
	<table class='formula'><tr><td rowspan=2>R(x) = &nbsp;</td><td style='border-bottom: 1px solid black'>ax + b</td></tr><tr><td>cx + d</td></tr></table>
	<p>
Althoguh they can both interpolate 4 points.
	</p>
	<p>
For all the configurations, the method of obtaining coefficients is essentially the same. Remember what we did to get an interpolating polynomial? We put input points into the polynomial creating a system of equations, and then used a linear solver on it. We can do the same here.
	</p>
	<p>
For instance, for a four-point set <span class="formula">(x<sub>i</sub>, y<sub>i</sub>)</span> and the 2-by-2 minimal degree configuration, the equations would be:
	</p>
	<table class='formula'><tr><td style='border-bottom: 1px solid black'>ax<sub>1</sub> + b</td><td rowspan=2>&nbsp;= y<sub>1</sub></td></tr><tr><td>cx<sub>1</sub> + d</td></tr></table>
	<table class='formula'><tr><td style='border-bottom: 1px solid black'>ax<sub>2</sub> + b</td><td rowspan=2>&nbsp;= y<sub>2</sub></td></tr><tr><td>cx<sub>2</sub> + d</td></tr></table>
	<table class='formula'><tr><td style='border-bottom: 1px solid black'>ax<sub>3</sub> + b</td><td rowspan=2>&nbsp;= y<sub>3</sub></td></tr><tr><td>cx<sub>3</sub> + d</td></tr></table>
	<table class='formula'><tr><td style='border-bottom: 1px solid black'>ax<sub>4</sub> + b</td><td rowspan=2>&nbsp;= y<sub>4</sub></td></tr><tr><td>cx<sub>4</sub> + d</td></tr></table>
	<p>
But wait, you can say, these are not linear. Ah! Yes, not yet. But wait until we multiply both sides of every equation by <span class="formula">(cx<sub>i</sub> + d)</span> where <span class="formula">(cx<sub>i</sub> + d) &ne; 0</span>.
	</p>
	<p class="formula">
ax<sub>1</sub> + b = y<sub>1</sub> (cx<sub>1</sub> + d)
	</p>
	<p class="formula">
ax<sub>2</sub> + b = y<sub>2</sub> (cx<sub>2</sub> + d)
	</p>
	<p class="formula">
ax<sub>3</sub> + b = y<sub>3</sub> (cx<sub>3</sub> + d)
	</p>
	<p class="formula">
ax<sub>4</sub> + b = y<sub>4</sub> (cx<sub>4</sub> + d)
	</p>
	<p>
Then we expand and move the expressions to a single side of the equations so, for instance,
	</p>
	<p class="formula">
ax<sub>1</sub> + b = y<sub>1</sub> (cx<sub>1</sub> + d)
	</p>
	<p>
becomes
	</p>
	<p class="formula">
ax<sub>1</sub> + b = y<sub>1</sub>cx<sub>1</sub> + y<sub>1</sub>d
	</p>
	<p>
and then
	</p>
	<p class="formula">
ax<sub>1</sub> + b - y<sub>1</sub>cx<sub>1</sub> - y<sub>1</sub>d = 0
	</p>
	<p>
This doesn’t look like a linear equation at first sight still, but remember, we’re hunting <span class="formula">a</span>, <span class="formula">b</span>, <span class="formula">c</span>, and <span class="formula">d</span> here. The <span class="formula">x<sub>i</sub></span> and <span class="formula">y<sub>i</sub></span> are our input data. So when we put our equations together, we'll get a system of linear equations after all:
	</p>
	<p class="formula">
ax<sub>1</sub> + b - y<sub>1</sub>cx<sub>1</sub> - y<sub>1</sub>d = 0
	</p>
	<p class="formula">
ax<sub>2</sub> + b - y<sub>2</sub>cx<sub>2</sub> - y<sub>2</sub>d = 0
	</p>
	<p class="formula">
ax<sub>3</sub> + b - y<sub>3</sub>cx<sub>3</sub> - y<sub>3</sub>d = 0
	</p>
	<p class="formula">
ax<sub>4</sub> + b - y<sub>4</sub>cx<sub>4</sub> - y<sub>4</sub>d = 0
	</p>
	<p>
We can totally solve that with a linear solver.
	</p>
	<p>
On the interactive plot below, you can add or move points to familiarize yourself with how rational interpolation feels like:
	</p>
	<canvas id="interpolation_canvas" width=640 height=640></canvas>
	<div style="text-align:center; padding-bottom:12pt;">
		<input type="radio" name="ipol" id="i_1" value="Add" /><label for="i_1">Add a point;</label> &nbsp;
		<input type="radio" name="ipol" id="i_2" checked value="Move"><label for="i_2">move a point.</label> &nbsp;
		<button type="button" style="width: 180pt;" onclick="undo_last_for_interpolation()">Remove last point</button>
		<button type="button" style="width: 120pt;" onclick="reset_all_for_interpolation()">Reset all</button>
	</div>
	<div id="interpolation_formula">
	</div>

	<script language="JavaScript">
	reset_all_for_interpolation();
	init_interpolation_canvas();
	</script>
	<p>
Now for a more practical task. Or the one that looks practical anyway. Let’s model a <span class="formula">log<sub>2</sub>(x)</span> function.
	</p>
	<p>
Logarithm base 2 is a function that for every positive argument y, returns x so <span class="formula">2<sup>x</sup> = y</span>.
	</p>
	<p class="formula">
log<sub>2</sub>(1) = 0
	</p>
	<p class="formula">
log<sub>2</sub>(2) = 1
	</p>
	<p class="formula">
log<sub>2</sub>(4) = 2
	</p>
	<p class="formula">
log<sub>2</sub>(8) = 3
	</p>
	<p class="formula">
.&nbsp;&nbsp;.&nbsp;&nbsp;.
	</p>
	<p class="formula">
log<sub>2</sub>(65536) = 16
	</p>
	<p class="formula">
.&nbsp;&nbsp;.&nbsp;&nbsp;.
	</p>
	<p>
We can, of course, use the Taylor series to model this function in some range with a polynomial, but <span class="formula">log<sub>2</sub>(x)</span> isn’t defined for <span class="formula">x &le; 0</span>. Moreover, it has an asymptote in 0 meaning that the function falls indefinitely into minus infinity as we come closer and closer to 0. We can’t possibly model this effect with a polynomial.
	</p>
	<p>
However, with rational interpolation, this would be easy. A vertical asymptote occurs when the denominator of the fraction is 0. And the denominator is zero when the polynomial representing the denominator has a root.
	</p>
	<p>
For a simple <span class="formula">log<sub>2</sub>(x)</span> model, we can use this ratio:
	</p>
	<table class='formula'><tr><td rowspan=2>R(x) = &nbsp;</td><td style='border-bottom: 1px solid black'>ax<sup>2</sup> + bx + c</td></tr><tr><td>dx</td></tr></table>
	<p>
Note that this is not a minimal degree configuration, we need <span class="formula">x</span> in the denominator so we could have a root in it.
	</p>
	<p>
There are 4 coefficients, so to compute all the coefficients, we need to put 4 facts about the <span class="formula">log<sub>2</sub>(x)</span> into the equation soup. Let them be these:
	</p>
	<p style="text-align: center;">
<span class="formula">log<sub>2</sub>(x)</span> has an asymptote in <span class="formula">0</span>. So <span class="formula">dx(0) = 0</span>.
	</p>
	<p class="formula">
log<sub>2</sub>(1) = 0.
</p>
	<p class="formula">
log<sub>2</sub>(2) = 1.
</p>
	<p class="formula">
log<sub>2</sub>(4) = 2.
	</p>
	<p>
Also, this system does not have a single solution but a whole family of solutions since the ratio itself introduces ambiguity. E.g. <span class="formula">1 / 2</span> is the same as <span class="formula">2 / 4</span> or <span class="formula">5 / 10</span> or <span class="formula">k / 2k</span> in general.
	</p>
	<p>
To avoid having a parametric solution, let’s just take one of the coefficients and pin it down as a specific number. Any non-zero number will do, and any coefficient too. My personal preference would be <span class="formula">d = 1</span>. So with my preference in mind, the <a href="https://wordsandbuttons.online/sympy_makes_math_fun_again.html">code that solves the system symbolically</a> looks like this:
	</p>
	<pre id="code_1" class="code">
from sympy import *

a, b, c, d, N, D, R = symbols('a b c d N D R')
x = symbols('x')
N = a*x*x + b*x + c
D = d*x
R = N/D

# R(0) = -inf
# R(1) = 0 <=> N(1) = 0
# R(2) = 1 <=> N(2) - D(2) = 0
# R(4) = 2 <=> N(4) - 2*D(4) = 0

eqs = [
    d - 1,
    D.subs(x, 0),
    N.subs(x, 1),
    (N - D).subs(x, 2),
    (N - 2*D).subs(x, 4)
]

sol = solve(eqs, (a, b, c, d))

print(sol)
</pre>
	<p>
Here is the solution:
	</p>
	<pre id="code_1" class="code">
{a: 1/3, b: 1, c: -4/3, d: 1}
</pre>
	<p>
And here is the solution visualized:
	</p>
	<canvas id="log_model"></canvas>
	<p class="comment">
The red line is the real log<sub>2</sub>(x). The blue line is the model. The plot is navigable.
	</p>
	<script language="JavaScript">
init_atan_plot(document.getElementById("log_model"), [function(x){return Math.log2(x);}, function(x){return (1/3*x*x + x -4/3) / x;}], ["#d64562", "#457fd6"], [],
		2.0, 2.0, 4.0, false, 640, 640, false, false, false);
document.getElementById("code_1").innerHTML = colorized(document.getElementById("code_1").innerHTML);
	</script>
	<p>
This is not a terribly precise model, and it has an extra bit for <span class="formula">x &lt; 0</span> that we don’t want. But it is simple and for its simplicity, it is good enough. Better than the polynomial one.
	</p>
	<h2>
Summary
	</h2>
	<p>
Polynomial interpolation is fine, and for most intents and purposes, we can stick to that. But for some problems, you need to extend your modeling capabilities a bit, and then rational interpolation comes to help.
	</p>
	<p>
Rational interpolation is also a gateway term to rational Bezier functions and non-uniform rational basis splines also known as NURBS. If you want to understand NURBS well, you should start with simple rational functions first. They were a missing link in my curriculum, and I struggled with NURBS for years after college. Luckily, now you don’t have to.
	</p>

	<table class="footer" style="width: 600pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
	<tr>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
		<a href="index.html">Index</a>
		<a href="all_mathematics.html">#mathematics</a> <a href="all_tutorials.html">#tutorials</a>
	</td>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
		&nbsp;&larr; there's more.
	</td>
	<td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
			<nobr>+
		<a href="https://wordsandbuttons.online/SYTYKC.pdf">So You Think You Know C</a> <span style="color:#888; font-size: 12pt;">(free book)</span></nobr><br>
			<nobr>+
		<a href="https://www.amazon.com/Geometry-Programmers-Oleksandr-Kaleniuk/dp/1633439607">Geometry for Programmers</a> <span style="color:#888; font-size: 12pt;">(paid book)</span></nobr><br>
			+
		<a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &

		<a href="https://wordsandbuttons.online/rss.rss"><span style="letter-spacing: 1pt;">RSS</span></a>
	</td>
	</tr>
	</table>
	</center>
</body>
</html>
