<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=0.84">
	<title>Interactive explanation of marching cubes and dual contouring</title>
	<meta name="description" content="Marching cubes and dual contouring are often used for mesh generation. This explanation shows how they work, what are their differences, similarities, and limitations.">
	<meta name="keywords" content="mathematics, algorithms, tutorials">
	<link rel="shortcut icon" type="image/x-icon" href="favicon.svg" />
	<style>
body{
	margin: 0 0 0 0;
}

a{
	text-decoration: none;
}

h1 {
	padding-top: 36pt;
	font-size: 24pt;
	width: 600pt;
	text-align: left;
}

h2 {
	padding-top: 20pt;
	font-size: 20pt;
	width: 555pt;
	text-align: left;
}

p {
	line-height: 1.42;
	font-size: 16pt;
	width: 505pt;
	text-align: left;
}

pre {
	margin: 0 0 0 0;
	padding-top: 12pt;
	padding-left: 12pt;
	padding-right: 12pt;
	padding-bottom: 12pt;
	font-size: 12pt;
	text-align: left;
	width: 300pt;
}

.formula {
	font-family: sans-serif;
	font-size: 15pt;
	font-style: italic;
	text-align: center;
	padding-top: 6pt;
	padding-bottom: 6pt;
}

.comment {
	font-size: 12pt;
	text-align:center;
	font-family: sans-serif;
	padding-bottom: 24pt;
}

li {
	font-size: 16pt;
	width: 505pt;
	text-align: left;
	padding-bottom: 6pt;
}

table {
	border-width: 0pt;
}

td {
	vertical-align: top;
	padding: 6pt 12pt 6pt 12pt;
	font-size: 16pt;
	border: 1px solid black;
	width: 600pt;
}

button{
	width: 248pt;
	height: 42pt;
	margin-left:4pt;
	margin-right:4pt;
	font-size: 16pt;
}

u {
	border-bottom: 1px dotted #000;
	text-decoration: none;
	cursor: pointer;
}

canvas { touch-action: none; }
	</style>
	<script language="JavaScript">
const w = 640;
const h = 480;

function draw_one_cube(context, j, i, grid_size, d_f, distance, do_interpolation) {
	var d00 = d_f(j, i);
	var d01 = d_f(j, i + grid_size);
	var d11 = d_f(j + grid_size, i + grid_size);
	var d10 = d_f(j + grid_size, i);
	var t00_01 = do_interpolation ? (distance - d00) / (d01 - d00) : 0.5;
	var t01_11 = do_interpolation ? (distance - d01) / (d11 - d01) : 0.5;
	var t11_10 = do_interpolation ? (distance - d11) / (d10 - d11) : 0.5;
	var t10_00 = do_interpolation ? (distance - d10) / (d00 - d10) : 0.5;
	var in_00 = d00 < distance;
	var out_00 = !in_00;
	var in_01 = d01 < distance;
	var out_01 = !in_01;
	var in_11 = d11 < distance;
	var out_11 = !in_11;
	var in_10 = d10 < distance;
	var out_10 = !in_10;

	if(out_00 && in_01 && in_11 && in_10) {
		context.moveTo(j + grid_size * (1.0 - t10_00), i); // top
		context.lineTo(j, i + grid_size * t00_01);
	}
	if(in_00 && out_01 && in_11 && in_10) {
		context.moveTo(j, i + grid_size * t00_01); // left
		context.lineTo(j + grid_size * t01_11, i + grid_size);
	}
	if(out_00 && out_01 && in_11 && in_10) {
		context.moveTo(j + grid_size * (1.0 - t10_00), i);
		context.lineTo(j + grid_size * t01_11, i + grid_size); // bottom
	}
	if(in_00 && in_01 && out_11 && in_10) {
		context.moveTo(j + grid_size * t01_11, i + grid_size);
		context.lineTo(j + grid_size, i + grid_size * (1.0 - t11_10)); // right
	}
	if(out_00 && in_01 && out_11 && in_10) {
		context.moveTo(j + grid_size * (1.0 - t10_00), i);
		context.lineTo(j + grid_size, i + grid_size * (1.0 - t11_10));
		context.moveTo(j, i + grid_size * t00_01);
		context.lineTo(j + grid_size * t01_11, i + grid_size);
	}
	if(in_00 && out_01 && out_11 && in_10) {
		context.moveTo(j + grid_size, i + grid_size * (1.0 - t11_10));
		context.lineTo(j, i + grid_size * t00_01);
	}
	if(out_00 && out_01 && out_11 && in_10) {
		context.moveTo(j + grid_size, i + grid_size * (1.0 - t11_10));
		context.lineTo(j + grid_size * (1.0 - t10_00), i);
	}
	if(in_00 && in_01 && in_11 && out_10) {
		context.moveTo(j + grid_size * (1.0 - t10_00), i);
		context.lineTo(j + grid_size, i + grid_size * (1.0 - t11_10));
	}
	if(out_00 && in_01 && in_11 && out_10) {
		context.moveTo(j, i + grid_size * t00_01);
		context.lineTo(j + grid_size, i + grid_size * (1.0 - t11_10));
	}
	if(in_00 && out_01 && in_11 && out_10) {
		context.moveTo(j + grid_size, i + grid_size * (1.0 - t11_10));
		context.lineTo(j + grid_size * t01_11, i + grid_size);
		context.moveTo(j, i + grid_size * t00_01);
		context.lineTo(j + grid_size * (1.0 - t10_00), i);
	}
	if(out_00 && out_01 && in_11 && out_10) {
		context.moveTo(j + grid_size, i + grid_size * (1.0 - t11_10));
		context.lineTo(j + grid_size * t01_11, i + grid_size);
	}
	if(in_00 && in_01 && out_11 && out_10) {
		context.moveTo(j + grid_size * t01_11, i + grid_size);
		context.lineTo(j + grid_size * (1.0 - t10_00), i);
	}
	if(out_00 && in_01 && out_11 && out_10) {
		context.moveTo(j + grid_size * t01_11, i + grid_size);
		context.lineTo(j, i + grid_size * t00_01);
	}
	if(in_00 && out_01 && out_11 && out_10) {
		context.moveTo(j, i + grid_size * t00_01);
		context.lineTo(j + grid_size * (1.0 - t10_00), i);
	}
}

function draw_marching_cubes(context, d_f, do_interpolation, w, h, grid_size, distance) {
	context.beginPath();
	for(var i = 0; i <= h - grid_size; i += grid_size) {
		for(var j = 0; j <= w - grid_size; j += grid_size) {
			draw_one_cube(context, j, i, grid_size, d_f, distance, do_interpolation);
		}
	}
	context.strokeStyle="#457fd6";
	context.lineWidth=4;
	context.stroke();
	context.closePath();
	context.lineWidth=1;
}

function fill_a_pixel_in(pixel_data, j, i, d, r, g, b) {
	if (Math.abs(d) < 1.4) {
		pixel_data.data[(i*w + j) * 4 + 0] = r;
		pixel_data.data[(i*w + j) * 4 + 1] = g;
		pixel_data.data[(i*w + j) * 4 + 2] = b;
		pixel_data.data[(i*w + j) * 4 + 3] = 0xFF;
	} else if(Math.abs(d) < 2.0) {
		pixel_data.data[(i*w + j) * 4 + 0] = r;
		pixel_data.data[(i*w + j) * 4 + 1] = g;
		pixel_data.data[(i*w + j) * 4 + 2] = b;
		pixel_data.data[(i*w + j) * 4 + 3] = 0x7F;
	}
}

var do_contour = false;
function draw_contour() {
	var contour = document.getElementById("contour");
	var context = contour.getContext("2d");
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);
	context.font = "16px sans-serif";

	// circle function
	var distance_field = context.createImageData(w, h);
	for (var i = 0; i < distance_field.data.length; ++i)
		distance_field.data[i] = 0;
	for (var i = 0; i <= h; ++i)
		for (var j = 0; j <= w; ++j) {
			var d = Math.pow(Math.pow(i - h/2, 2) + Math.pow(j - w/2, 2), 0.5) - 160;
			fill_a_pixel_in(distance_field, j, i, d, 0xD6, 0x45, 0x62);
		}
	context.putImageData(distance_field, -0.5, -0.5);

	if(do_contour) {
		draw_marching_cubes(context, function (x, y) {
			return Math.pow(Math.pow(x - w/2, 2) + Math.pow(y - h/2, 2), 0.5);},
			true,
			w, h, 80, 160);
	}

	// grid
	const client_y_center = h /2 + 0.5;
	const client_x_center = w / 2 + 0.5;
	const x_min = -4;
	const x_max = +4;
	const y_min = -3;
	const y_max = +3;
	const client_x_step = w / (x_max - x_min);
	const client_y_step = h / (y_max - y_min);
	context.beginPath();
	context.moveTo(0, client_y_center);
	context.lineTo(w, client_y_center);
	context.lineTo(w - 12, client_y_center - 5);
	context.moveTo(w, client_y_center);
	context.lineTo(w - 12, client_y_center + 5);
	context.moveTo(client_x_center, h);
	context.lineTo(client_x_center, 0);
	context.lineTo(client_x_center - 5, 12);
	context.moveTo(client_x_center, 0);
	context.lineTo(client_x_center + 5, 12);
	context.fillStyle="#000000";
	for(var i = x_min + 1; i <= x_max - 1; i++){
		if(i != 0) {
			context.moveTo(client_x_center + i*client_x_step, client_y_center);
			context.lineTo(client_x_center + i*client_x_step, client_y_center - 5);
			context.fillText(i, client_x_center + i*client_x_step + 4, client_y_center + 16);
		}
	}
	for(var i = y_min + 1; i <= y_max - 1; i++){
		if(i != 0) {
			context.moveTo(client_x_center, client_y_center - i*client_y_step);
			context.lineTo(client_x_center + 5, client_y_center - i*client_y_step);
		}
		context.fillText(i, client_x_center + 5, client_y_center - i*client_y_step + 16);
	}
	context.strokeStyle="#000000";
	context.stroke();
	context.closePath();
}

function toggle_contour() {
	do_contour = !do_contour;
	draw_contour();
	var toggle_contour = document.getElementById("toggle_contour");
	if(do_contour)
		toggle_contour.innerHTML = "Undo the contour";
	else
		toggle_contour.innerHTML = "Do the contour";
}

function draw_grid_border(context, d_f, w, h, grid_size, distance) {
	context.beginPath();
	for(var i = 0.5; i <= h - grid_size; i += grid_size) {
		for(var j = 0.5; j <= w - grid_size; j += grid_size) {
			var do_horizontal =
		(d_f(j + 0.5 * grid_size, i - 0.5 * grid_size) - distance ) *
		(d_f(j + 0.5 * grid_size, i + 0.5 * grid_size) - distance ) < 0 ? true : false;
			var do_vertical =
		(d_f(j - 0.5 * grid_size, i + 0.5 * grid_size) - distance ) *
		(d_f(j + 0.5 * grid_size, i + 0.5 * grid_size) - distance ) < 0 ? true : false;
			if(do_horizontal) {
				context.moveTo(j, i);
				context.lineTo(j + grid_size, i);
			}
			if(do_vertical) {
				context.moveTo(j, i);
				context.lineTo(j, i + grid_size);
			}
		}
	}
	context.strokeStyle="#3561a3";
	context.lineWidth=4;
	context.stroke();
	context.closePath();
	context.lineWidth=1;
}

function draw_grid_border_contour() {
	var grid_border = document.getElementById("grid_border");
	var context = grid_border.getContext("2d");
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);
	context.font = "16px sans-serif";

	// circle function
	var distance_field = context.createImageData(w, h);
	for (var i = 0; i < distance_field.data.length; ++i)
		distance_field.data[i] = 0;
	for (var i = 0; i <= h; ++i)
		for (var j = 0; j <= w; ++j) {
			var d = Math.pow(Math.pow(i - h/2, 2) + Math.pow(j - w/2, 2), 0.5) - 160;
			fill_a_pixel_in(distance_field, j, i, d, 0xD6, 0x45, 0x62);
		}
	context.putImageData(distance_field, -0.5, -0.5);

	// grid
	const grid_size = 32;
	context.beginPath();
	for(var i = 0; i <= h; i += grid_size) {
		context.moveTo(0.0, i);
		context.lineTo(w, i);
	}
	for(var j = 0; j <= w; j += grid_size) {
		context.moveTo(j, 0.0);
		context.lineTo(j, h);
	}
	context.strokeStyle="#222222";
	context.lineWidth=1;
	context.stroke();
	context.closePath();

	// +-
	context.beginPath();
	context.strokeStyle="#555555";
	for(var i = grid_size / 2 + 0.5; i <= h; i += grid_size) {
		for(var j = grid_size / 2 + 0.5; j <= w; j += grid_size) {
			var d = Math.pow(Math.pow(i - h/2, 2) + Math.pow(j - w/2, 2), 0.5) - 160;
			context.moveTo(j - 5, i);
			context.lineTo(j + 5, i);
			if(d > 0) {
				context.moveTo(j, i - 5);
				context.lineTo(j, i + 5);
			}
		}
	}
	context.stroke();
	context.closePath();

	draw_grid_border(context, function (x, y) {
		return Math.pow(Math.pow(x - w/2, 2) + Math.pow(y - h/2, 2), 0.5);},
		w, h, grid_size, 160);
	}

function draw_marching_cubes_contour(element, do_interpolation) {
	var context = document.getElementById(element).getContext("2d");
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);
	context.font = "16px sans-serif";

	// circle function
	var distance_field = context.createImageData(w, h);
	for (var i = 0; i < distance_field.data.length; ++i)
		distance_field.data[i] = 0;
	for (var i = 0; i <= h; ++i)
		for (var j = 0; j <= w; ++j) {
			var d = Math.pow(Math.pow(i - h/2, 2) + Math.pow(j - w/2, 2), 0.5) - 160;
			fill_a_pixel_in(distance_field, j, i, d, 0xD6, 0x45, 0x62);
		}
	context.putImageData(distance_field, -0.5, -0.5);

	// grid
	const grid_size = 80;
	context.beginPath();
	for(var i = 0; i <= h; i += grid_size) {
		context.moveTo(0.0, i);
		context.lineTo(w, i);
	}
	for(var j = 0; j <= w; j += grid_size) {
		context.moveTo(j, 0.0);
		context.lineTo(j, h);
	}
	context.strokeStyle="#222222";
	context.lineWidth=1;
	context.stroke();
	context.closePath();

	draw_marching_cubes(context,
			function (x, y) {return Math.pow(Math.pow(x - w/2, 2) + Math.pow(y - h/2, 2), 0.5);},
			do_interpolation,
			w, h, grid_size, 160);
}


var marching_cube_signs = [[0, 1], [1, 1]];
var marching_cube_buttons_xy = [[[160, 80], [480, 80]], [[160, 400], [480, 400]]];
var marching_cube_buttons_r = 24.0;
function init_marching_cube_no_interpolation() {
	var marching_cube = document.getElementById("marching_cube_no_interpolation");
	draw_marching_cube("marching_cube_no_interpolation", false, 0, 0, false);

	marching_cube.addEventListener('pointermove', function(e) {
		var canvas_rect = marching_cube.getBoundingClientRect();
		var client_x = e.clientX - canvas_rect.left;
		var client_y = e.clientY - canvas_rect.top;
		draw_marching_cube("marching_cube_no_interpolation", false, client_x, client_y, true);
		draw_marching_cube("marching_cube_interpolation", true, client_x, client_y, true);
	}, false);

	marching_cube.addEventListener('pointerup', function(e) {
		var canvas_rect = marching_cube.getBoundingClientRect();
		var client_x = e.clientX - canvas_rect.left;
		var client_y = e.clientY - canvas_rect.top;
		for(var i = 0; i <= 1; ++i)
			for(var j = 0; j <= 1; ++j) {
				if(Math.pow(client_x - marching_cube_buttons_xy[i][j][0], 2)
				 + Math.pow(client_y - marching_cube_buttons_xy[i][j][1], 2)
				<= Math.pow(marching_cube_buttons_r, 2)) {
					marching_cube_signs[i][j] = 1 - marching_cube_signs[i][j];
				}
			}
		draw_marching_cube("marching_cube_no_interpolation", false, client_x, client_y, true);
		draw_marching_cube("marching_cube_interpolation", true, client_x, client_y, true);
	}, false);
}

function init_marching_cube_interpolation() {
	var marching_cube = document.getElementById("marching_cube_interpolation");
	draw_marching_cube("marching_cube_interpolation", true, 0, 0, false);

	marching_cube.addEventListener('pointermove', function(e) {
		var canvas_rect = marching_cube.getBoundingClientRect();
		var client_x = e.clientX - canvas_rect.left;
		var client_y = e.clientY - canvas_rect.top;
		draw_marching_cube("marching_cube_interpolation", true, client_x, client_y, true);
		draw_marching_cube("marching_cube_no_interpolation", false, client_x, client_y, true);
	}, false);

	marching_cube.addEventListener('pointerup', function(e) {
		var canvas_rect = marching_cube.getBoundingClientRect();
		var client_x = e.clientX - canvas_rect.left;
		var client_y = e.clientY - canvas_rect.top;
		for(var i = 0; i <= 1; ++i)
			for(var j = 0; j <= 1; ++j) {
				if(Math.pow(client_x - marching_cube_buttons_xy[i][j][0], 2)
				 + Math.pow(client_y - marching_cube_buttons_xy[i][j][1], 2)
				<= Math.pow(marching_cube_buttons_r, 2)) {
					marching_cube_signs[i][j] = 1 - marching_cube_signs[i][j];
				}
			}
		draw_marching_cube("marching_cube_interpolation", true, client_x, client_y, true);
		draw_marching_cube("marching_cube_no_interpolation", false, client_x, client_y, true);
	}, false);
}

function draw_marching_cube(element, do_interpolation, client_x, client_y, do_highlight) {
	var context = document.getElementById(element).getContext("2d");
	context.font = "16px sans-serif";
	context.textAlign = 'left';
	context.textBaseline = 'bottom';

	// function
	var signed_distance_function = function(x, y, d) {
		return Math.sqrt(x*x + y*y) - d;
	};

	var sample_function = function(x, y) {return signed_distance_function(x - w*0.5, y + h*0.6, 340);};

	if(marching_cube_signs[0][0] == 0 && marching_cube_signs[0][1] == 1 && marching_cube_signs[1][0] == 1 && marching_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.0, y + h*0.1, 340);};

	if(marching_cube_signs[0][0] == 1 && marching_cube_signs[0][1] == 0 && marching_cube_signs[1][0] == 1 && marching_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.9, y + h*0.1, 340);};

	if(marching_cube_signs[0][0] == 0 && marching_cube_signs[0][1] == 0 && marching_cube_signs[1][0] == 1 && marching_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.6, y + h*0.3, 440);};

	if(marching_cube_signs[0][0] == 1 && marching_cube_signs[0][1] == 1 && marching_cube_signs[1][0] == 0 && marching_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.1, y - h*1.1, 340);};

	if(marching_cube_signs[0][0] == 0 && marching_cube_signs[0][1] == 1 && marching_cube_signs[1][0] == 0 && marching_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.0, y - h*0.4, 380);};

	if(marching_cube_signs[0][0] == 1 && marching_cube_signs[0][1] == 0 && marching_cube_signs[1][0] == 0 && marching_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return y < x ? signed_distance_function(x - w*1.0, y + h*0.1, 320)
													   : signed_distance_function(x - w*0.0, y - h*1.1, 320);};

	if(marching_cube_signs[0][0] == 0 && marching_cube_signs[0][1] == 0 && marching_cube_signs[1][0] == 0 && marching_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.0, y + h*0.1, 540);};

	if(marching_cube_signs[0][0] == 1 && marching_cube_signs[0][1] == 1 && marching_cube_signs[1][0] == 1 && marching_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*1.0, y - h*1.1, 410);};

	if(marching_cube_signs[0][0] == 0 && marching_cube_signs[0][1] == 1 && marching_cube_signs[1][0] == 1 && marching_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return y < w-x ? signed_distance_function(x - w*0.0, y + h*0.2, 365)
														 : signed_distance_function(x - w*1.0, y - h*1.2, 365);};

	if(marching_cube_signs[0][0] == 1 && marching_cube_signs[0][1] == 0 && marching_cube_signs[1][0] == 1 && marching_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*1.0, y - h*0.6, 380);};

	if(marching_cube_signs[0][0] == 0 && marching_cube_signs[0][1] == 0 && marching_cube_signs[1][0] == 1 && marching_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*1.0, y + h*0.1, 540);};

	if(marching_cube_signs[0][0] == 1 && marching_cube_signs[0][1] == 1 && marching_cube_signs[1][0] == 0 && marching_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.4, y - h*1.3, 440);};

	if(marching_cube_signs[0][0] == 0 && marching_cube_signs[0][1] == 1 && marching_cube_signs[1][0] == 0 && marching_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.0, y - h*1.1, 540);};

	if(marching_cube_signs[0][0] == 1 && marching_cube_signs[0][1] == 0 && marching_cube_signs[1][0] == 0 && marching_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*1.0, y - h*1.1, 540);};

	if(marching_cube_signs[0][0] == 0 && marching_cube_signs[0][1] == 0 && marching_cube_signs[1][0] == 0 && marching_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.5, y - h*0.5, 340);};

	var sample_function_image = context.createImageData(w, h);
	for (var i = 0; i < sample_function_image.data.length; ++i)
		sample_function_image.data[i] = 0;
	for (var i = 0; i <= h; ++i)
		for (var j = 0; j <= w; ++j) {
			var d = sample_function(j, i);
			fill_a_pixel_in(sample_function_image, j, i, d, 0xD6, 0x45, 0x62);
		}
	context.putImageData(sample_function_image, -0.5, -0.5);

	// cell
	context.beginPath();
	context.moveTo(0.0, marching_cube_buttons_xy[0][0][1]);
	context.lineTo(w, marching_cube_buttons_xy[0][0][1]);
	context.moveTo(0.0, marching_cube_buttons_xy[1][0][1]);
	context.lineTo(w, marching_cube_buttons_xy[1][0][1]);

	context.moveTo(marching_cube_buttons_xy[0][0][0], 0.0);
	context.lineTo(marching_cube_buttons_xy[0][0][0], h);
	context.moveTo(marching_cube_buttons_xy[0][1][0], 0.0);
	context.lineTo(marching_cube_buttons_xy[0][1][0], h)

	context.strokeStyle="#000000";
	context.lineWidth=1;
	context.stroke();
	context.closePath();

	// draw the line segment(s)
	context.beginPath();
	var one_cube_size = marching_cube_buttons_xy[0][1][0] - marching_cube_buttons_xy[0][0][0];
	draw_one_cube(context, marching_cube_buttons_xy[0][0][0], marching_cube_buttons_xy[0][0][1], one_cube_size, sample_function, 0, do_interpolation);
	context.strokeStyle = "#457fd6";
	context.lineWidth=4;
	context.stroke();
	context.closePath();
	context.lineWidth=1;

	// signs
	for(var i = 0; i <= 1; ++i)
		for(var j = 0; j <= 1; ++j) {
			context.beginPath();
			context.arc(marching_cube_buttons_xy[i][j][0], marching_cube_buttons_xy[i][j][1], marching_cube_buttons_r, 0, 2*Math.PI);
			if(do_highlight && true &&
			   Math.pow(client_x - marching_cube_buttons_xy[i][j][0], 2)
			 + Math.pow(client_y - marching_cube_buttons_xy[i][j][1], 2)
			<= Math.pow(marching_cube_buttons_r, 2)) { // highlight
				if(marching_cube_signs[i][j] == 1) {
					context.fillStyle="#ff0000";
				} else {
					context.fillStyle="#0000ff";
				}
			} else {
				if(marching_cube_signs[i][j] == 1) {
					context.fillStyle="#660000";
				} else {
					context.fillStyle="#000066";
				}
			}
			context.closePath();
			context.fill();

			// minus
			context.fillStyle="#eeeeee";
			context.fillRect(marching_cube_buttons_xy[i][j][0] - 12, marching_cube_buttons_xy[i][j][1] - 2, 24, 4);
			// plus
			if(marching_cube_signs[i][j] == 1) {
				context.fillRect(marching_cube_buttons_xy[i][j][0] - 2, marching_cube_buttons_xy[i][j][1] - 12, 4, 24);
			}
			if(do_interpolation) {
				context.fillStyle="#222222";
				context.fillText(
					Math.floor(sample_function(marching_cube_buttons_xy[i][j][0], marching_cube_buttons_xy[i][j][1])),
					marching_cube_buttons_xy[i][j][0] + 24,
					marching_cube_buttons_xy[i][j][1] - 6);
			}
		}
}

// interactive
var metaballs = [[[150, 516], [150, 516]], [[206, 454], [219, 438]], [[322, 398], [315, 464]], [[497, 109], [497, 109]], [[461, 145], [461, 145]], [[491, 227], [506, 224]]];

function d_metaballs(x, y) {
	var d = 0;
	for (var i = 0; i < metaballs.length; ++i) {
		d += 1.0 / Math.sqrt((metaballs[i][1][0]-x)*(metaballs[i][1][0]-x) + (metaballs[i][1][1]-y)*(metaballs[i][1][1]-y));
	}
	return (1.0 / d) * Math.sqrt(metaballs.length);
}

function init_interactive_marching_cubes(){
	var canvas = document.getElementById("interactive_marching_cubes");
	canvas.addEventListener('pointerdown', function(e){
		canvas_rect = canvas.getBoundingClientRect();
		metaballs.push([[e.clientX - canvas_rect.left, e.clientY - canvas_rect.top],[e.clientX - canvas_rect.left, e.clientY - canvas_rect.top]]);
		canvas.releasePointerCapture(e.pointerId);
	}, false);

	canvas.addEventListener('pointermove', function(e){
		if(e.buttons == 1){
			canvas_rect = canvas.getBoundingClientRect();
			metaballs[metaballs.length-1][1] = [e.clientX - canvas_rect.left, e.clientY - canvas_rect.top];
			draw_interactive_marching_cubes();
		}
	}, false);

	canvas.addEventListener('pointerup', function(e){
		canvas_rect = canvas.getBoundingClientRect();
		metaballs[metaballs.length-1][1] = [e.clientX - canvas_rect.left, e.clientY - canvas_rect.top];
		draw_interactive_marching_cubes();
	}, false);

	draw_interactive_marching_cubes();
}

function draw_interactive_marching_cubes(){
	var canvas = document.getElementById("interactive_marching_cubes");
	var context = canvas.getContext("2d");
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	var h = 640;
	var grid_size = 32;
	var distance = 64;

	// distance function
	var distance_field = context.createImageData(w, h);
	for (var i = 0; i < distance_field.data.length; ++i)
		distance_field.data[i] = 0;

	for (var i = 0; i <= h; i += 2.0)
		for (var j = 0; j <= w; j += 2.0) {
			d = d_metaballs(j, i);
			if (d <= distance) {
				distance_field.data[(i*w + j) * 4 + 0] = 0x77;
				distance_field.data[(i*w + j) * 4 + 1] = 0x77;
				distance_field.data[(i*w + j) * 4 + 2] = 0x77;
				distance_field.data[(i*w + j) * 4 + 3] = 0xFF;
			}
		}
	context.putImageData(distance_field, -0.5, -0.5);

	// grid
	context.beginPath();
	for(var i = 0; i <= h; i += grid_size) {
		context.moveTo(0.0, i);
		context.lineTo(w, i);
	}
	for(var j = 0; j <= w; j += grid_size) {
		context.moveTo(j, 0.0);
		context.lineTo(j, h);
	}
	context.strokeStyle="#222222";
	context.lineWidth=1;
	context.stroke();
	context.closePath();

	draw_marching_cubes(context, d_metaballs, true, w, h, grid_size, distance);
}

function reset_all_metaballs() {
	metaballs = [];
	draw_interactive_marching_cubes();
}

function undo_last_metaball() {
	metaballs.splice(-1,1);
	draw_interactive_marching_cubes();
}


// not interactive
function draw_marching_cubes_square_contour() {
	var context = document.getElementById("marching_cubes_square").getContext("2d");
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);
	context.font = "16px sans-serif";

	// square function
	var d_f = function(x, y) {
		return Math.max(Math.abs(y - h/2) - 130, Math.abs(x - w/2) - 170);
	}

	var distance_field = context.createImageData(w, h);
	for (var i = 0; i < distance_field.data.length; ++i)
		distance_field.data[i] = 0;
	for (var i = 0; i <= h; ++i)
		for (var j = 0; j <= w; ++j) {
			var d = d_f(j, i);
			fill_a_pixel_in(distance_field, j, i, d, 0xD6, 0x45, 0x62);
		}
	context.putImageData(distance_field, -0.5, -0.5);

	// grid
	const grid_size = 80;
	context.beginPath();
	for(var i = 0; i <= h; i += grid_size) {
		context.moveTo(0.0, i);
		context.lineTo(w, i);
	}
	for(var j = 0; j <= w; j += grid_size) {
		context.moveTo(j, 0.0);
		context.lineTo(j, h);
	}
	context.strokeStyle="#222222";
	context.lineWidth=1;
	context.stroke();
	context.closePath();

	draw_marching_cubes(context,
			d_f,
			true,
			w, h, grid_size, 0);
}

// dual contouring variant
function optimum_in_cube_brute(d_f, x, y, grid_size, gradient_step) {
	// this is the optimizer alternative that you can use to craft your own optimum criteria
	var optimum = [0, 0];
	var optimum_value = Number.MAX_VALUE;
	for (var i = y; i < y + grid_size; i += gradient_step) {
		for (var j = x; j < x + grid_size; j += gradient_step) {
			var estimate = Math.pow(d_f(j, i), 2); // this puts the point on the contour
			if( estimate > optimum_value )
				continue;
			estimate += 2.0 * Math.pow(d_f(j - gradient_step, i) - d_f(j + gradient_step, i), 2) + Math.pow(d_f(j, i - gradient_step) - d_f(j, i + gradient_step), 2); // this finds features
			estimate += 0.01 * (Math.pow(j - (x + grid_size / 2), 2) + Math.pow(i - (y + grid_size / 2), 2) ); // this drags the point to the cell's center if there are no better alternatives
			if (estimate < optimum_value) {
				optimum_value = estimate;
				optimum = [j, i];
			}
		}
	}
	return optimum;
}

function draw_dual_contouring(context, d_f, j0, i0, w, h, grid_size) {
	context.beginPath();
	for(var i = i0; i <= h - grid_size; i += grid_size) {
		for(var j = j0; j <= w - grid_size; j += grid_size) {
			if(d_f(j, i) < 0 != d_f(j, i + grid_size) < 0) {
				var opt1 = optimum_in_cube_brute(d_f, j, i, grid_size, 1.0);
				var opt2 = optimum_in_cube_brute(d_f, j - grid_size, i, grid_size, 1.0);
				context.moveTo(opt1[0], opt1[1]);
				context.lineTo(opt2[0], opt2[1]);
			}
			if(d_f(j, i) < 0 != d_f(j + grid_size, i) < 0) {
				var opt1 = optimum_in_cube_brute(d_f, j, i ,grid_size, 1.0);
				var opt2 = optimum_in_cube_brute(d_f, j, i - grid_size, grid_size, 1.0);
				context.moveTo(opt1[0], opt1[1]);
				context.lineTo(opt2[0], opt2[1]);
			}
		}
	}
	context.strokeStyle="#62d645";
	context.lineWidth=4;
	context.stroke();
	context.closePath();
}

var dual_cube_signs = [[0, 1], [1, 1]];
var dual_cube_buttons_xy = [[[640/2 - 80, 480/2 - 80], [640/2 + 80, 480/2 - 80]], [[640/2 - 80, 480/2 + 80], [640/2 + 80, 480/2 + 80]]];
var dual_cube_buttons_r = 24.0;
function init_dual_cube() {
	var dual_cube = document.getElementById("dual_cube");
	draw_dual_cube(0, 0, false);

	dual_cube.addEventListener('pointermove', function(e) {
		var canvas_rect = dual_cube.getBoundingClientRect();
		var client_x = e.clientX - canvas_rect.left;
		var client_y = e.clientY - canvas_rect.top;
		draw_dual_cube(client_x, client_y, true);
	}, false);

	dual_cube.addEventListener('pointerup', function(e) {
		var canvas_rect = dual_cube.getBoundingClientRect();
		var client_x = e.clientX - canvas_rect.left;
		var client_y = e.clientY - canvas_rect.top;
		for(var i = 0; i <= 1; ++i)
			for(var j = 0; j <= 1; ++j) {
				if(Math.pow(client_x - dual_cube_buttons_xy[i][j][0], 2)
				 + Math.pow(client_y - dual_cube_buttons_xy[i][j][1], 2)
				<= Math.pow(dual_cube_buttons_r, 2)) {
					dual_cube_signs[i][j] = 1 - dual_cube_signs[i][j];
				}
			}
		draw_dual_cube(client_x, client_y, true);
	}, false);
}

function draw_dual_cube(client_x, client_y, do_highlight) {
	var context = document.getElementById("dual_cube").getContext("2d");
	context.font = "16px sans-serif";
	context.textAlign = 'left';
	context.textBaseline = 'bottom';

	// function
	var signed_distance_function = function(x, y, d) {
		return Math.sqrt(x*x + y*y) - d;
	};

	var sample_function = function(x, y) {return signed_distance_function(x - w*0.5, y + h*0.6, 340);};

	if(dual_cube_signs[0][0] == 0 && dual_cube_signs[0][1] == 1 && dual_cube_signs[1][0] == 1 && dual_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.0, y + h*0.1, 370);};

	if(dual_cube_signs[0][0] == 1 && dual_cube_signs[0][1] == 0 && dual_cube_signs[1][0] == 1 && dual_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.9, y + h*0.1, 340);};

	if(dual_cube_signs[0][0] == 0 && dual_cube_signs[0][1] == 0 && dual_cube_signs[1][0] == 1 && dual_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.6, y + h*0.3, 400);};

	if(dual_cube_signs[0][0] == 1 && dual_cube_signs[0][1] == 1 && dual_cube_signs[1][0] == 0 && dual_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.1, y - h*1.1, 340);};

	if(dual_cube_signs[0][0] == 0 && dual_cube_signs[0][1] == 1 && dual_cube_signs[1][0] == 0 && dual_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.0, y - h*0.4, 360);};

	if(dual_cube_signs[0][0] == 1 && dual_cube_signs[0][1] == 0 && dual_cube_signs[1][0] == 0 && dual_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return y < x ? signed_distance_function(x - w*1.0, y + h*0.1, 380)
													   : signed_distance_function(x - w*0.0, y - h*1.1, 370);};

	if(dual_cube_signs[0][0] == 0 && dual_cube_signs[0][1] == 0 && dual_cube_signs[1][0] == 0 && dual_cube_signs[1][1] == 1)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.0, y + h*0.1, 500);};

	if(dual_cube_signs[0][0] == 1 && dual_cube_signs[0][1] == 1 && dual_cube_signs[1][0] == 1 && dual_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*1.0, y - h*1.1, 390);};

	if(dual_cube_signs[0][0] == 0 && dual_cube_signs[0][1] == 1 && dual_cube_signs[1][0] == 1 && dual_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return y < w-x ? signed_distance_function(x - w*0.0, y + h*0.2, 380)
														 : signed_distance_function(x - w*1.0, y - h*1.2, 400);};

	if(dual_cube_signs[0][0] == 1 && dual_cube_signs[0][1] == 0 && dual_cube_signs[1][0] == 1 && dual_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*1.0, y - h*0.6, 340);};

	if(dual_cube_signs[0][0] == 0 && dual_cube_signs[0][1] == 0 && dual_cube_signs[1][0] == 1 && dual_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*1.0, y + h*0.1, 490);};

	if(dual_cube_signs[0][0] == 1 && dual_cube_signs[0][1] == 1 && dual_cube_signs[1][0] == 0 && dual_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.4, y - h*1.3, 410);};

	if(dual_cube_signs[0][0] == 0 && dual_cube_signs[0][1] == 1 && dual_cube_signs[1][0] == 0 && dual_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.0, y - h*1.1, 490);};

	if(dual_cube_signs[0][0] == 1 && dual_cube_signs[0][1] == 0 && dual_cube_signs[1][0] == 0 && dual_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*1.0, y - h*1.1, 500);};

	if(dual_cube_signs[0][0] == 0 && dual_cube_signs[0][1] == 0 && dual_cube_signs[1][0] == 0 && dual_cube_signs[1][1] == 0)
		sample_function = function(x, y) {return signed_distance_function(x - w*0.5, y - h*0.5, 200);};

	var sample_function_image = context.createImageData(w, h);
	for (var i = 0; i < sample_function_image.data.length; ++i)
		sample_function_image.data[i] = 0;
	for (var i = 0; i <= h; ++i)
		for (var j = 0; j <= w; ++j) {
			var d = sample_function(j, i);
			fill_a_pixel_in(sample_function_image, j, i, d, 0xD6, 0x45, 0x62);
		}
	context.putImageData(sample_function_image, -0.5, -0.5);

	// cell
	var dx = (dual_cube_buttons_xy[1][1][0] - dual_cube_buttons_xy[0][0][0]);
	var dy = (dual_cube_buttons_xy[1][1][1] - dual_cube_buttons_xy[0][0][1]);
	context.beginPath();
	context.moveTo(0.0, dual_cube_buttons_xy[0][0][1]);
	context.lineTo(w, dual_cube_buttons_xy[0][0][1]);
	context.moveTo(0.0, dual_cube_buttons_xy[0][0][1] + dy);
	context.lineTo(w, dual_cube_buttons_xy[0][0][1] + dy);

	context.moveTo(dual_cube_buttons_xy[0][0][0] - dx, 0.0);
	context.lineTo(dual_cube_buttons_xy[0][0][0] - dx, h);
	context.moveTo(dual_cube_buttons_xy[0][0][0], 0.0);
	context.lineTo(dual_cube_buttons_xy[0][0][0], h);
	context.moveTo(dual_cube_buttons_xy[0][0][0] + dx, 0.0);
	context.lineTo(dual_cube_buttons_xy[0][0][0] + dx, h);
	context.moveTo(dual_cube_buttons_xy[0][0][0] + 2*dx, 0.0);
	context.lineTo(dual_cube_buttons_xy[0][0][0] + 2*dx, h);

	context.strokeStyle="#000000";
	context.lineWidth=1;
	context.stroke();
	context.closePath();

	// draw the line segment(s)
	var one_cube_size = dual_cube_buttons_xy[0][1][0] - dual_cube_buttons_xy[0][0][0];
	draw_dual_contouring(context,
			sample_function,
			dual_cube_buttons_xy[0][0][0] - 2*dx,
			dual_cube_buttons_xy[0][0][1] - dy,
			dx * 4.5,
			dy * 4.5,
			one_cube_size);

	// signs
	for(var i = 0; i <= 1; ++i)
		for(var j = 0; j <= 1; ++j) {
			context.beginPath();
			context.arc(dual_cube_buttons_xy[i][j][0], dual_cube_buttons_xy[i][j][1], dual_cube_buttons_r, 0, 2*Math.PI);
			if(do_highlight && true &&
			   Math.pow(client_x - dual_cube_buttons_xy[i][j][0], 2)
			 + Math.pow(client_y - dual_cube_buttons_xy[i][j][1], 2)
			<= Math.pow(dual_cube_buttons_r, 2)) { // highlight
				if(dual_cube_signs[i][j] == 1) {
					context.fillStyle="#ff0000";
				} else {
					context.fillStyle="#0000ff";
				}
			} else {
				if(dual_cube_signs[i][j] == 1) {
					context.fillStyle="#660000";
				} else {
					context.fillStyle="#000066";
				}
			}
			context.closePath();
			context.fill();

			// minus
			context.fillStyle="#eeeeee";
			context.fillRect(dual_cube_buttons_xy[i][j][0] - 12, dual_cube_buttons_xy[i][j][1] - 2, 24, 4);
			// plus
			if(dual_cube_signs[i][j] == 1) {
				context.fillRect(dual_cube_buttons_xy[i][j][0] - 2, dual_cube_buttons_xy[i][j][1] - 12, 4, 24);
			}
			context.fillStyle="#222222";
			context.fillText(
				Math.floor(sample_function(dual_cube_buttons_xy[i][j][0], dual_cube_buttons_xy[i][j][1])),
				dual_cube_buttons_xy[i][j][0] + 24,
				dual_cube_buttons_xy[i][j][1] - 6);
		}
}

function draw_dual_square_contour() {
	var context = document.getElementById("dual_square").getContext("2d");
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);
	context.font = "16px sans-serif";

	// square function
	var d_f = function(x, y) {
		return Math.max(Math.abs(y - h/2) - 130, Math.abs(x - w/2) - 170);
	}

	var distance_field = context.createImageData(w, h);
	for (var i = 0; i < distance_field.data.length; ++i)
		distance_field.data[i] = 0;
	for (var i = 0; i <= h; ++i)
		for (var j = 0; j <= w; ++j) {
			var d = d_f(j, i);
			fill_a_pixel_in(distance_field, j, i, d, 0xD6, 0x45, 0x62);
		}
	context.putImageData(distance_field, -0.5, -0.5);

	// grid
	const grid_size = 80;
	context.beginPath();
	for(var i = 0; i <= h; i += grid_size) {
		context.moveTo(0.0, i);
		context.lineTo(w, i);
	}
	for(var j = 0; j <= w; j += grid_size) {
		context.moveTo(j, 0.0);
		context.lineTo(j, h);
	}
	context.strokeStyle="#222222";
	context.lineWidth=1;
	context.stroke();
	context.closePath();

	draw_dual_contouring(context,
			d_f,
			0, 0, w, h, grid_size);
}

// interactive
var lines = [[[92, 169], [542, 313]], [[432, 96], [166, 492]]];

function dot(a1, a2, b1, b2) {
	return a1 * b1 + a2 * b2;
}

function distance_to_segment(lp1x, lp1y, lp2x, lp2y, px, py) {
	var t_proj = dot(px - lp1x, py - lp1y, lp2x - lp1x, lp2y - lp1y) / dot(lp2x - lp1x, lp2y - lp1y, lp2x - lp1x, lp2y - lp1y);
	if (isNaN(t_proj))
		t_proj = 0.0;
	else if (t_proj < 0.0)
		t_proj = 0.0;
	else if (t_proj > 1.0)
		t_proj = 1.0;
	var p_proj_x = lp1x + (lp2x - lp1x) * t_proj;
	var p_proj_y = lp1y + (lp2y - lp1y) * t_proj;
	return Math.sqrt(dot(p_proj_x - px, p_proj_y - py, p_proj_x - px, p_proj_y - py));
}

function distance_to_line_segment(line, px, py) {
	return distance_to_segment(line[0][0], line[0][1], line[1][0], line[1][1], px, py);
}

function d_lines(x, y) {
	var d = Number.MAX_VALUE; // everything is out
	for (var i = 0; i < lines.length; ++i) {
		var di = distance_to_line_segment(lines[i], x, y);
		if (di < d)
			d = di;
	}
	return d - 64;
}

function init_interactive_dual_contouring(){
	var canvas = document.getElementById("interactive_dual_contouring");
	canvas.addEventListener('pointerdown', function(e){
		canvas_rect = canvas.getBoundingClientRect();
		lines.push([[e.clientX - canvas_rect.left, e.clientY - canvas_rect.top],[e.clientX - canvas_rect.left, e.clientY - canvas_rect.top]]);
		canvas.releasePointerCapture(e.pointerId);
	}, false);

	canvas.addEventListener('pointermove', function(e){
		if(e.buttons == 1){
			canvas_rect = canvas.getBoundingClientRect();
			lines[lines.length-1][1] = [e.clientX - canvas_rect.left, e.clientY - canvas_rect.top];
			draw_interactive_dual_contouring();
		}
	}, false);

	canvas.addEventListener('pointerup', function(e){
		canvas_rect = canvas.getBoundingClientRect();
		lines[lines.length-1][1] = [e.clientX - canvas_rect.left, e.clientY - canvas_rect.top];
		draw_interactive_dual_contouring();
	}, false);

	draw_interactive_dual_contouring();
}

function draw_interactive_dual_contouring(){
	var canvas = document.getElementById("interactive_dual_contouring");
	var context = canvas.getContext("2d");
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	var h = 640;
	var grid_size = 32;

	// distance function
	var distance_field = context.createImageData(w, h);
	for (var i = 0; i < distance_field.data.length; ++i)
		distance_field.data[i] = 0;

	for (var i = 0; i <= h; i += 2.0)
		for (var j = 0; j <= w; j += 2.0) {
			d = d_lines(j, i);
			if (d <= 0) {
				distance_field.data[(i*w + j) * 4 + 0] = 0x77;
				distance_field.data[(i*w + j) * 4 + 1] = 0x77;
				distance_field.data[(i*w + j) * 4 + 2] = 0x77;
				distance_field.data[(i*w + j) * 4 + 3] = 0xFF;
			}
		}
	context.putImageData(distance_field, -0.5, -0.5);

	// grid
	context.beginPath();
	for(var i = 0; i <= h; i += grid_size) {
		context.moveTo(0.0, i);
		context.lineTo(w, i);
	}
	for(var j = 0; j <= w; j += grid_size) {
		context.moveTo(j, 0.0);
		context.lineTo(j, h);
	}
	context.strokeStyle="#222222";
	context.lineWidth=1;
	context.stroke();
	context.closePath();

	draw_dual_contouring(context,
		d_lines,
		0, 0, w, h, grid_size);
}

function reset_all_lines() {
	lines = [];
	draw_interactive_dual_contouring();
}

function undo_last_line() {
	lines.splice(-1,1);
	draw_interactive_dual_contouring();
}
	</script>
</head>
<body>
	<center>
	<h1>
Interactive explanation of marching cubes and dual contouring
	</h1>
	<p>
Marching cubes and dual contouring are mostly known as 3D mesh generating algorithms, but since it's hard to explain 3D things using 2D display, we will concentrate on planar analog. We will do contours.
	</p>

	<h2>
What is <span id="index_contouring">contouring</span>?
	</h2>
	<p>
Let's say we have a function.
	</p>
	<p class="formula">
x<sup>2</sup> + y<sup>2</sup> = 4
	</p>
	<p>
This function represents a circle. Now let's say we don't want a perfect circle, but its contour — a set of line segments that represent the circle within some tolerable error.
	</p>
	<canvas id="contour" width=640 height=480></canvas>
	<div style="text-align:right; width:640px; padding-bottom:12pt;">
		<button type="button" id="toggle_contour" onclick="toggle_contour()">Do the contour</button>
	</div>
	<script language="JavaScript">
	draw_contour();
	</script>
	<p>
With the contour, we can do things that would be tricky to do with the circle itself. Like intersecting it with some other arbitrary curve or storing it in the same array with lines, triangles, and all the other contours regardless of their original nature.
	</p>
	<p>
Conceptually, contouring is simple. Let's rewrite our function:
	</p>
	<p class="formula">
F(x, y) = x<sup>2</sup> + y<sup>2</sup> - 4
	</p>
	<p>
Now we cover the plane with a grid. For every two adjacent cells, its shared border becomes a piece of the contour if the function <i>F(x,y)</i> changes sign between these two cell's centers. And that's it. This simple rule is enough for simple contouring.
	</p>
	<canvas id="grid_border" width=640 height=480></canvas>
	<script language="JavaScript">
	draw_grid_border_contour();
	</script>
	<p>
Well, technically, it does represent the original curve. And the error is predictable. It never exceeds half of the cell's diagonal. But this contour has way too many corners for a circle.
	</p>
	<p>
We need something better.
	</p>
	<h2>
<span id="index_marching_cubes">Marching cubes</span>
	</h2>

	<p>
What if we add line segments that go across the cells? We can measure function signs in every corner for each square, and add line segments accordingly. For now, let's connect the sign-changing edges from middle to middle.
	</p>
	<p>
There are 4 squares, 2 signs; there are only 16 combinations of sign change possible.
	</p>
	<canvas id="marching_cube_no_interpolation" width=640 height=480></canvas>
	<script language="JavaScript">
	init_marching_cube_no_interpolation();
	</script>
	<p class="comment">
Click the +/- buttons to change signs.
	</p>
	<p>
Since pairs of signs for each shared edge change synchronously for both cells, the line segments connect automatically into a continuous contour.
	</p>
	<canvas id="marching_cubes_no_interpolation" width=640 height=480></canvas>
	<script language="JavaScript">
	draw_marching_cubes_contour("marching_cubes_no_interpolation", false);
	</script>
	<p>
It's a little better than before, but it is still far from the shape we want.
	</p>
	<p>
What if we don't put our line segments ends in the middle of edges, but try to find a better place for them? We have not only the function's signs but also the values so why don't we exploit that?
	</p>
	<p>
One way to find a better place to put line segments' ends will be by using linear interpolation.
	</p>
	<canvas id="marching_cube_interpolation" width=640 height=480></canvas>
	<script language="JavaScript">
	init_marching_cube_interpolation();
	</script>
	<p class="comment">
Sign buttons are clickable.
	</p>
	<p>
This is not flawless. Since our target function is not necessarily linear, we can't expect linear interpolation to approximate it perfectly well. Ideally, we should have been looking for an actual point where the curve intersects an edge and not an interpolative prediction.
	</p>
	<p>
But linear interpolation still works well enough most of the time, and it's super cheap to compute.
	</p>
	<canvas id="marching_cubes_interpolation" width=640 height=480></canvas>
	<script language="JavaScript">
	draw_marching_cubes_contour("marching_cubes_interpolation", true);
	</script>
	<p>
Here, you can try it out yourself. Just click and drag anywhere on the canvas.
	</p>
	<canvas id="interactive_marching_cubes" width=640 height=640></canvas>
	<script language="JavaScript">
	init_interactive_marching_cubes();
	</script>
	<div style="text-align:right; width:640px; padding-bottom:12pt;">
		<button type="button" style="width: 108pt;" onclick="undo_last_metaball()"><nobr>Undo last</nobr></button>
		<button type="button" style="width: 108pt;" onclick="reset_all_metaballs()"><nobr>Reset all</nobr></button>
	</div>
	<p>
The ironic drawback of marching cubes is that they don't work very well with real cubes.
	</p>
	<canvas id="marching_cubes_square" width=640 height=480></canvas>
	<p class="comment">
It's a red rectangle approximated by marching cubes' blue contour &uarr;
	</p>
	<script language="JavaScript">
	draw_marching_cubes_square_contour();
	</script>
	<p>
It gets better with a finer grid, sure, but conceptually this is the weak spot. For this problem, we need something different.
	</p>
	<h2>
Intermezzo
	</h2>
	<p>
<i>Marching cubes is not a single algorithm. It's a general approach covering a whole family of algorithms. Some are adaptive. Some are supplemented with sharp feature detection. Some can preserve the topology of non-manifold surfaces. Some work faster than others. Some have better memory consumption.</i>
	</p>
	<p>
<i>Just as that, dual contouring is not a single dual method. There are plenty. From primitive surface nets to the most sophisticated adaptive methods. We will not look into them.</i>
	</p>
	<p>
<i>I believe, the most important lesson we can take from dual methods is the idea of duality. The very concept, not the specific algorithm. We will look into this right now.</i>
	</p>
	<h2>
<span id="index_dual_contouring">Dual contouring</span>
	</h2>
	<p>
With marching cubes we did the following:
	</p>
	<ol>
		<li>
If a function changes its sign in a <b>cube</b>, we add a line segment from <b>edge</b> to <b>edge</b>.
		</li>
		<li>
The exact ends of each segment are being placed anywhere on the <b>edges</b> to minimize the difference between an isoline and a contour.
		</li>
	</ol>
	<p>
Conceptually, dual contouring goes like this:
	</p>
	<ol>
		<li>
If a function changes its sign on the <b>edge</b>, we add a line segment from <b>cube</b> to <b>cube</b>.
		</li>
		<li>
The exact ends of each segment are being placed anywhere in the <b>cubes</b> to minimize the difference between an isoline and a contour.
		</li>
	</ol>
	<p>
Noticed anything?
	</p>
	<p>
Exactly! This is the same algorithm. Only cubes now play as edges and edges as cubes. That's the <span id="index_duality">duality</span>.
	</p>
	<canvas id="dual_cube" width=640 height=480></canvas>
	<script language="JavaScript">
	init_dual_cube();
	</script>
	<p>
And now, since we get to place a segment end anywhere in the cube, we can also choose it to be on the corner.
	</p>
	<canvas id="dual_square" width=640 height=480></canvas>
	<p class="comment">
There is a red rectangle under the green one, but it's completely covered &uarr;
	</p>
	<script language="JavaScript">
	draw_dual_square_contour();
	</script>
	<p>
Here, try it yourself. Click and drag.
	</p>
	<canvas id="interactive_dual_contouring" width=640 height=640></canvas>
	<script language="JavaScript">
	init_interactive_dual_contouring();
	</script>
	<div style="text-align:right; width:640px; padding-bottom:12pt;">
		<button type="button" style="width: 108pt;" onclick="undo_last_line()"><nobr>Undo last</nobr></button>
		<button type="button" style="width: 108pt;" onclick="reset_all_lines()"><nobr>Reset all</nobr></button>
	</div>
	<p>
Duality is a fascinating concept. The way you get new properties from an algorithm by merely swapping planes and points is, in a way, a mathematical miracle.
	</p>
	<h2>
Conclusion
	</h2>
	<p>
In practice, marching cubes and dual contouring tend to be complicated because we want more than just a contour or a triangle mesh out of them. We want them to work with sharp features, textures, open surfaces, non-manifold models, and all in a reasonable time, too. But conceptually, they are both rather simple. I hope this explanation shows it well.
	</p>

	<table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
	<tr>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
		<a href="index.html">Index</a>
		<a href="all_mathematics.html">#mathematics</a> <a href="all_algorithms.html">#algorithms</a> <a href="all_tutorials.html">#tutorials</a>
	</td>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
		&nbsp;&larr; there's more.
	</td>
	<td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
		+
		<a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &

		<a href="https://wordsandbuttons.online/rss"><span style="letter-spacing: 1pt;">RSS</span></a>
	</td>
	</tr>
	</table>
	</center>
</body>
</html>
