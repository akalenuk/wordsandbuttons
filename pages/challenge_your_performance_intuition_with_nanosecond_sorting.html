<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=0.84">
	<title>Challenge your performance intuition with nanosecond sorting</title>
	<meta name="description" content="And yet another interactive quiz where you get to estimate the performance difference between several variants of the same code.">
	<meta name="keywords" content="programming, quizzes">
	<link rel="shortcut icon" type="image/x-icon" href="favicon.svg" />
	<style>
body{
	margin: 0 0 0 0;
}

a {
	text-decoration: none;
}

a:link, a:visited {
	color: blue;
}

h1 {
	padding-top: 36pt;
	font-size: 24pt;
	width: 600pt;
	text-align: left;
}

h2 {
	padding-top: 64pt;
	font-size: 20pt;
	width: 600pt;
	text-align: left;
}

p {
	line-height: 1.42;
	font-size: 16pt;
	width: 600pt;
	text-align: left;
}

.comment {
	font-size: 14pt;
	text-align:center;
	font-family: sans-serif;
	padding-bottom: 24pt;
}

table.footer {
	padding: 64pt 0pt 32pt 0pt;
	background-color: transparent;
	width: 600pt;
}

td.footer {
	font-family: sans-serif;
	font-size: 16pt;
	font-style: normal;
	padding: 0;
	margin: 0;
	border: 0;
}

pre {
	margin: 0 0 0 0;
	padding-top: 12pt;
	padding-left: 12pt;
	padding-right: 12pt;
	padding-bottom: 12pt;
	font-size: 12pt;
	text-align: left;
	width: 360pt;
}

table {
	text-align: center;
	border-width: 0pt;
}

td {
	padding: 6pt 12pt 6pt 12pt;
	font-size: 16pt;
	border: 1px solid black;
}

button{
	width: 304pt;
	height: 42pt;
	margin-left:4pt;
	margin-right:4pt;
	font-size: 18pt;
}

u {
	text-decoration: none;
	font-weight: bold;
	color: #e30707;
}

canvas { touch-action: none; }
	</style>
	<script language="JavaScript">
const slider_set = [false, false, false, false, false, false, false];
const slider_true_xs = [
	0.1446586 / (0.1446586 + 0.02240006) * 512,
	0.02240006 / (0.02240006 + 0.020363) * 512,
	0.020363 / (0.020363 + 0.08614054) * 512,

	0.08614054 / (0.08614054 + 0.0899975) * 512,
	0.0899975 / (0.0899975 + 0.04408498) * 512,
	0.04408498 / (0.04408498 + 0.02030048) * 512,

	0.020363 / (0.020363 + 0.02052882) * 512,
	];
const slider_user_xs = [256, 256, 256, 256, 256, 256, 256];
const slider_xs = [256, 256, 256, 256, 256, 256, 256];
const sliders = slider_true_xs.length;

var slider_down = false;

function comment_on_slider(no){
	var left = document.getElementById("left_" + (no + 1));
	var right = document.getElementById("right_" + (no + 1));
	var x = slider_xs[no]
	var xl = x;
	var xr = 511 - x;
	if(x < 255){
		left.style.backgroundColor = "#" + (Math.round(xl)).toString(16) + "ff" + (Math.round(xl)).toString(16);
		right.style.backgroundColor = "#ff" + (Math.round(xl)).toString(16) + (Math.round(xl)).toString(16);
	}else{
		right.style.backgroundColor = "#" + (Math.round(xr)).toString(16) + "ff" + (Math.round(xr)).toString(16);
		left.style.backgroundColor = "#ff" + (Math.round(xr)).toString(16) + (Math.round(xr)).toString(16);
	}

	var comment = document.getElementById("comment_" + (no + 1));
	if(Math.abs(xl - xr) < 3){
		comment.innerHTML = "They are almost the same.";
	}else if(xl > xr){
		if(xl > 20*xr){
			comment.innerHTML = "Right is more than 20 times faster!";
		}else if(xl > 10*xr){
			comment.innerHTML = "Right is more than 10 times faster!";
		}else if(xl > 5*xr){
			comment.innerHTML = "Right is more than 5 times faster!";
		}else if(xl > 3*xr){
			comment.innerHTML = "Right is more than 3 times faster!";
		}else if(xl > 2*xr){
			comment.innerHTML = "Right is more than 2 times faster!";
		}else if(xl > 1.5*xr){
			comment.innerHTML = "Right is more than 50% faster.";
		}else if(xl > 1.25*xr){
			comment.innerHTML = "Right is more than 25% faster.";
		}else if(xl > 1.1*xr){
			comment.innerHTML = "Right is more than 10% faster.";
		}else{
			comment.innerHTML = "Right is slightly faster.";
		}
	}else if(xr > xl){
		if(xr > 20*xl){
			comment.innerHTML = "Left is more than 20 times faster!";
		}else if(xr > 10*xl){
			comment.innerHTML = "Left is more than 10 times faster!";
		}else if(xr > 5*xl){
			comment.innerHTML = "Left is more than 5 times faster!";
		}else if(xr > 3*xl){
			comment.innerHTML = "Left is more than 3 times faster!";
		}else if(xr > 2*xl){
			comment.innerHTML = "Left is more than 2 times faster!";
		}else if(xr > 1.5*xl){
			comment.innerHTML = "Left is more than 50% faster.";
		}else if(xr > 1.25*xl){
			comment.innerHTML = "Left is more than 25% faster.";
		}else if(xr > 1.1*xl){
			comment.innerHTML = "Left is more than 10% faster.";
		}else{
			comment.innerHTML = "Left is slightly faster.";
		}
	}
}

function position_slider(no, client_x){
	if(!slider_set[no]){
		var slider = document.getElementById("slider_" + (no + 1));
		var canvas_rect = slider.getBoundingClientRect();
		var x = client_x - canvas_rect.left - 48;
		if(x < 16)
			x = 16;
		if(x > 511 - 16)
			x = 511 - 16;
		slider_xs[no] = x;

		comment_on_slider(no);
	}
}

function init_slider(no){
	draw_slider(no);
	var slider = document.getElementById("slider_" + (no + 1));

	slider.addEventListener('pointerleave', function(e){
		slider_down = false;
	}, false);

	slider.addEventListener('pointerup', function(e){
		slider_down = false;
	}, false);

	slider.addEventListener('pointerdown', function(e){
		slider_down = true;
		position_slider(no, e.clientX);
		draw_slider(no);
		slider.releasePointerCapture(e.pointerId);
	}, false);

	slider.addEventListener('pointermove', function(e){
		if(slider_down){
			position_slider(no, e.clientX);
			draw_slider(no);
		}
	}, false);
}

function draw_slider(no){
	ctx = document.getElementById("slider_" + (no + 1)).getContext("2d");
	x = slider_xs[no] + 48 + 0.5;

	ctx.clearRect(0, 0, 608, 128);
	ctx.beginPath();
	ctx.moveTo(64.5-16, 32.5);
	ctx.lineTo(0.5 + 16, 127.5 - 32);
	ctx.lineTo(607.5 - 16, 127.5 - 32);
	ctx.lineTo(607.5 - 64 + 16, 32.5);
	ctx.lineTo(64.5-16, 32.5);
	ctx.strokeStyle="#000000";
	ctx.stroke();
	ctx.closePath();
	ctx.fillStyle="#999999";
	ctx.fill();

	if(slider_set[no]){
		x_red = slider_user_xs[no] + 48 + 0.5;
		ctx.beginPath();
		ctx.moveTo(x_red, 0);
		ctx.lineTo(x_red - 64, 127);
		ctx.lineTo(x_red + 64, 127);
		ctx.lineTo(x_red, 0);
		ctx.strokeStyle="#660000";
		ctx.stroke();
		ctx.closePath();
		ctx.fillStyle="#ffcccc";
		ctx.fill();
	}

	ctx.beginPath();
	ctx.moveTo(x, 0);
	ctx.lineTo(x - 64, 127);
	ctx.lineTo(x + 64, 127);
	ctx.lineTo(x, 0);
	ctx.strokeStyle="#000000";
	ctx.stroke();
	ctx.closePath();
	ctx.fillStyle="#cccccc";
	ctx.fill();
}

function reveal(no){
	slider_set[no] = true;
	slider_user_xs[no] = slider_xs[no];
	slider_xs[no] = slider_true_xs[no];
	draw_slider(no);
	comment_on_slider(no);
	document.getElementById("the_truth_" + (no + 1)).style.display = "block";
	document.getElementById("button_" + (no + 1)).style.display = "none";

	for(var i = 0; i < sliders; i++){
		if(slider_set[i] == false)
			return;
	}

	document.getElementById("show_in_the_end").style.display = "block";
	var score = 0;
	var default_score = 0;
	for(var i = 0; i < sliders; i++){
		score += Math.abs(slider_user_xs[i] - slider_xs[i]);
		default_score += Math.abs(256 - slider_xs[i]);
	}

	document.getElementById("score").innerHTML = "<b>" + score.toFixed(0) + "</b>";
	document.getElementById("default_score").innerHTML = "<b>" + default_score.toFixed(0) + "</b>";


	if(score < default_score*0.25)
		document.getElementById("superb_bragging_rights").style.display = "block";
	else if(score < default_score)
		document.getElementById("bragging_rights").style.display = "block";
}

function next(slides){
	// show the next slide
	var first_slide = document.getElementById(slides + "_" + 1);
	for(var i = 1; i < 10; ++i)
	{
		var this_slide = document.getElementById(slides + "_" + i);
		var next_slide = document.getElementById(slides + "_" + (i+1));
		if(this_slide)
			if(this_slide.style.display == "block")
				{
				this_slide.style.display = "none";
				if(next_slide)
					next_slide.style.display = "block";
				else
					first_slide.style.display = "block";
				break;
				}
	}
	// name the button
	var button = document.getElementById(slides + "_button")
	for(var i = 1; i < 10; ++i)
	{
		var this_slide = document.getElementById(slides + "_" + i);
		var next_slide = document.getElementById(slides + "_" + (i+1));
		if (this_slide && !next_slide && this_slide.style.display == "block") {
			button.innerHTML = "Back to the 1-st slide";
			break;
		}
		else
			button.innerHTML = "Next slide";
	}
}

function colorized(text) {
	const separators = ['\n', ' ', '\t', '.', ',', ':', '=', '[', ']', '(', ')'];
	const comments = [['/*', '*/'], ['#', '\n']];

	function painted_in(line, color) {
		return line.length == 0 ? "" : "<span style=\"color:#" + color + "\">" + line + "</span>";
	}

	function colorized(token) {
		var code_sum = 0;
		for(var i = 0; i < token.length; ++i)
			code_sum += ([1, 7, 11, 13][i % 4] * token.charCodeAt(i));
		var zero_channel = code_sum % 3;
		var color = '' + (zero_channel == 0 ? '0' : '') + (1 + (code_sum % 5) * 2)
			+ (zero_channel == 1 ? '0' : '') + (4 + (code_sum % 2) * 5)
			+ (zero_channel == 2 ? '0' : '');
		return painted_in(token, color);
	}

	function separated(line, i) {
		if(i == separators.length)
			return colorized(line);
		return line.split(separators[i]).map(function(subline) {
			return separated(subline, i + 1);}).join(separators[i]);
	}

	function uncommented(line, i) {
		if(i == comments.length)
			return separated(line, 0);
		var chunks = line.split(comments[i][0]);
		return uncommented(chunks[0], i + 1) + chunks.slice(1).map( function(chunk) {
			var in_out_comment = chunk.split(comments[i][1]);
			return painted_in(comments[i][0] + in_out_comment[0] + (in_out_comment.length > 1 ? comments[i][1] : ''), "777")
				+ uncommented(in_out_comment.slice(1).join(comments[i][1]), i + 1);}).join('');
	}

	return uncommented(text, 0);
}
	</script>
</head>
<body>
	<center>
	<p style="width: 600pt; padding: 36pt 0pt 64pt 0pt;">This is <a href="index.html">Words and Buttons Online</a> — a collection of&nbsp;interactive <a href="all_tutorials.html">#tutorials</a>, <a href="all_demos.html">#demos<a/>, and <a href="all_quizzes.html">#quizzes</a> about <a href="all_mathematics.html">#mathematics</a>, <a href="all_algorithms.html">#algorithms</a> and <a href="all_programming.html">#programming</a>.</p>
	<h1>
Challenge your performance intuition with nanosecond sorting
	</h1>
	<p>
In the physical world, nanotechnology predictably brings us surprises. Being structured on nano-scale, the most common materials, such as carbon, iron or copper, gain new unforeseen properties. What we know about them on the macro-scale do not apply anymore.
	</p>
	<p>
Surprisingly, a very similar effect happens in computation. If the operation you want to speed-up already runs in a few nano-seconds, your reasoning about algorithmic complexity probably wouldn't apply.
	</p>
	<p>
The most effective algorithms become mediocre while the useless rise from the oblivion to shine and amaze. One of these algorithms is the index sort. It has unconditional <i>O(n<sup>2</sup>)</i> complexity and this makes it probably the least performant sorting algorithm you never heard about. It's useless on the macro-scale. But on the nano-scale, it excels.
	</p>
	<h2>
Index sort
	</h2>
	<p>
The idea of index sort is this. For every item in the assorted array, you can find its index in the sorted array by comparing it to all the others.
	</p>

	<table><tr>
	<td style="width:600pt;">
	<pre><span id="slides_is_1" style="display:block;"><div style="color:#994466"><b>Example</b></div>
X (assorted): 3 2 4 2

   Xi   Comparisons                     Index
         3       2       4       2
    3           >       >       >       ?

    2   >=              >       >       ?

    4   >=      >=              >       ?

    2   >=      >=      >=              ?




</span><span id="slides_is_2" style="display:none;"><div style="color:#994466"><b>Example</b></div>
X (assorted): 3 2 4 2

   Xi   Comparisons                     Index
         3       <b>2</b>       4       2
    <b>3</b>           <u>></u>       >       >       1+?

    2   >=              >       >       ?

    4   >=      >=              >       ?

    2   >=      >=      >=              ?




</span><span id="slides_is_3" style="display:none;"><div style="color:#994466"><b>Example</b></div>
X (assorted): 3 2 4 2

   Xi   Comparisons                     Index
         3       2       4       <b>2</b>
    <b>3</b>           <b>></b>       >       <u>></u>       <u>2</u>

    2   >=              >       >       ?

    4   >=      >=              >       ?

    2   >=      >=      >=              ?




</span><span id="slides_is_4" style="display:none;"><div style="color:#994466"><b>Example</b></div>
X (assorted): 3 2 4 2

   Xi   Comparisons                     Index
         3       2       4       2
    3           <b>></b>       >       <b>></b>       2

    2   >=              >       >       <u>0</u>

    4   >=      >=              >       ?

    2   >=      >=      >=              ?




</span><span id="slides_is_5" style="display:none;"><div style="color:#994466"><b>Example</b></div>
X (assorted): 3 2 4 2

   Xi   Comparisons                     Index
         <b>3</b>       2       4       2
    3           <b>></b>       >       <b>></b>       2

    2   >=              >       >       0

    <b>4</b>   <u>>=</u>      >=              >       1+?

    2   >=      >=      >=              ?




</span><span id="slides_is_6" style="display:none;"><div style="color:#994466"><b>Example</b></div>
X (assorted): 3 2 4 2

   Xi   Comparisons                     Index
         3       <b>2</b>       4       2
    3           <b>></b>       >       <b>></b>       2

    2   >=              >       >       0

    <b>4</b>   <b>>=</b>      <u>>=</u>              >       2+?

    2   >=      >=      >=              ?




</span><span id="slides_is_7" style="display:none;"><div style="color:#994466"><b>Example</b></div>
X (assorted): 3 2 4 2

   Xi   Comparisons                     Index
         3       2       4       <b>2</b>
    3           <b>></b>       >       <b>></b>       2

    2   >=              >       >       0

    <b>4</b>   <b>>=</b>      <b>>=</b>              <u>></u>       <u>3</u>

    2   >=      >=      >=              ?




</span><span id="slides_is_8" style="display:none;"><div style="color:#994466"><b>Example</b></div>
X (assorted): 3 2 4 2

   Xi   Comparisons                     Index
         3       <b>2</b>       4       2
    3           <b>></b>       >       <b>></b>       2

    2   >=              >       >       0

    4   <b>>=</b>      <b>>=</b>              <b>></b>       3

    <b>2</b>   >=      <u>>=</u>      >=              <u>1</u>




</span><span id="slides_is_9" style="display:none;"><div style="color:#994466"><b>Example</b></div>
X (assorted): 3 2 4 2

   Xi   Comparisons                     Index
         3       2       4       2
    3           >       >       >       2

    2   >=              >       >       0

    4   >=      >=              >       3

    2   >=      >=      >=              1


                           Xs (sorted): <u>2 2 3 4</u>
       <i>(Xs[2] = 3, Xs[0] = 2, Xs[3] = 8, Xs[1] = 2)</i>
</span></pre></td>
	</td></tr></table>
	<p style="text-align:right">
	<button type="button" id="slides_is_button" onclick="next('slides_is')"><nobr>Next step</nobr></button>
	</p>
	<p>
It's not algorithmically elegant. But it's deterministic meaning that you can avoid branching completely. On small arrays, this should be a noticeable advantage.
	</p>
	<h2>
And now for the challenge
	</h2>
	<p>
Let's compare how different sorting works on triplets — arrays of three elements. You might think that this is a rare task but when you work with 3D graphics it comes up surprisingly often. Last year alone I did triplet sorting for triangles' indices, for cubic equation roots, and for axis-oriented bounding box' dimensions.
	</p>
	<p>
Tasks like that are rarely bottlenecks but if you can speed up your algorithm for even 12% with no measurable effort, it's probably worth doing.
	</p>
	<p>
Anyway, here is my benchmark.
	</p>
	<table><tr>
	<td>
	<pre style="width: 600pt;">
constexpr size_t samples = 10'000'000;
std::array&lt;std::array&lt;int, 3&gt;, samples&gt; g_data;

static void ResetData() {
    std::mt19937 rng(0);
    std::uniform_int_distribution&lt;int&gt; random_number(1, 100);
    for (auto& numbers : g_data) {
        numbers[0] = random_number(rng);
        numbers[1] = random_number(rng);
        numbers[2] = random_number(rng);
    }
}

int CheckDataForMissorts() {
    int missorts = 0;
    for (auto& numbers : g_data) {
        if(numbers[1] &lt; numbers[0] || numbers[2] &lt; numbers[1])
            missorts++;
    }
    return missorts;
}

#define MEASURE(CODE_TO_MEASURE, NAME_TO_PRINT) \
    { \
    ResetData();    \
    auto start = std::chrono::system_clock::now(); \
    for(auto& t : g_data) { \
        CODE_TO_MEASURE \
    }   \
    auto end = std::chrono::system_clock::now(); \
    std::chrono::duration&lt;double&gt; time = end - start; \
    std::cout &lt;&lt; time.count() &lt;&lt; " - " &lt;&lt; NAME_TO_PRINT; \
    std::cout &lt;&lt; "\n"; \
    std::cout &lt;&lt; "missorts: " &lt;&lt; CheckDataForMissorts(); \
    std::cout &lt;&lt; "\n\n"; \
    }
    </pre>
	</td></tr></table>
	<p>
It generates a lot of triplets, runs a piece of code a lot of times, and reports the total running time.
	</p>
	<p>
All the pieces of code are compiled with GCC 5.4.0: <i>g++ -std=c++14 -O3</i>, and measured on Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz.
	</p>
	<p>
Everything (spoilers including) is <a href="https://github.com/akalenuk/wordsandbuttons/tree/master/exp/sort/nanosort">availabe on GitHub</a>.
	</p>
	<p>
Using your intuition and best judgment, please estimate their relative performance. Please use the slider below the code samples.
	</p>

	<h2>
Round 1.
	</h2>
	<p>
The main question, the question #1 that has to be answered before anything else: why don't you use std::sort?
	</p>
	<table><tr>
	<td id="left_1">
	<pre>
std::sort(t.begin(), t.end());
    </pre>
	</td>
	<td id="right_1">
	<pre>
const auto a = t[0];
const auto b = t[1];
const auto c = t[2];
t[int(a > b) + int(a > c)] = a;
t[int(b >= a) + int(b > c)] = b;
t[int(c >= a) + int(c >= b)] = c;
	</pre>
	</td></tr></table>
	<canvas id="slider_1" width=608 height=128></canvas>
	<p class="comment" id="comment_1">
They are almost the same.
	</p>
	<button type="button" onclick="reveal(0)" id="button_1"><nobr>Reveal the truth</nobr></button>
	<div id="the_truth_1" style="display:none;">
	<p>
Index sort is five times faster in this context.
	</p>
	<p>
But in a different context, it might not work all that well. For instance, on ARMv7 (v7l) it's only 2 times faster. And with clang (Debian clang 3.5.0) it's even less drastic.
	</p>
	<p>
Clang's sort seems to be slightly better on small arrays generally. On my testing Intel i7 it's also 20% faster than the GCC version. Still, not enough to make it interesting so let's move along with the index sort.
	</p>
	</div>
	<script language="JavaScript">
	init_slider(0);
	</script>

	<h2>
Round 2.
	</h2>
	<p>
Sorting triplets is fun but can we generalise it with no additional overhead?
	</p>
	<table><tr>
	<td id="left_2">
	<pre>
const auto a = t[0];
const auto b = t[1];
const auto c = t[2];
t[int(a &gt; b) + int(a &gt; c)] = a;
t[int(b &gt;= a) + int(b &gt; c)] = b;
t[int(c &gt;= a) + int(c &gt;= b)] = c;
    </pre>
	</td>
	<td id="right_2">
	<pre>
template &lt;size_t N&gt;
void index_sort(std::array&lt;int, N&gt;& t) {
    std::array&lt;int, N&gt; a = t;
    for(auto i = 0u; i &lt; N; ++i) {
        auto k = 0u;
        for(auto j = 0u; j &lt; N; ++j) {
            if(j &gt; i)
                k += int(a[i] &gt; a[j]);
            else if(j &lt; i)
                k += int(a[i] &gt;= a[j]);
        }
        t[k] = a[i];
    }
}
    </pre>
	</td></tr></table>
	<canvas id="slider_2" width=608 height=128></canvas>
	<p class="comment" id="comment_2">
They are almost the same.
	</p>
	<button type="button" onclick="reveal(1)" id="button_2"><nobr>Reveal the truth</nobr></button>
	<div id="the_truth_2" style="display:none;">
	<p>
Yes, we can. And even with... negative overhead?
	</p>
	<p>
<a href="https://godbolt.org/#g:!((g:!((g:!((h:codeEditor,i:(j:1,lang:c%2B%2B,source:'%23include+%3Carray%3E%0A%0Atemplate+%3Clong+unsigned+int+N%3E+%0Avoid+index_sort(std::array%3Cint,+N%3E%26+t)+%7B%0A++++std::array%3Cint,+N%3E+a+%3D+t%3B%0A++++for(auto+i+%3D+0u%3B+i+%3C+N%3B+%2B%2Bi)%0A++++%7B%0A++++++++auto+k+%3D+0u%3B%0A++++++++for(auto+j+%3D+0u%3B+j+%3C+N%3B+%2B%2Bj)+%0A++++++++%7B%0A++++++++++++if(j+%3E+i)%0A++++++++++++++++k+%2B%3D+int(a%5Bi%5D+%3E+a%5Bj%5D)%3B%0A++++++++++++else+if(j+%3C+i)%0A++++++++++++++++k+%2B%3D+int(a%5Bi%5D+%3E%3D+a%5Bj%5D)%3B%0A++++++++%7D%0A++++++++t%5Bk%5D+%3D+a%5Bi%5D%3B%0A++++%7D%0A%7D%0A%0Avoid+sort(std::array%3Cint,+3%3E%26+t)+%7B%0A++++index_sort(t)%3B%0A%7D'),l:'5',n:'0',o:'C%2B%2B+source+%231',t:'0')),k:33.333333333333336,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:compiler,i:(compiler:g540,filters:(b:'0',binary:'1',commentOnly:'0',demangle:'0',directives:'0',execute:'1',intel:'0',libraryCode:'1',trim:'1'),lang:c%2B%2B,libs:!(),options:'-O3+--std%3Dc%2B%2B14',source:1),l:'5',n:'0',o:'x86-64+gcc+5.4+(Editor+%231,+Compiler+%231)+C%2B%2B',t:'0')),k:48.02304268133018,l:'4',n:'0',o:'',s:0,t:'0'),(g:!((h:output,i:(compiler:1,editor:1,wrap:'1'),l:'5',n:'0',o:'%231+with+x86-64+gcc+5.4',t:'0')),k:18.643623985336475,l:'4',n:'0',o:'',s:0,t:'0')),l:'2',n:'0',o:'',t:'0')),version:4">godbolt</a> doesn't show any conceptual advantage.
	</p>
	<table><tr>
	<td>
	<pre id="code_2_1">
        mov     eax, DWORD PTR [rdi]
        mov     ecx, DWORD PTR [rdi+4]
        xor     r8d, r8d
        mov     edx, DWORD PTR [rdi+8]
        cmp     eax, ecx
        setg    r8b
        xor     esi, esi
        cmp     eax, edx
        setg    sil
        add     esi, r8d
        xor     r8d, r8d
        cmp     eax, ecx
        movsx   rsi, esi
        setle   r8b
        mov     DWORD PTR [rdi+rsi*4], eax
        xor     esi, esi
        cmp     ecx, edx
        setg    sil
        add     esi, r8d
        movsx   rsi, esi
        mov     DWORD PTR [rdi+rsi*4], ecx
        xor     esi, esi
        cmp     eax, edx
        setle   sil
        xor     eax, eax
        cmp     ecx, edx
        setle   al
        add     eax, esi
        cdqe
        mov     DWORD PTR [rdi+rax*4], edx
        ret
    </pre>
	</td>
	<td>
	<pre id="code_2_2">
        mov     rax, QWORD PTR [rdi]
        mov     ecx, DWORD PTR [rdi+8]
        xor     esi, esi
        mov     edx, eax
        shr     rax, 32
        cmp     edx, eax
        setg    sil
        xor     r8d, r8d
        cmp     edx, ecx
        setg    r8b
        add     esi, r8d
        mov     DWORD PTR [rdi+rsi*4], edx
        xor     esi, esi
        cmp     edx, eax
        setle   sil
        xor     r8d, r8d
        cmp     ecx, eax
        setl    r8b
        add     esi, r8d
        cmp     edx, ecx
        setle   dl
        cmp     ecx, eax
        mov     DWORD PTR [rdi+rsi*4], eax
        setge   al
        movzx   edx, dl
        movzx   eax, al
        add     eax, edx
        mov     DWORD PTR [rdi+rax*4], ecx
        ret
    </pre>
	</td></tr></table>
	<p>
The code is not drastically different and it has no reason to be. My theory is that this gain is accidental. The most surprisingly, it reproduces well across compilers and CPUs.
	</p>
	</div>
	<script language="JavaScript">
	init_slider(1);
	</script>


	<h2>
Round 3.
	</h2>
	<p>
For a triplet, there is another std::sort substitude and it's just three conditional swaps.
	</p>
	<table><tr>
	<td id="left_3">
	<pre>
template &lt;size_t N&gt;
void index_sort(std::array&lt;int, N&gt;& t) {
    std::array&lt;int, N&gt; a = t;
    for(auto i = 0u; i &lt; N; ++i) {
        auto k = 0u;
        for(auto j = 0u; j &lt; N; ++j) {
            if(j &gt; i)
                k += int(a[i] &gt; a[j]);
            else if(j &lt; i)
                k += int(a[i] &gt;= a[j]);
        }
        t[k] = a[i];
    }
}
    </pre>
	</td>
	<td id="right_3">
	<pre>
void swap_sort(std::array&lt;int, 3&gt;& t) {
    auto sort_ = [](auto& a, auto& b) {
        if (a &gt; b)
            std::swap(a, b);
    };
    sort_(t[0], t[1]);
    sort_(t[1], t[2]);
    sort_(t[0], t[1]);
}
    </pre>
	</td></tr></table>
	<canvas id="slider_3" width=608 height=128></canvas>
	<p class="comment" id="comment_3">
They are almost the same.
	</p>
	<button type="button" onclick="reveal(2)" id="button_3"><nobr>Reveal the truth</nobr></button>
	<div id="the_truth_3" style="display:none;">
	<p>
They still work faster than std::sort but not as fast as the index sort. However, that's on modern Intel. On ARMv7 branching doesn't make all that difference and the measurements are almost identical.
	</p>
	<p>
The code is pretty straightforward.
	</p>
	<table><tr>
	<td>
	<pre id="code_3_1">
        mov     rax, QWORD PTR [rdi]
        mov     ecx, DWORD PTR [rdi+8]
        xor     esi, esi
        mov     edx, eax
        shr     rax, 32
        cmp     edx, eax
        setg    sil
        xor     r8d, r8d
        cmp     edx, ecx
        setg    r8b
        add     esi, r8d
        mov     DWORD PTR [rdi+rsi*4], edx
        xor     esi, esi
        cmp     edx, eax
        setle   sil
        xor     r8d, r8d
        cmp     ecx, eax
        setl    r8b
        add     esi, r8d
        cmp     edx, ecx
        setle   dl
        cmp     ecx, eax
        mov     DWORD PTR [rdi+rsi*4], eax
        setge   al
        movzx   edx, dl
        movzx   eax, al
        add     eax, edx
        mov     DWORD PTR [rdi+rax*4], ecx
        ret
    </pre>
	</td>
	<td>
	<pre id="code_3_2">
        mov     eax, DWORD PTR [rdi]
        mov     edx, DWORD PTR [rdi+4]
        cmp     eax, edx
        jle     .L2
        mov     ecx, DWORD PTR [rdi+8]
        mov     DWORD PTR [rdi], edx
        mov     DWORD PTR [rdi+4], eax
        cmp     ecx, eax
        jge     .L1
        mov     esi, edx
        mov     edx, eax
        mov     eax, esi
.L6:
        cmp     eax, ecx
        mov     DWORD PTR [rdi+4], ecx
        mov     DWORD PTR [rdi+8], edx
        jle     .L1
        mov     DWORD PTR [rdi], ecx
        mov     DWORD PTR [rdi+4], eax
        ret
.L2:
        mov     ecx, DWORD PTR [rdi+8]
        cmp     edx, ecx
        jg      .L6
.L1:
        rep ret
    </pre>
	</td></tr></table>
	<p>
It's three pairs of jump and compare.
	</p>
	</div>
	<script language="JavaScript">
	init_slider(2);
	</script>


	<h2>
Round 4.
	</h2>
	<p>
What if we do std::min/std::max instead of conditional swaps?
	</p>
	<table><tr>
	<td id="left_4">
	<pre>
void swap_sort(std::array&lt;int, 3&gt;& t) {
    auto sort_ = [](auto& a, auto& b) {
        if (a &gt; b)
            std::swap(a, b);
    };
    sort_(t[0], t[1]);
    sort_(t[1], t[2]);
    sort_(t[0], t[1]);
}
    </pre>
	</td>
	<td id="right_4">
	<pre>
void swap_sort_no_ifs
    (std::array&lt;int, 3&gt;& t) {
    auto sort_ = [](auto& a, auto& b) {
        const auto temp = std::min(a, b);
        b = std::max(a, b);
        a = temp;
    };
    sort_(t[0], t[1]);
    sort_(t[1], t[2]);
    sort_(t[0], t[1]);
}
    </pre>
	</td></tr></table>
	<canvas id="slider_4" width=608 height=128></canvas>
	<p class="comment" id="comment_4">
They are almost the same.
	</p>
	<button type="button" onclick="reveal(3)" id="button_4"><nobr>Reveal the truth</nobr></button>
	<div id="the_truth_4" style="display:none;">
	<p>
With GCC, there is virtually no difference.
	</p>
	<table><tr>
	<td>
	<pre id="code_4_1">
        mov     eax, DWORD PTR [rdi]
        mov     edx, DWORD PTR [rdi+4]
        cmp     eax, edx
        jle     .L2
        mov     ecx, DWORD PTR [rdi+8]
        mov     DWORD PTR [rdi], edx
        mov     DWORD PTR [rdi+4], eax
        cmp     ecx, eax
        jge     .L1
        mov     esi, edx
        mov     edx, eax
        mov     eax, esi
.L6:
        cmp     eax, ecx
        mov     DWORD PTR [rdi+4], ecx
        mov     DWORD PTR [rdi+8], edx
        jle     .L1
        mov     DWORD PTR [rdi], ecx
        mov     DWORD PTR [rdi+4], eax
        ret
.L2:
        mov     ecx, DWORD PTR [rdi+8]
        cmp     edx, ecx
        jg      .L6
.L1:
        rep ret
    </pre>
	</td>
	<td>
	<pre id="code_4_2">
        mov     edx, DWORD PTR [rdi+4]
        mov     eax, DWORD PTR [rdi]
        cmp     edx, eax
        jl      .L8
        mov     esi, eax
        jle     .L2
        mov     ecx, DWORD PTR [rdi+8]
        cmp     ecx, edx
        jl      .L10
.L15:
        mov     eax, edx
        jle     .L4
.L5:
        cmp     eax, esi
        mov     DWORD PTR [rdi+8], ecx
        jl      .L12
        mov     edx, esi
        jle     .L6
        mov     DWORD PTR [rdi+4], eax
        mov     DWORD PTR [rdi], edx
        ret
.L12:
        mov     edx, eax
.L6:
        mov     eax, esi
        mov     DWORD PTR [rdi], edx
        mov     DWORD PTR [rdi+4], eax
        ret
.L8:
        mov     esi, edx
.L2:
        mov     ecx, DWORD PTR [rdi+8]
        mov     edx, eax
        cmp     ecx, edx
        jge     .L15
.L10:
        mov     eax, ecx
.L4:
        mov     ecx, edx
        jmp     .L5
    </pre>
	</td></tr></table>
	<p>
Again, the code is accidentally different but it's essentially the same thing.
	</p>
	<p>
However, with Clang the difference is obvious.
	</p>
	<table><tr>
	<td>
	<pre id="code_4_1_">
        mov     ecx, dword ptr [rdi]
        mov     edx, dword ptr [rdi + 4]
        cmp     ecx, edx
        jle     .LBB0_1
        mov     dword ptr [rdi], edx
        mov     dword ptr [rdi + 4], ecx
        mov     eax, edx
        jmp     .LBB0_3
.LBB0_1:
        mov     eax, ecx
        mov     ecx, edx
.LBB0_3:
        mov     edx, dword ptr [rdi + 8]
        cmp     ecx, edx
        jle     .LBB0_4
        mov     dword ptr [rdi + 4], edx
        mov     dword ptr [rdi + 8], ecx
        jmp     .LBB0_6
.LBB0_4:
        mov     edx, ecx
.LBB0_6:
        cmp     eax, edx
        jle     .LBB0_8
        mov     dword ptr [rdi], edx
        mov     dword ptr [rdi + 4], eax
.LBB0_8:
        ret
    </pre>
	</td>
	<td>
	<pre id="code_4_2_">
        mov     eax, dword ptr [rdi]
        mov     ecx, dword ptr [rdi + 4]
        cmp     ecx, eax
        mov     edx, eax
        cmovle  edx, ecx
        cmp     eax, ecx
        cmovl   eax, ecx
        mov     ecx, dword ptr [rdi + 8]
        cmp     ecx, eax
        mov     esi, eax
        cmovle  esi, ecx
        cmp     eax, ecx
        cmovl   eax, ecx
        mov     dword ptr [rdi + 8], eax
        cmp     esi, edx
        mov     eax, edx
        cmovle  eax, esi
        cmp     edx, esi
        cmovge  esi, edx
        mov     dword ptr [rdi + 4], esi
        mov     dword ptr [rdi], eax
        ret
    </pre>
	</td></tr></table>
	<p>
The min/max version is branchless! Clang uses the conditional moves instead of conditional jumps and this makes the code on the right five times faster on the very same CPU.
	</p>
	</div>
	<script language="JavaScript">
	init_slider(3);
	</script>


	<h2>
Round 5.
	</h2>
	<p>
You don't have to rely on the compiler to make the deterministic conditional swap. There is an arithmetic trick that lets you sort a pair of numbers.
	</p>
	<p>
A half-sum of a pair minus half-difference is the lowest number; a half-sum plus a half-difference is the greatest. Of course, they are the same when their half-difference is 0.
	</p>
	<p>
This limits the application of this sorting. With integers, you can accidentally overflow, and with floating-point numbers, you can lose precision if the numbers have different exponent. But let's just presume this works for us. Let's see which is faster.
	</p>
	<table><tr>
	<td id="left_5">
	<pre>
void swap_sort_no_ifs
    (std::array&lt;int, 3&gt;& t) {
    auto sort_ = [](auto& a, auto& b) {
        const auto temp = std::min(a, b);
        b = std::max(a, b);
        a = temp;
    };
    sort_(t[0], t[1]);
    sort_(t[1], t[2]);
    sort_(t[0], t[1]);
}
    </pre>
	</td>
	<td id="right_5">
	<pre>
void swap_sort_arithmetic_hack
    (std::array&lt;int, 3&gt;& t) {
    auto sort_ = [](auto& a, auto& b) {
        auto sum = a+b;
        auto diff = std::abs(a-b);
        a = (sum - diff) / 2;
        b = (sum + diff) / 2;
    };
    sort_(t[0], t[1]);
    sort_(t[1], t[2]);
    sort_(t[0], t[1]);
}
    </pre>
	</td></tr></table>
	<canvas id="slider_5" width=608 height=128></canvas>
	<p class="comment" id="comment_5">
They are almost the same.
	</p>
	<button type="button" onclick="reveal(4)" id="button_5"><nobr>Reveal the truth</nobr></button>
	<div id="the_truth_5" style="display:none;">
	<p>
The code is a little excessive but it is deterministic. It is branchless.
	</p>
	<table><tr>
	<td>
	<pre id="code_5_1">
        mov     edx, DWORD PTR [rdi+4]
        mov     eax, DWORD PTR [rdi]
        cmp     edx, eax
        jl      .L8
        mov     esi, eax
        jle     .L2
        mov     ecx, DWORD PTR [rdi+8]
        cmp     ecx, edx
        jl      .L10
.L15:
        mov     eax, edx
        jle     .L4
.L5:
        cmp     eax, esi
        mov     DWORD PTR [rdi+8], ecx
        jl      .L12
        mov     edx, esi
        jle     .L6
        mov     DWORD PTR [rdi+4], eax
        mov     DWORD PTR [rdi], edx
        ret
.L12:
        mov     edx, eax
.L6:
        mov     eax, esi
        mov     DWORD PTR [rdi], edx
        mov     DWORD PTR [rdi+4], eax
        ret
.L8:
        mov     esi, edx
.L2:
        mov     ecx, DWORD PTR [rdi+8]
        mov     edx, eax
        cmp     ecx, edx
        jge     .L15
.L10:
        mov     eax, ecx
.L4:
        mov     ecx, edx
        jmp     .L5
    </pre>
	</td>
	<td>
	<pre id="code_5_2">
        mov     edx, DWORD PTR [rdi+4]
        mov     eax, DWORD PTR [rdi]
        lea     ecx, [rax+rdx]
        sub     eax, edx
        cdq
        xor     eax, edx
        sub     eax, edx
        mov     edx, ecx
        sub     edx, eax
        add     eax, ecx
        mov     ecx, eax
        mov     esi, edx
        shr     ecx, 31
        shr     esi, 31
        add     eax, ecx
        mov     ecx, DWORD PTR [rdi+8]
        add     edx, esi
        sar     eax
        sar     edx
        lea     r8d, [rcx+rax]
        sub     eax, ecx
        mov     ecx, eax
        sar     ecx, 31
        xor     eax, ecx
        sub     eax, ecx
        mov     ecx, r8d
        sub     ecx, eax
        add     eax, r8d
        mov     esi, ecx
        shr     esi, 31
        add     esi, ecx
        mov     ecx, eax
        shr     ecx, 31
        sar     esi
        add     eax, ecx
        lea     ecx, [rsi+rdx]
        sar     eax
        mov     DWORD PTR [rdi+8], eax
        mov     eax, edx
        sub     eax, esi
        cdq
        xor     eax, edx
        sub     eax, edx
        mov     edx, ecx
        sub     edx, eax
        mov     esi, edx
        shr     esi, 31
        add     edx, esi
        sar     edx
        add     eax, ecx
        mov     DWORD PTR [rdi], edx
        mov     edx, eax
        shr     edx, 31
        add     eax, edx
        sar     eax
        mov     DWORD PTR [rdi+4], eax
        ret
    </pre>
	</td></tr></table>
	<p>
Since we're already knee-deep into limitations, why don't we try a truly integer-specific hack?
	</p>
	</div>
	<script language="JavaScript">
	init_slider(4);
	</script>


	<h2>
Round 6.
	</h2>
	<p>
I'll be honest, I stole this from somewhere on the Internet and I don't know how exactly this works. Apparently, it works just fine on an integer half-range so it's also limited.
	</p>
	<p>
But would it be faster?
	</p>
	<table><tr>
	<td id="left_6">
	<pre>
void swap_sort_arithmetic_hack
    (std::array&lt;int, 3&gt;& t) {
    auto sort_ = [](auto& a, auto& b) {
        auto sum = a+b;
        auto diff = std::abs(a-b);
        a = (sum - diff) / 2;
        b = (sum + diff) / 2;
    };
    sort_(t[0], t[1]);
    sort_(t[1], t[2]);
    sort_(t[0], t[1]);
}
    </pre>
	</td>
	<td id="right_6">
	<pre>
void swap_sort_bit_hack
    (std::array&lt;int, 3&gt;& t) {
    auto sort_ = [](auto& x, auto& y) {
        constexpr auto shift =
            (sizeof(int) * CHAR_BIT - 1);
        const auto temp =
            y + ((x - y) & ((x - y) &gt;&gt; shift));
        y = x - ((x - y) & ((x - y) &gt;&gt; shift));
        x = temp;
    };
    sort_(t[0], t[1]);
    sort_(t[1], t[2]);
    sort_(t[0], t[1]);
}
    </pre>
	</td></tr></table>
	<canvas id="slider_6" width=608 height=128></canvas>
	<p class="comment" id="comment_6">
They are almost the same.
	</p>
	<button type="button" onclick="reveal(5)" id="button_6"><nobr>Reveal the truth</nobr></button>
	<div id="the_truth_6" style="display:none;">
	<p>
It is even faster than before and it generates even better code.
	</p>
	<table><tr>
	<td>
	<pre id="code_6_1">
        mov     edx, DWORD PTR [rdi+4]
        mov     eax, DWORD PTR [rdi]
        lea     ecx, [rax+rdx]
        sub     eax, edx
        cdq
        xor     eax, edx
        sub     eax, edx
        mov     edx, ecx
        sub     edx, eax
        add     eax, ecx
        mov     ecx, eax
        mov     esi, edx
        shr     ecx, 31
        shr     esi, 31
        add     eax, ecx
        mov     ecx, DWORD PTR [rdi+8]
        add     edx, esi
        sar     eax
        sar     edx
        lea     r8d, [rcx+rax]
        sub     eax, ecx
        mov     ecx, eax
        sar     ecx, 31
        xor     eax, ecx
        sub     eax, ecx
        mov     ecx, r8d
        sub     ecx, eax
        add     eax, r8d
        mov     esi, ecx
        shr     esi, 31
        add     esi, ecx
        mov     ecx, eax
        shr     ecx, 31
        sar     esi
        add     eax, ecx
        lea     ecx, [rsi+rdx]
        sar     eax
        mov     DWORD PTR [rdi+8], eax
        mov     eax, edx
        sub     eax, esi
        cdq
        xor     eax, edx
        sub     eax, edx
        mov     edx, ecx
        sub     edx, eax
        mov     esi, edx
        shr     esi, 31
        add     edx, esi
        sar     edx
        add     eax, ecx
        mov     DWORD PTR [rdi], edx
        mov     edx, eax
        shr     edx, 31
        add     eax, edx
        sar     eax
        mov     DWORD PTR [rdi+4], eax
        ret
    </pre>
	</td>
	<td>
	<pre id="code_6_2">
        mov     ecx, DWORD PTR [rdi]
        mov     edx, DWORD PTR [rdi+4]
        mov     eax, ecx
        sub     eax, edx
        mov     esi, eax
        sar     esi, 31
        and     eax, esi
        add     edx, eax
        sub     ecx, eax
        mov     eax, DWORD PTR [rdi+8]
        mov     esi, ecx
        sub     esi, eax
        mov     r8d, esi
        sar     r8d, 31
        and     esi, r8d
        sub     ecx, esi
        add     eax, esi
        mov     DWORD PTR [rdi+8], ecx
        mov     ecx, edx
        sub     ecx, eax
        mov     esi, ecx
        sar     esi, 31
        and     ecx, esi
        sub     edx, ecx
        add     eax, ecx
        mov     DWORD PTR [rdi+4], edx
        mov     DWORD PTR [rdi], eax
        ret
    </pre>
	</td></tr></table>
	<p>
Yes. It is GCC-specific though. On Clang, the best code still comes from min/max swaps.
	</p>
	</div>
	<script language="JavaScript">
	init_slider(5);
	</script>


	<h2>
Bonus round.
	</h2>
	<p>
Since we know that the algorithm is supposed to work with small arrays, maybe we can help the compiler to pick the types better. I was always curious to try uint_fast8_t somewhere.
	</p>
	<table><tr>
	<td id="left_7">
	<pre>
template &lt;size_t N&gt;
void index_sort(std::array&lt;int, N&gt;& t) {
    std::array&lt;int, N&gt; a = t;
    for(auto i = 0u; i &lt; N; ++i) {
        auto k = 0u;
        for(auto j = 0u; j &lt; N; ++j) {
            if(j &gt; i)
                k += int(a[i] &gt; a[j]);
            else if(j &lt; i)
                k += int(a[i] &gt;= a[j]);
        }
        t[k] = a[i];
    }
}
    </pre>
	</td>
	<td id="right_7">
	<pre>
template &lt;size_t N&gt;
void index_sort_fast_t(std::array&lt;int, N&gt;& t) {
    std::array&lt;int, N&gt; a = t;
    for(uint_fast8_t i = 0u; i &lt; N; ++i) {
        uint_fast8_t k = 0u;
        for(uint_fast8_t j = 0u; j &lt; N; ++j) {
            if(j &gt; i)
                k += uint_fast8_t(a[i] &gt; a[j]);
            else if(j &lt; i)
                k += uint_fast8_t(a[i] &gt;= a[j]);
        }
        t[k] = a[i];
    }
}
    </pre>
	</td></tr></table>
	<canvas id="slider_7" width=608 height=128></canvas>
	<p class="comment" id="comment_7">
They are almost the same.
	</p>
	<button type="button" onclick="reveal(6)" id="button_7"><nobr>Reveal the truth</nobr></button>
	<div id="the_truth_7" style="display:none;">
	<p>
There is no meaningful difference.
	</p>
	<table><tr>
	<td>
	<pre id="code_7_1">
        mov     rax, QWORD PTR [rdi]
        mov     ecx, DWORD PTR [rdi+8]
        xor     esi, esi
        mov     edx, eax
        shr     rax, 32
        cmp     edx, eax
        setg    sil
        xor     r8d, r8d
        cmp     edx, ecx
        setg    r8b
        add     esi, r8d
        mov     DWORD PTR [rdi+rsi*4], edx
        xor     esi, esi
        cmp     edx, eax
        setle   sil
        xor     r8d, r8d
        cmp     ecx, eax
        setl    r8b
        add     esi, r8d
        cmp     edx, ecx
        setle   dl
        cmp     ecx, eax
        mov     DWORD PTR [rdi+rsi*4], eax
        setge   al
        movzx   edx, dl
        movzx   eax, al
        add     eax, edx
        mov     DWORD PTR [rdi+rax*4], ecx
        ret
    </pre>
	</td>
	<td>
	<pre id="code_7_2">
        mov     rax, QWORD PTR [rdi]
        mov     ecx, DWORD PTR [rdi+8]
        mov     edx, eax
        shr     rax, 32
        cmp     edx, eax
        setg    sil
        cmp     edx, ecx
        setg    r8b
        add     esi, r8d
        cmp     edx, eax
        movzx   esi, sil
        mov     DWORD PTR [rdi+rsi*4], edx
        setle   sil
        cmp     ecx, eax
        setl    r8b
        add     esi, r8d
        cmp     edx, ecx
        setle   dl
        movzx   esi, sil
        cmp     ecx, eax
        mov     DWORD PTR [rdi+rsi*4], eax
        setge   al
        add     eax, edx
        movzx   eax, al
        mov     DWORD PTR [rdi+rax*4], ecx
        ret
    </pre>
	</td></tr></table>
	<p>
The code is accidentally different but the difference is too small. This is consistent across compilers and CPUs. No magics gains here.
	</p>
	</div>
	<script language="JavaScript">
	init_slider(6);
	</script>


	<div id="show_in_the_end" style="display:none;">
	<h2>
Congratulations!
	</h2>
	<p>
You scored <span id="score"></span> pixels of error. As a reference, if you leave every slider untouched there would be exactly <span id="default_score"></span> pixels of error.
	</p>
	<div id="bragging_rights" style="display:none;">
	<p>
This shows that your performance intuition works! Can you please tell other people about this? Here's a convenient Twitter link: <a href="https://twitter.com/intent/tweet?text=My+performance+intuition+works+fine+according+to+the+Challenge+your+performance+intuition+with+nanosecond+sorting+quiz.+https%3A%2F%2Fwordsandbuttons.online%2Fchallenge_your_performance_intuition_with_nanosecond_sorting.html">My performance intuition works fine according to the Challenge your performance intuition with nanosecond sorting quiz. https://wordsandbuttons.online/challenge_your_performance_intuition_with_nanosecond_sorting.html</a>.
	</p>
	<p>
It's not immodest, you're just doing me a favor by sharing a quiz ;-)
	</p>
	</div>
	<div id="superb_bragging_rights" style="display:none;">
	<p>
This shows that your performance intuition works excellently! Can you please tell other people about this? Here's a convenient Twitter link: <a href="https://twitter.com/intent/tweet?text=My+performance+intuition+works+excellently+according+to+the+Challenge+your+performance+intuition+with+nanosecond+sorting+quiz%21+https%3A%2F%2Fwordsandbuttons.online%2Fchallenge_your_performance_intuition_with_nanosecond_sorting.html">My performance intuition works excellently according to the Challenge your performance intuition with nanosecond sorting quiz! https://wordsandbuttons.online/challenge_your_performance_intuition_with_nanosecond_sorting.html</a>.
	</p>
	<p>
It's not immodest, you're just doing me a favor by sharing a quiz ;-)
	</p>
	</div>

	<h2>
Conclusion
	</h2>
	<p>
You can always win some performance by using clever tricks. Something type-specific or compiler-specific or processor-specific. However, even in the nano-world, the simplest solution often works the best.
	</p>
	</div>
	<script language="JavaScript">
	document.getElementById("code_2_1").innerHTML = colorized(document.getElementById("code_2_1").innerHTML);
	document.getElementById("code_2_2").innerHTML = colorized(document.getElementById("code_2_2").innerHTML);
	document.getElementById("code_3_1").innerHTML = colorized(document.getElementById("code_3_1").innerHTML);
	document.getElementById("code_3_2").innerHTML = colorized(document.getElementById("code_3_2").innerHTML);
	document.getElementById("code_4_1").innerHTML = colorized(document.getElementById("code_4_1").innerHTML);
	document.getElementById("code_4_2").innerHTML = colorized(document.getElementById("code_4_2").innerHTML);
	document.getElementById("code_4_1_").innerHTML = colorized(document.getElementById("code_4_1_").innerHTML);
	document.getElementById("code_4_2_").innerHTML = colorized(document.getElementById("code_4_2_").innerHTML);
	document.getElementById("code_5_1").innerHTML = colorized(document.getElementById("code_5_1").innerHTML);
	document.getElementById("code_5_2").innerHTML = colorized(document.getElementById("code_5_2").innerHTML);
	document.getElementById("code_6_1").innerHTML = colorized(document.getElementById("code_6_1").innerHTML);
	document.getElementById("code_6_2").innerHTML = colorized(document.getElementById("code_6_2").innerHTML);
	document.getElementById("code_7_1").innerHTML = colorized(document.getElementById("code_7_1").innerHTML);
	document.getElementById("code_7_2").innerHTML = colorized(document.getElementById("code_7_2").innerHTML);
	</script>

	<h2>
Links
	</h2>
	<p>
<a href="https://wordsandbuttons.online/challenge_your_performance_intuition_with_cpp_magic_squares.html">Challenge your performance intuition with C++ magic squares</a>
	</p>
	<p>
<a href="https://wordsandbuttons.online/challenge_your_performance_intuition_with_cpp_operators.html">Challenge your performance intuition with C++ operators</a>
	</p>
	<p>
<a href="https://wordsandbuttons.online/challenge_your_performance_intuition_with_cpp_sine.html">Challenge your performance intuition with C++ sine</a>
	</p>
	<p>
Further reading: <a href="https://medium.com/@veedrac/learning-the-value-of-good-benchmarking-technique-with-c-magic-squares-b61b3386c97f">Learning the value of good benchmarking technique with C++ magic squares</a>.
	</p>
	<p>
Github with <a href="https://github.com/akalenuk/wordsandbuttons/tree/master/exp/sort/nanosort">all the experiments</a>.
	</p>

	<table class="footer" style="width: 600pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
	<tr>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
		<a href="index.html">Index</a>
		<a href="all_programming.html">#programming</a> <a href="all_quizzes.html">#quizzes</a>
	</td>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
		&nbsp;&larr; there's more.
	</td>
	<td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
			+
		<a href="https://wordsandbuttons.online/SYTYKC.pdf">So You Think You Know C</a> <span style="color:#888; font-size: 12pt;">(free book)</span><br>
			+
		<a href="https://www.amazon.com/Geometry-Programmers-Oleksandr-Kaleniuk/dp/1633439607">Geometry for Programmers</a> <span style="color:#888; font-size: 12pt;">(paid book)</span><br>
			+
		<a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &

		<a href="https://wordsandbuttons.online/rss"><span style="letter-spacing: 1pt;">RSS</span></a>
	</td>
	</tr>
	</table>
	</center>
</body>
</html>
