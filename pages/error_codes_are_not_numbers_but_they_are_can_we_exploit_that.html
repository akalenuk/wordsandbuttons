<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=0.84">
	<title>Error codes are not numbers. But they are. Can we exploit that?</title>
	<meta name="description" content="An interactive explanation of how we can use floating-point NaNs as error code holders in C++.">
	<meta name="keywords" content="programming, mathematics, demos">
	<link rel="shortcut icon" type="image/x-icon" href="favicon.svg" />
	<style>
body {
	margin: 0 0 0 0;
}

a {
	text-decoration: none;
}

a:link, a:visited {
	color: blue;
}

h1 {
	padding-top: 36pt;
	font-size: 24pt;
	width: 600pt;
	text-align: left;
}

h2 {
	padding-top: 20pt;
	font-size: 20pt;
	width: 600pt;
	text-align: left;
}

p {
	line-height: 1.42;
	font-size: 16pt;
	width: 600pt;
	text-align: left;
}

pre {
	margin: 0 0 0 0;
	padding-top: 12pt;
	padding-left: 12pt;
	padding-right: 12pt;
	padding-bottom: 12pt;
	font-size: 12pt;
	text-align: left;
	width: 600pt;
}

table {
	border-width: 0pt;
}

td {
	vertical-align: top;
	padding: 6pt 12pt 6pt 12pt;
	font-size: 16pt;
	border: 1px solid black;
	width: 600pt;
}

button {
	width: 248pt;
	height: 42pt;
	margin-left:4pt;
	margin-right:4pt;
	font-size: 16pt;
}

.comment {
	font-size: 14pt;
	text-align:center;
	font-family: sans-serif;
	padding-bottom: 24pt;
}

canvas { touch-action: none; }
	</style>
	<script language="JavaScript">
const w = 640;
const h = 200;
const cell_width = 64;
const cell_height = 64;
const cell_y = 20;

const button_border = "#999";
const button_shadow = "#444";

// floating-point
floating_cell_xs = [20, 20 + 90 + 43 - 32, 20 + 90*2 + 43 - 32, 20 + 90*3 + 43 - 32, 20 + 90*4 + 43*2, 20 + 90*5 + 43*2];
floating_cell_colors = ["#dba0ac", "#acdba0", "#acdba0", "#acdba0", "#cfa0db", "#cfa0db"];
floating_cell_bits = [0, 1, 1, 1, 0, 1];

function init_floating() {
	var floating = document.getElementById("floating");
	floating_draw();

	floating.addEventListener('pointerdown', function(e) {
		var canvas_rect = floating.getBoundingClientRect();
		var x = e.clientX - canvas_rect.left;
		var y = e.clientY - canvas_rect.top;
		for(var i = 0; i < floating_cell_xs.length; ++i) {
			if (x > floating_cell_xs[i] && x < floating_cell_xs[i] + cell_width && y > cell_y && y < cell_y + cell_height)
				floating_cell_bits[i] = 1 - floating_cell_bits[i];
		}
		floating_draw('down', x, y);
		floating.releasePointerCapture(e.pointerId);
	}, false);

	floating.addEventListener('pointerup', function(e) {
		var canvas_rect = floating.getBoundingClientRect();
		var x = e.clientX - canvas_rect.left;
		var y = e.clientY - canvas_rect.top;
		floating_draw('up', x, y);
	}, false);
}

var cur_float = 0.;
function floating_draw(mouse_state, x, y) {
	var floating = document.getElementById("floating");
	var context = floating.getContext("2d");

	// background
	context.fillStyle="#eeee99";
	context.fillRect(0, 0, w, h);

	// cells
	for(var i = 0; i < floating_cell_xs.length; ++i) {
		var text_dx = 0;
		var text_dy = 0;
		if(mouse_state == "down"
		&& x >= floating_cell_xs[i] && x - floating_cell_xs[i] < cell_width
		&& y >= cell_y && y - cell_y < cell_height) {
			context.fillStyle = button_shadow;
			context.fillRect(floating_cell_xs[i] -1 , cell_y - 1, cell_width + 2, cell_height + 2);
			context.fillStyle = button_border;
			context.fillRect(floating_cell_xs[i], cell_y, cell_width + 1, cell_height + 2);
			text_dx = 1;
			text_dy = 1;
		} else {
			context.fillStyle = button_border;
			context.fillRect(floating_cell_xs[i] -1 , cell_y - 1, cell_width + 1, cell_height + 1);
			context.fillStyle = button_shadow;
			context.fillRect(floating_cell_xs[i], cell_y, cell_width + 1, cell_height + 1);
		}
		context.fillStyle = floating_cell_colors[i];
		context.fillRect(floating_cell_xs[i], cell_y, cell_width, cell_height);

		context.textAlign = "center";
		context.textBaseline = "middle";
		context.font = "48px sans-serif";
		context.fillStyle = "#222222";
		context.fillText(floating_cell_bits[i], text_dx + floating_cell_xs[i] + cell_width / 2.0, text_dy + cell_y + cell_height / 2.0 + 4);
	}

	// the number
	var sign = floating_cell_bits[0] ? -1.0 : 1.0;
	var e = floating_cell_bits[3] + floating_cell_bits[2] * 2 + floating_cell_bits[1] * 4;
	var n = floating_cell_bits[5] + floating_cell_bits[4] * 2 + ((e != 0 && e != 7) ? 4 : 0);

	// explicit point
	if (e != 0 && e != 7) {
		context.fillStyle = "#673670";
		context.fillText("1", 420, cell_y + cell_height / 2.0 + 4);
	}

	// comment
	context.textAlign = "left";
	context.textBaseline = "alphabetic";
	context.font = "20px sans-serif";

	if( e == 7 ) {
		if ( n == 0 ) {
			context.fillStyle = "#914853";
			context.fillText(sign == -1.0 ? "Negative" : "Positive", 20, 120);
			context.fillStyle = "#673670";
			context.fillText("infinite number.", 20, 145);
		} else {
			context.fillStyle = "#673670";
			context.fillText("Not a number.", 20, 120);
		}
		cur_float = NaN;
	} else {
		context.fillStyle = "#914853";
		context.fillText(sign == -1.0 ? "Negative number" : "Positive number", 20, 120);

		context.fillStyle = "#673670"
		context.fillText("of " + n, 20, 145);
		context.fillStyle = "#597052";
		var measures = "quarters,";
		if(e == 2)
			measures = "halves,";
		if(e == 3)
			measures = "wholes,";
		if(e == 4)
			measures = "pairs,";
		if(e == 5)
			measures = "four-packs,";
		if(e == 6)
			measures = "eight-packs,";
		context.fillText(measures, 64, 145);

		context.fillStyle = "#673670";
		context.fillText("which is " + sign * (n * Math.pow(2, e - 2 - (e > 0 ? 1 : 0))).toFixed(2) + " in real numbers", 20, 170);
		cur_float = sign * (n * Math.pow(2, e - 2 - (e > 0 ? 1 : 0))).toFixed(2);
	}
}

function update_buttons(slides){
	// title the next button
	var button = document.getElementById(slides + "_button")
	for(var i = 1; i < 9; ++i)
	{
		var this_slide = document.getElementById(slides + "_" + i);
		var next_slide = document.getElementById(slides + "_" + (i+1));
		if (this_slide && !next_slide && this_slide.style.display == "block") {
			button.innerHTML = "ᐊᐊ Back to the 1-st slide";
			break;
		}
		else
			button.innerHTML = "Next slide ᐅ";
	}

	var button = document.getElementById(slides + "_back_button")
	for(var i = 1; i < 9; ++i)
	{
		var this_slide = document.getElementById(slides + "_" + i);
		var prev_slide = document.getElementById(slides + "_" + (i-1));
		if (this_slide && !prev_slide && this_slide.style.display == "block") {
			button.innerHTML = "To the last slide ᐅᐅ";
			break;
		}
		else
			button.innerHTML = "ᐊ Previous slide";
	}
}

function next(slides){
	// show the next slide
	var first_slide = document.getElementById(slides + "_" + 1);
	for(var i = 1; i < 9; ++i)
	{
		var this_slide = document.getElementById(slides + "_" + i);
		var next_slide = document.getElementById(slides + "_" + (i+1));
		if(this_slide)
			if(this_slide.style.display == "block")
				{
				this_slide.style.display = "none";
				if(next_slide)
					next_slide.style.display = "block";
				else
					first_slide.style.display = "block";
				break;
				}
	}
	update_buttons(slides);
}

function previous(slides){
	// show the previous slide
	var last_slide = 0;
	for(var i = 1; i < 9; ++i)
		if(document.getElementById(slides + "_" + i))
			last_i = i;

	var last_slide = document.getElementById(slides + "_" + last_i);
	for(var i = 1; i < 9; ++i)
	{
		var this_slide = document.getElementById(slides + "_" + i);
		var prev_slide = document.getElementById(slides + "_" + (i-1));
		if(this_slide)
			if(this_slide.style.display == "block")
				{
				this_slide.style.display = "none";
				if(prev_slide)
					prev_slide.style.display = "block";
				else
					last_slide.style.display = "block";
				break;
				}
	}
	update_buttons(slides);
}

	</script>
</head>
<body>
	<center>
	<p style="width: 600pt; padding: 36pt 0pt 64pt 0pt;">This is <a href="index.html">Words and Buttons Online</a> — a collection of&nbsp;interactive <a href="all_tutorials.html">#tutorials</a>, <a href="all_demos.html">#demos<a/>, and <a href="all_quizzes.html">#quizzes</a> about <a href="all_mathematics.html">#mathematics</a>, <a href="all_algorithms.html">#algorithms</a> and <a href="all_programming.html">#programming</a>.</p>
	<h1>
Error codes are not numbers. But they are. Can we exploit that?
	</h1>
	<p>
People do it with different feelings. Sometimes with pride for a clever solution, sometimes with guilt for an obscure hack. Which is odd since there is nothing hacky about it. The <nobr>IEEE 754</nobr> is ok with it. The <nobr>ISO/IEC 14882</nobr> is ok with it. So why is it perceived as a hack and not a norm?
	</p>
	<p>
I'm talking, of course, about storing return codes in floating-point NaNs.
	</p>
	<h2>
What?
	</h2>
	<p>
The floating-point numbers are often perceived as esoteric and unusual. For instance, you can't sum up three thirds and expect 1. But that is not due to sorcery, that's due to engineering.
	</p>
	<p>
A floating-point number consists of a <span id="index_sign_bit">sign bit</span>, an <span id="index_exponent">exponent</span>, and a <span id="index_significant">significant</span>. The model below is a perfectly standard <nobr>IEEE 754</nobr> number, although it was only given 6 bits to make it more clickable.
	</p>
	<canvas id="floating" width=640 height=200></canvas>
	<script language="JavaScript">
		init_floating();
	</script>
	<p>
It is set to indicate the first best "not a number" value. But there's more than one. This particular model has 6 NaNs: 3 with a plus sign, and 3 more with a minus.
	</p>
	<p>
A single-precision floating-point number has <nobr>16 777 214</nobr> different NaNs, and double-precision has <nobr>9 007 199 254 740 990</nobr>. It would be wasteful not to exploit that.
	</p>
	<h2>
How?
	</h2>
	<p>
In C++, you can use the significant bits to store error codes by unionizing the enumerator with a floating-point number. Consider this example.
	</p>

<table><tr>
	<td>
	<pre>
#include &lt;cassert&gt;
#include &lt;cmath&gt;
#include &lt;cstdint&gt;

enum class ECode : uint64_t {
    INPUT_IS_NAN = 0xFFF0'0000'0000'0001,
    INPUT_IS_INFINITE,
    INPUT_IS_NEGATIVE
};

union Result_or_code
{
    double result;
    ECode code;
    Result_or_code(double x) {result = x;}
    Result_or_code(ECode c) {code = c;}
    operator double() {return result;}
    operator ECode() {return code;}
};

Result_or_code sqrt_or_not(double x) {
    if (std::isnan(x))
        return ECode::INPUT_IS_NAN;
    if (std::isinf(x))
        return ECode::INPUT_IS_INFINITE;
    if(x &lt; 0)
        return ECode::INPUT_IS_NEGATIVE;
    return std::sqrt(x);
}

int main(void) {
    assert(sqrt_or_not(-1.) == ECode::INPUT_IS_NEGATIVE);
    assert(sqrt_or_not(1./0.) == ECode::INPUT_IS_INFINITE);
    assert(sqrt_or_not(0./0.) == ECode::INPUT_IS_NAN);
    assert(sqrt_or_not(4.) == 2.);

    assert(std::isnan(sqrt_or_not(-1.)));
    assert(std::isnan(sqrt_or_not(1./0.)));
    assert(std::isnan(sqrt_or_not(0./0.)));
    assert(std::isnan(sqrt_or_not(-1.) + 1.));
}
    </pre>
	</td>
	</tr></table>
	<p>
In this example, a square root is being computed for the argument in double. Or it isn't. Not all the doubles have a legitimate square root. The error code enumerator is unionized with the numeric result in double so you get a number when possible and an error code enum when not.
	</p>
	<p>
The enumerator starts from the first negative NaN so every error code is also a NaN. And every valid number still has a representation in double. We have both ranges covered with a single entity.
	</p>
	<p>
The square root of NaN is NaN. Which makes sense since every number has a square in numbers including +INF.
	</p>
	<p>
The square root of +INF is also a NaN. This is a bit controversial since you have a lot of numbers other than +INF that result in +INF being squared. But since it's not just a single number but an array, it's ok to report a NaN here. Arrays are not numbers.
	</p>
	<p>
And while the square root of a negative number is a number mathematically, it's a complex number so it doesn't have a representation in doubles. In doubles, it's also NaN.
	</p>
	<p>
The concept works wonderfully. Unless you want to return both a valid number and an error code, you can store them together.
	</p>
	<h2>
Why?
	</h2>
	<p>
There are two reasons to store your error codes in NaNs. First is the memory savings. It's not really a problem if you want to get a square root of nine. But if, for instance, you have to store the result of signed distance function in a huge grid for the <a href="https://wordsandbuttons.online/interactive_explanation_of_marching_cubes_and_dual_contouring.html">marching cubes</a>, then suddenly using all the bits you have makes sense.
	</p>
	<p>
The second reason is the expected performance gain but it is just the first reason in disguise. You don't make your code faster by reading or writing the error code in NaN. But if you have to store the results somewhere, then storing your codes in NaNs is beneficial. You have more values fitting in a single cache line, and every level of the cache also contains more values, and generally, you have to access less memory to get work done.
	</p>
	<p>
I've made this simple benchmark to test how noticeable the gains really are.
	</p>
<table><tr>
	<td>
	<pre>
enum class ECode : uint64_t {
    OK = 0xFFF0'0000'0000'0001,
    ERROR,
    INPUT_IS_NAN,
    INPUT_IS_INFINITE,
    INPUT_IS_NEGATIVE,
};

union Result_or_code
{
    double result;
    ECode code;
    Result_or_code(double x) {result = x;}
    Result_or_code(ECode c) {code = c;}
    operator double() {return result;}
    operator ECode() {return code;}
};

#define MEASURE(CODE_TO_MEASURE) \
    { \
    auto start = std::chrono::system_clock::now(); \
    CODE_TO_MEASURE \
    auto end = std::chrono::system_clock::now(); \
    std::chrono::duration&lt;double&gt; difference = end - start; \
    std::cout &lt;&lt; difference.count(); \
    }
    </pre>
	</td>
	</tr></table>
	<p>
Here are eight snippets of code. The first three have error codes as NaNs, then there are a pair of snippets for boost::optional, then there are two more for tuples, and, last but not least, an exception throwing.
	</p>

<table><tr>
	<td>
	<pre><span id="slides_1" style="display:block"><div style="color:#d64562"><b>Option 1.1. Checking error codes as enum</b></div>
    Result_or_code sqrt_or_not(double x) {
        if (std::isnan(x))
            return ECode::INPUT_IS_NAN;
        if (std::isinf(x))
            return ECode::INPUT_IS_INFINITE;
        if(x &lt; 0.)
            return ECode::INPUT_IS_NEGATIVE;
        return std::sqrt(x);
    }
...
    MEASURE(
        for(double x = -1024.; x &lt;= 1024.; x += 1./65536.) {
            auto root = sqrt_or_not(x);
            if(root &gt;= ECode::ERROR)
                ++errors;
            else {
                ++results;
                total += root;
            }
        }
    );

<div style="color:#457fd6"><b>Time: 0.2 s        Return type size: 8 B</b></div></span><span id="slides_2" style="display:none"><div style="color:#d64562"><b>Option 1.2. Checking error codes as NaN</b></div>
    Result_or_code sqrt_or_not(double x) {
        if (std::isnan(x))
            return ECode::INPUT_IS_NAN;
        if (std::isinf(x))
            return ECode::INPUT_IS_INFINITE;
        if(x &lt; 0.)
            return ECode::INPUT_IS_NEGATIVE;
        return std::sqrt(x);
    }
...
    MEASURE(
        for(double x = -1024.; x &lt;= 1024.; x += 1./65536.) {
            auto root = sqrt_or_not(x);
            if(std::isnan(root))
                ++errors;
            else {
                ++results;
                total += root;
            }
        }
    );

<div style="color:#457fd6"><b>Time: 0.3 s        Return type size: 8 B</b></div></span><span id="slides_3" style="display:none"><div style="color:#d64562"><b>Option 1.3. Storing error codes in NaN</b></div>
    Result_or_code sqrt_or_not(double x) {
        if (std::isnan(x))
            return ECode::INPUT_IS_NAN;
        if (std::isinf(x))
            return ECode::INPUT_IS_INFINITE;
        if(x &lt; 0.)
            return ECode::INPUT_IS_NEGATIVE;
        return std::sqrt(x);
    }
...
    MEASURE(
        std::vector&lt;Result_or_code&gt; results_or_codes;
        for(double x = -1024.; x &lt;= 1024.; x += 1./65536.) {
            results_or_codes.push_back(sqrt_or_not(x));
            if(results_or_codes.back() &gt;= ECode::ERROR)
                ++errors;
            else {
                ++results;
            }
        }
    );

<div style="color:#457fd6"><b>Time: 1.3 s        Return type size: 8 B</b></div></span><span id="slides_4" style="display:none"><div style="color:#d64562"><b>Option 2.1. Checking optional result</b></div>
    boost::optional&lt;double&gt; optional_sqrt(double x) {
        if (std::isnan(x) || std::isinf(x) || x &lt; 0)
            return boost::optional&lt;double&gt;();
        return boost::optional&lt;double&gt;(std::sqrt(x));
    }
...
    MEASURE(
        for(double x = -1024.; x &lt;= 1024.; x += 1./65536.) {
            auto optional_root = optional_sqrt(x);
            if(!optional_root)
                ++errors;
            else {
                ++results;
                total += *optional_root;
            }
        }
    );





<div style="color:#457fd6"><b>Time: 0.2 s        Return type size: 16 B</b></div></span><span id="slides_5" style="display:none"><div style="color:#d64562"><b>Option 2.2. Storing optional results</b></div>
    boost::optional&lt;double&gt; optional_sqrt(double x) {
        if (std::isnan(x) || std::isinf(x) || x &lt; 0)
            return boost::optional&lt;double&gt;();
        return boost::optional&lt;double&gt;(std::sqrt(x));
    }
...
    MEASURE(
        for(double x = -1024.; x &lt;= 1024.; x += 1./65536.) {
            optional_results.push_back(optional_sqrt(x));
            if(!optional_results.back())
                ++errors;
            else {
                ++results;
                total += *optional_results.back();
            }
        }
    );





<div style="color:#457fd6"><b>Time: 2.9 s        Return type size: 16 B</b></div></span><span id="slides_6" style="display:none"><div style="color:#d64562"><b>Option 3.1. Checking tuple of code and value</b></div>
    std::tuple&lt;ECode, double&gt; code_and_sqrt(double x) {
        if (std::isnan(x))
            return std::make_tuple(ECode::INPUT_IS_NAN, 0.);
        if (std::isinf(x))
            return std::make_tuple(ECode::INPUT_IS_INFINITE, 0.);
        if(x &lt; 0)
            return std::make_tuple(ECode::INPUT_IS_NEGATIVE, 0.);
        return std::make_tuple(ECode::OK, std::sqrt(x));
    }
...
    MEASURE(
        for(double x = -1024.; x &lt;= 1024.; x += 1./65536.) {
            auto code_and_root = code_and_sqrt(x);
            if(std::get&lt;0&gt;(code_and_root) != ECode::OK)
                ++errors;
            else {
                ++results;
                total += std::get&lt;1&gt;(code_and_root);
            }
        }
    );

<div style="color:#457fd6"><b>Time: 0.2 s        Return type size: 16 B</b></div></span><span id="slides_7" style="display:none"><div style="color:#d64562"><b>Option 3.2. Storing tuples of code and value</b></div>
    std::tuple&lt;ECode, double&gt; code_and_sqrt(double x) {
        if (std::isnan(x))
            return std::make_tuple(ECode::INPUT_IS_NAN, 0.);
        if (std::isinf(x))
            return std::make_tuple(ECode::INPUT_IS_INFINITE, 0.);
        if(x &lt; 0)
            return std::make_tuple(ECode::INPUT_IS_NEGATIVE, 0.);
        return std::make_tuple(ECode::OK, std::sqrt(x));
    }
...
    MEASURE(
        std::vector&lt;std::tuple&lt;ECode, double&gt;&gt; results_and_codes;
        for(double x = -1024.; x <= 1024.; x += 1./65536.) {
            results_and_codes.push_back(code_and_sqrt(x));
            if(std::get&lt;0&gt;(results_and_codes.back()) != ECode::OK)
                ++errors;
            else {
                ++results;
            }
        }
    );

<div style="color:#457fd6"><b>Time: 2.4 s        Return type size: 16 B</b></div></span><span id="slides_8" style="display:none"><div style="color:#d64562"><b>Option 4. Exceptions</b></div>
    double sqrt_or_throw(double x) {
        if (std::isnan(x))
            throw std::invalid_argument("");
        if (std::isinf(x))
            throw std::invalid_argument("");
        if(x &lt; 0)
            throw std::domain_error("");
        return std::sqrt(x);
    }
...
    MEASURE(
        for(double x = -2.; x &lt;= 2.; x += 1./65536.) {
            try {
                auto root = sqrt_or_throw(x);
                total += root;
                ++results;
            } catch (const std::logic_error& e) {
                ++errors;
            }
        }
    );

<div style="color:#457fd6"><b>Time: ≈126.8 s</b></div></span></pre></td></tr></table>

	<button type="button" id="slides_back_button" onclick="previous('slides')"></button>
	<button type="button" id="slides_button" onclick="next('slides')"></button>
	<script language="JavaScript">
		update_buttons('slides');
	</script>
	<br>
	<p class="comment">
Measured on Intel(R) Core(TM) i7-7700HQ CPU @ 2.80GHz<br>
Compiled with clang version 3.8.0-2ubuntu4<br>
Benchmark code is <a href="https://github.com/akalenuk/wordsandbuttons/tree/master/exp/nan_code">available on Github</a>.
	</p>
	<p>
Storing error codes in NaNs is economical; optional and tuple are almost the same thing; and exceptions are slow. If your goal is to write memory tight code, then the first option is your way to go.
	</p>

	<h2>
Why not?
	</h2>
	<p>
There is one reason why you might want to avoid using NaNs as error code carriers: they are already used as error code carriers. Or they aren't. You can't be sure.
	</p>
	<p>
<nobr>IEEE 754</nobr> allows signaling NaNs and it's a nice idea conceptually. Some specific NaNs are allowed to interfere with the operations on them. Like when you try to add <i>2 + NaN</i>, and it doesn't result in yet another <i>NaN</i> but in an exception, you can handle. With that, you're supposed to find more bugs earlier and this is generally a good thing.
	</p>
	<p>
The problem is, the exact notation of signaling NaNs, the implementation of traps, or even their very existence, are all unspecified in the standard. This means that if you're aiming at writing cross-platform code, messing with NaNs is probably not the best idea.
	</p>
	<p>
Of course, if you're planning on catching all of your error codes right after each and every operation then this is not an issue.
	</p>
	<p>
That's what people do, right?
	</p>

	<h2>
Conclusion
	</h2>
	<p>
Using NaNs to encode error codes is not sorcery. It's an engineering practice with its benefits and its downsides. Sometimes it is worth doing, sometimes it just isn't. I hope this page could help you make the best decision if you would have to.
	</p>

	<table class="footer" style="width: 600pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
	<tr>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
		<a href="index.html">Index</a>
		<a href="all_programming.html">#programming</a> <a href="all_mathematics.html">#mathematics</a> <a href="all_demos.html">#demos</a>
	</td>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
		&nbsp;&larr; there's more.
	</td>
	<td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
			+
		<a href="https://wordsandbuttons.online/SYTYKC.pdf">Free book</a><br>
			+
		<a href="https://www.manning.com/books/geometry-for-programmers">Paid book</a><br>
			+
		<a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &

		<a href="https://wordsandbuttons.online/rss"><span style="letter-spacing: 1pt;">RSS</span></a>
	</td>
	</tr>
	</table>
	</center>
  </body>
</html>
