<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=0.84">
	<title>C++ magic squares demystified with Valgrind and disassembly</title>
	<meta name="description" content="A comment on the 'Magic Squares Quiz'.">
	<meta name="keywords" content="">
	<link rel="shortcut icon" type="image/x-icon" href="favicon.svg" />
	<style>
body{
	margin: 0 0 0 0;
}

a{
	text-decoration: none;
}

h1 {
	padding-top: 36pt;
	font-size: 24pt;
	width: 600pt;
	text-align: left;
}

h2 {
	padding-top: 20pt;
	font-size: 20pt;
	width: 555pt;
	text-align: left;
}

p {
	line-height: 1.42;
	font-size: 16pt;
	width: 505pt;
	text-align: left;
}

.comment {
	font-size: 12pt;
	text-align: center;
	font-family: sans-serif;
	padding-bottom: 24pt;
}

table.footer {
	padding: 64pt 0pt 32pt 0pt;
	background-color: transparent;
	width: 505pt;
}

td.footer {
	font-family: sans-serif;
	font-size: 16pt;
	font-style: normal;
	padding: 0;
	margin: 0;
	border: 0;
}

pre {
	margin: 0 0 0 0;
	padding-top: 12pt;
	padding-left: 12pt;
	padding-right: 12pt;
	padding-bottom: 12pt;
	font-size: 12pt;
	text-align: left;
	width: 360pt;
}

table {
	text-align: center;
	border-width: 0pt;
}

td {
	padding: 6pt 12pt 6pt 12pt;
	font-size: 16pt;
	border: 1px solid black;
}

button{
	width: 304pt;
	height: 42pt;
	margin-left:4pt;
	margin-right:4pt;
	font-size: 18pt;
}

	</style>
	<script language="JavaScript">

	</script>
</head>
<body>
	<center>
	<h1>
C++ magic squares demystified with Valgrind and disassembly
	</h1>
	<p>
This is a follow-up on <a href="https://wordsandbuttons.online/challenge_your_performance_intuition_with_cpp_magic_squares.html">Challenge your performance intuition with C++ magic squares</a>. The original post got some public attention and also raised some intriguing questions. Measurements, sure, let's say we measure code A against code B and the B is faster. But why?
	</p>
	<p>
We can get a hint or two with varlgrind's cachegrind and with good old disassembly. So let's do that.
	</p>
	<p>
But just before we start, I want to remind you that it is all only a game and the CPU, the compiler, and the benchmark are the rules. They might not necessarily represent the “real life” well enough, although in the “real life” knights don't walk in a silly “L” pattern either, and it doesn't make chess any less interesting.
	</p>
	<p>
However, the benchmark proposed <b>does have a flaw</b>! It produces data in certain order that shadows the importance of branch prediction. Branch mis-prediction is certainly not something you would want to ignore. If you are interested in more relevant benchmarking, please take a look at <a href="https://medium.com/@veedrac/learning-the-value-of-good-benchmarking-technique-with-c-magic-squares-b61b3386c97f">Learning the value of good benchmarking technique with C++ magic squares</a> by Veedrac. It's very insightful!
	</p>

	<h2>
Shifts vs. no shifts
	</h2>
	<p>
<a href="https://www.reddit.com/user/ioquatix">ioquatix</a> from Reddit wonders how lookups can be faster than direct shifts. Honestly, for me this was also a mystery.
	</p>
	<table><tr>
	<td>
	<pre>
auto c15 = '5' * 3;
uint_fast64_t ideal_char_map =
    static_cast&lt;uint_fast64_t&gt;(0x1FF) &lt;&lt; 49;
uint_fast64_t char_map_one = 1u;

bool check_if_magic(const std::string& sq)
  {
  if ((sq[0] + sq[1] + sq[2] != c15)
    || (sq[3] + sq[4] + sq[5] != c15)
    || (sq[6] + sq[7] + sq[8] != c15)

    || (sq[0] + sq[3] + sq[6] != c15)
    || (sq[1] + sq[4] + sq[7] != c15)
    || (sq[2] + sq[5] + sq[8] != c15)

    || (sq[0] + sq[4] + sq[8] != c15)
    || (sq[2] + sq[4] + sq[6] != c15))
    return false;

  auto char_map = ideal_char_map;
  for(auto i = 0u; i &lt; 9; ++i)
    char_map ^= char_map_one &lt;&lt; sq[i];
  if (char_map != 0)
    return false;

  return true;
  }
    </pre>
	</td>
	<td>
	<pre>
auto magic_number = '5' * 3;
auto not_so_magic_number = '5' * 2;
const std::array&lt;uint16_t, 58&gt; bit_shifts {
  0, 0, 0, 0,   0, 0, 0, 0,
  0, 0, 0, 0,   0, 0, 0, 0,
  0, 0, 0, 0,   0, 0, 0, 0,
  0, 0, 0, 0,   0, 0, 0, 0,

  0, 0, 0, 0,   0, 0, 0, 0,
  0, 0, 0, 0,   0, 0, 0, 0,
  0, 1, 2, 4,   8, 16, 32, 64,
  128, 256
  };

bool check_if_magic(const std::string& sq)
  {
  if ((sq[0] + sq[1] + sq[2] != magic_number)
    || (sq[3] + sq[5] != not_so_magic_number)
    || (sq[6] + sq[7] + sq[8] != magic_number)

    || (sq[0] + sq[3] + sq[6] != magic_number)
    || (sq[1] + sq[7] != not_so_magic_number)
    || (sq[2] + sq[5] + sq[8] != magic_number)

    || (sq[0] + sq[4] + sq[8] != magic_number)
    || (sq[2] + sq[4] + sq[6] != magic_number))
    return false;

  auto char_map = 0u;
  for(auto i = 0u; i < 9; ++i)
    <b>char_map ^= bit_shifts[sq[i]];</b>
  if (char_map != 511)
    return false;

  return true;
  }
    </pre>
	</td></tr></table>
	<p>
I think it would be helpful to look at the disassembly.
	</p>
	<table><tr>
	<td>
	<pre>
Z14check_if_magic ...
.LFB1711:
	.cfi_startproc
	<a title="Move quadword">movq</a>	(%rdi), %rdx
	<a title="Exclusive OR">xorl</a>	%eax, %eax
	<a title="Move">movsbl</a>	(%rdx), %esi
	<a title="Move">movsbl</a>	1(%rdx), %edi
	<a title="Move">movsbl</a>	2(%rdx), %r8d
	<a title="Load Effective Address">leal</a>	(%rsi,%rdi), %ecx
	<a title="Add">addl</a>	%r8d, %ecx
	<a title="Compare operands">cmpl</a>	magic_number(%rip), %ecx
	<a title="Jump if condition">je</a>	.L21
	<a title="Return from procedure">ret</a>
	.p2align 4,,10
	.p2align 3
.L21:
	<a title="Push data onto stack">pushq</a>	%r13
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	<a title="Push data onto stack">pushq</a>	%r12
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	<a title="Push data onto stack">pushq</a>	%rbp
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	<a title="Push data onto stack">pushq</a>	%rbx
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	<a title="Move">movsbl</a>	3(%rdx), %r10d
	<a title="Move">movsbl</a>	4(%rdx), %r11d
	<a title="Move">movsbl</a>	5(%rdx), %ebx
	<a title="Load Effective Address">leal</a>	(%r10,%r11), %r9d
	<a title="Add">addl</a>	%ebx, %r9d
	<a title="Compare operands">cmpl</a>	%r9d, %ecx
	<a title="Jump if condition">je</a>	.L22
.L13:
	<a title="Pop data from stack">popq</a>	%rbx
	.cfi_remember_state
	.cfi_restore 3
	.cfi_def_cfa_offset 32
	<a title="Pop data from stack">popq</a>	%rbp
	.cfi_restore 6
	.cfi_def_cfa_offset 24
	<a title="Pop data from stack">popq</a>	%r12
	.cfi_restore 12
	.cfi_def_cfa_offset 16
	<a title="Pop data from stack">popq</a>	%r13
	.cfi_restore 13
	.cfi_def_cfa_offset 8
	<a title="Return from procedure">ret</a>
	.p2align 4,,10
	.p2align 3
.L22:
	.cfi_restore_state
	<a title="Move">movsbl</a>	6(%rdx), %ebp
	<a title="Move">movsbl</a>	7(%rdx), %r13d
	<a title="Move">movsbl</a>	8(%rdx), %r12d
	<a title="Load Effective Address">leal</a>	0(%rbp,%r13), %r9d
	<a title="Add">addl</a>	%r12d, %r9d
	<a title="Compare operands">cmpl</a>	%r9d, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Load Effective Address">leal</a>	(%rsi,%r10), %r9d
	<a title="Add">addl</a>	%ebp, %r9d
	<a title="Compare operands">cmpl</a>	%r9d, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Add">addl</a>	%r11d, %edi
	<a title="Add">addl</a>	%r13d, %edi
	<a title="Compare operands">cmpl</a>	%edi, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Load Effective Address">leal</a>	(%r8,%rbx), %edi
	<a title="Add">addl</a>	%r12d, %edi
	<a title="Compare operands">cmpl</a>	%edi, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Add">addl</a>	%r11d, %esi
	<a title="Add">addl</a>	%r12d, %esi
	<a title="Compare operands">cmpl</a>	%esi, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Add">addl</a>	%r11d, %r8d
	<a title="Add">addl</a>	%ebp, %r8d
	<a title="Compare operands">cmpl</a>	%r8d, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Move quadword">movq</a>	ideal_char_map(%rip), %rsi
	<a title="Move quadword">movq</a>	char_map_one(%rip), %r8
	<a title="Load Effective Address">leaq</a>	9(%rdx), %rdi
	<a title="Move quadword">movq</a>	%rdx, %rax
	.p2align 4,,10
	.p2align 3
.L4:
	<a title="Move">movsbl</a>	(%rax), %ecx
	<b><a title="Move quadword">movq</a>	%r8, %rdx
	<a title="Add">addq</a>	$1, %rax
	<a title="Shift Arithmetically left (signed shift left)">salq</a>	%cl, %rdx
	<a title="Exclusive OR">xorq</a>	%rdx, %rsi
	<a title="Compare operands">cmpq</a>	%rax, %rdi
	<a title="Jump if condition">jne</a>	.L4
	<a title="Logical compare (AND)">testq</a>	%rsi, %rsi</b>
	<a title="Set byte to one on condition, zero otherwise">sete</a>	%al
	<a title="Jump">jmp</a>	.L13
	.cfi_endproc
	</pre>
	</td>
	<td>
	<pre>
_Z14check_if_magic ...
.LFB1752:
	.cfi_startproc
	<a title="Move quadword">movq</a>	(%rdi), %rdx
	<a title="Exclusive OR">xorl</a>	%eax, %eax
	<a title="Move">movsbl</a>	(%rdx), %esi
	<a title="Move">movsbl</a>	1(%rdx), %edi
	<a title="Move">movsbl</a>	2(%rdx), %r8d
	<a title="Load Effective Address">leal</a>	(%rsi,%rdi), %ecx
	<a title="Add">addl</a>	%r8d, %ecx
	<a title="Compare operands">cmpl</a>	magic_number(%rip), %ecx
	<a title="Jump if condition">je</a>	.L17
	<a title="Return from procedure">ret</a>
	.p2align 4,,10
	.p2align 3
.L17:
	<a title="Push data onto stack">pushq</a>	%r13
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	<a title="Push data onto stack">pushq</a>	%r12
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	<a title="Push data onto stack">pushq</a>	%rbp
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	<a title="Push data onto stack">pushq</a>	%rbx
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	<a title="Move">movsbl</a>	3(%rdx), %r9d
	<a title="Move">movsbl</a>	5(%rdx), %r10d
	<a title="Load Effective Address">leal</a>	(%r9,%r10), %ebp
	<a title="Compare operands">cmpl</a>	not_so_magic_number(%rip), %ebp
	<a title="Jump if condition">je</a>	.L18
.L2:
	<a title="Pop data from stack">popq</a>	%rbx
	.cfi_remember_state
	.cfi_restore 3
	.cfi_def_cfa_offset 32
	<a title="Pop data from stack">popq</a>	%rbp
	.cfi_restore 6
	.cfi_def_cfa_offset 24
	<a title="Pop data from stack">popq</a>	%r12
	.cfi_restore 12
	.cfi_def_cfa_offset 16
	<a title="Pop data from stack">popq</a>	%r13
	.cfi_restore 13
	.cfi_def_cfa_offset 8
	<a title="Return from procedure">ret</a>
	.p2align 4,,10
	.p2align 3
.L18:
	.cfi_restore_state
	<a title="Move">movsbl</a>	6(%rdx), %r11d
	<a title="Move">movsbl</a>	7(%rdx), %r13d
	<a title="Move">movsbl</a>	8(%rdx), %ebx
	<a title="Load Effective Address">leal</a>	(%r11,%r13), %r12d
	<a title="Add">addl</a>	%ebx, %r12d
	<a title="Compare operands">cmpl</a>	%r12d, %ecx
	<a title="Jump if condition">jne</a>	.L2
	<a title="Add">addl</a>	%esi, %r9d
	<a title="Add">addl</a>	%r11d, %r9d
	<a title="Compare operands">cmpl</a>	%r9d, %ecx
	<a title="Jump if condition">jne</a>	.L2
	<a title="Add">addl</a>	%r13d, %edi
	<a title="Compare operands">cmpl</a>	%edi, %ebp
	<a title="Jump if condition">jne</a>	.L2
	<a title="Load Effective Address">leal</a>	(%r8,%r10), %edi
	<a title="Add">addl</a>	%ebx, %edi
	<a title="Compare operands">cmpl</a>	%edi, %ecx
	<a title="Jump if condition">jne</a>	.L2
	<a title="Move">movsbl</a>	4(%rdx), %edi
	<a title="Add">addl</a>	%edi, %esi
	<a title="Add">addl</a>	%ebx, %esi
	<a title="Compare operands">cmpl</a>	%esi, %ecx
	<a title="Jump if condition">jne</a>	.L2
	<a title="Add">addl</a>	%r8d, %edi
	<a title="Add">addl</a>	%edi, %r11d
	<a title="Compare operands">cmpl</a>	%r11d, %ecx
	<a title="Jump if condition">jne</a>	.L2
	<a title="Move quadword">movq</a>	%rdx, %rax
	<a title="Load Effective Address">leaq</a>	9(%rdx), %rsi
	<a title="Exclusive OR">xorl</a>	%edx, %edx
	.p2align 4,,10
	.p2align 3
.L3:
	<a title="Move">movsbq</a>	(%rax), %rcx
	<b><a title="Add">addq</a>	$1, %rax
	<a title="Move">movzwl</a>	_ZL25bit_shifts(%rcx,%rcx), %ecx
	<a title="Exclusive OR">xorl</a>	%ecx, %edx
	<a title="Compare operands">cmpq</a>	%rax, %rsi
	<a title="Jump if condition">jne</a>	.L3
	<a title="Compare operands">cmpl</a>	$511, %edx</b>
	<a title="Set byte to one on condition, zero otherwise">sete</a>	%al
	<a title="Jump">jmp</a>	.L2
	.cfi_endproc
	</pre>
	</td></tr></table>
	<p>
<a title="Logical AND">And... I was wrong. It is not really helpful. Apparently, we read more data, and do less instructions, but what does this mean in terms of performance? To settle this we need Valgrind.</a>
	</p>
	<p>
Valgrind is a dynamic analyzer, it can do lots of stuff for us. In this case I would be the most interested in the memory read/writes vs. instruction reads.
	</p>
	<table><tr>
	<td>
	<pre>
I   refs:      13,099,624,571
I1  misses:             1,846
LLi misses:             1,705
I1  miss rate:           0.00%
LLi miss rate:           0.00%


D   refs:       7,435,891,049
    (4,739,364,171 rd   + 2,696,526,878 wr)

D1  misses:            15,886
    (       13,670 rd   +         2,216 wr)

LLd misses:             9,155
    (        7,758 rd   +         1,397 wr)

D1  miss rate:            0.0%
    (          0.0%     +           0.0%  )

LLd miss rate:            0.0%
    (          0.0%     +           0.0%  )


LL refs:               17,732
    (       15,516 rd   +         2,216 wr)

LL misses:             10,860
    (        9,463 rd   +         1,397 wr)

LL miss rate:             0.0%
    (          0.0%     +           0.0%  )
    </pre>
	</td>
	<td>
	<pre>
I   refs:      13,041,321,061
I1  misses:             1,843
LLi misses:             1,705
I1  miss rate:           0.00%
LLi miss rate:           0.00%


D   refs:       7,438,562,794
    (4,742,035,917 rd   + 2,696,526,877 wr)

D1  misses:            15,894
    (       13,676 rd   +         2,218 wr)

LLd misses:             9,156
    (        7,761 rd   +         1,395 wr)

D1  miss rate:            0.0%
    (          0.0%     +           0.0%  )

LLd miss rate:            0.0%
    (          0.0%     +           0.0%  )


LL refs:               17,737
    (       15,519 rd   +         2,218 wr)

LL misses:             10,861
    (        9,466 rd   +         1,395 wr)

LL miss rate:             0.0%
    (          0.0%     +           0.0%  )
    </pre>
	</td></tr></table>
	<p>
Apparently, we now have 3 000 000 more data cache reads, but also 60 000 000 less instruction cache reads. All and all, it is more effective with the lookup.
	</p>
	<p>
But this works only because all the data fit in L1-cache perfectly. Which is, of course, rarely the case on practice, so it is generally better to abstain from using lookups. It is true, it just doesn't help in this particular exercise.
	</p>
	<h2>
Variables vs. constants
	</h2>
	<p>
<a href="https://www.reddit.com/user/FbF_">FbF_</a> from Reddit justly points out that leaving global variables non-constant is very wrong. Excellent point! This is indeed a mistake, of course, everything that is meant to be constant should be `const`. But does it affect performance all that much?
	</p>
	<table><tr>
	<td>
	<pre>
auto c15 = '5' * 3;
uint_fast64_t ideal_char_map =
    static_cast&lt;uint_fast64_t&gt;(0x1FF) &lt;&lt; 49;
uint_fast64_t char_map_one = 1u;

bool check_if_magic(const std::string& sq)
  {
  if ((sq[0] + sq[1] + sq[2] != c15)
    || (sq[3] + sq[4] + sq[5] != c15)
    || (sq[6] + sq[7] + sq[8] != c15)

    || (sq[0] + sq[3] + sq[6] != c15)
    || (sq[1] + sq[4] + sq[7] != c15)
    || (sq[2] + sq[5] + sq[8] != c15)

    || (sq[0] + sq[4] + sq[8] != c15)
    || (sq[2] + sq[4] + sq[6] != c15))
    return false;

  auto char_map = ideal_char_map;
  for(auto i = 0u; i &lt; 9; ++i)
    char_map ^= char_map_one &lt;&lt; sq[i];
  if (char_map != 0)
    return false;

  return true;
  }
    </pre>
	</td>
	<td>
	<pre>
const auto c15 = '5' * 3;
const uint_fast64_t ideal_char_map =
    static_cast&lt;uint_fast64_t&gt;(0x1FF) &lt;&lt; 49;
const uint_fast64_t char_map_one = 1u;

bool check_if_magic(const std::string& sq)
  {
  if ((sq[0] + sq[1] + sq[2] != c15)
    || (sq[3] + sq[4] + sq[5] != c15)
    || (sq[6] + sq[7] + sq[8] != c15)

    || (sq[0] + sq[3] + sq[6] != c15)
    || (sq[1] + sq[4] + sq[7] != c15)
    || (sq[2] + sq[5] + sq[8] != c15)

    || (sq[0] + sq[4] + sq[8] != c15)
    || (sq[2] + sq[4] + sq[6] != c15))
    return false;

  auto char_map = ideal_char_map;
  for(auto i = 0u; i &lt; 9; ++i)
    char_map ^= char_map_one &lt;&lt; sq[i];
  if (char_map != 0)
    return false;

  return true;
  }
    </pre>
	</td></tr></table>
	<p>
Well, the difference in runtime is subtle. They both run for about 1.8 seconds along with the generator. But the difference is quite visible in the code. Indeed, the constant version does look better.
	</p>
	<table><tr>
	<td>
	<pre>
Z14check_if_magic ...
.LFB1711:
	.cfi_startproc
	<a title="Move quadword">movq</a>	(%rdi), %rdx
	<a title="Exclusive OR">xorl</a>	%eax, %eax
	<a title="Move">movsbl</a>	(%rdx), %esi
	<a title="Move">movsbl</a>	1(%rdx), %edi
	<a title="Move">movsbl</a>	2(%rdx), %r8d
	<a title="Load Effective Address">leal</a>	(%rsi,%rdi), %ecx
	<a title="Add">addl</a>	%r8d, %ecx
	<a title="Compare operands">cmpl</a>	magic_number(%rip), %ecx
	<a title="Jump if condition">je</a>	.L21
	<a title="Return from procedure">ret</a>
	.p2align 4,,10
	.p2align 3
.L21:
	<a title="Push data onto stack">pushq</a>	%r13
	.cfi_def_cfa_offset 16
	.cfi_offset 13, -16
	<a title="Push data onto stack">pushq</a>	%r12
	.cfi_def_cfa_offset 24
	.cfi_offset 12, -24
	<a title="Push data onto stack">pushq</a>	%rbp
	.cfi_def_cfa_offset 32
	.cfi_offset 6, -32
	<a title="Push data onto stack">pushq</a>	%rbx
	.cfi_def_cfa_offset 40
	.cfi_offset 3, -40
	<a title="Move">movsbl</a>	3(%rdx), %r10d
	<a title="Move">movsbl</a>	4(%rdx), %r11d
	<a title="Move">movsbl</a>	5(%rdx), %ebx
	<a title="Load Effective Address">leal</a>	(%r10,%r11), %r9d
	<a title="Add">addl</a>	%ebx, %r9d
	<a title="Compare operands">cmpl</a>	%r9d, %ecx
	<a title="Jump if condition">je</a>	.L22
.L13:
	<a title="Pop data from stack">popq</a>	%rbx
	.cfi_remember_state
	.cfi_restore 3
	.cfi_def_cfa_offset 32
	<a title="Pop data from stack">popq</a>	%rbp
	.cfi_restore 6
	.cfi_def_cfa_offset 24
	<a title="Pop data from stack">popq</a>	%r12
	.cfi_restore 12
	.cfi_def_cfa_offset 16
	<a title="Pop data from stack">popq</a>	%r13
	.cfi_restore 13
	.cfi_def_cfa_offset 8
	<a title="Return from procedure">ret</a>
	.p2align 4,,10
	.p2align 3
.L22:
	.cfi_restore_state
	<a title="Move">movsbl</a>	6(%rdx), %ebp
	<a title="Move">movsbl</a>	7(%rdx), %r13d
	<a title="Move">movsbl</a>	8(%rdx), %r12d
	<a title="Load Effective Address">leal</a>	0(%rbp,%r13), %r9d
	<a title="Add">addl</a>	%r12d, %r9d
	<a title="Compare operands">cmpl</a>	%r9d, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Load Effective Address">leal</a>	(%rsi,%r10), %r9d
	<a title="Add">addl</a>	%ebp, %r9d
	<a title="Compare operands">cmpl</a>	%r9d, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Add">addl</a>	%r11d, %edi
	<a title="Add">addl</a>	%r13d, %edi
	<a title="Compare operands">cmpl</a>	%edi, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Load Effective Address">leal</a>	(%r8,%rbx), %edi
	<a title="Add">addl</a>	%r12d, %edi
	<a title="Compare operands">cmpl</a>	%edi, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Add">addl</a>	%r11d, %esi
	<a title="Add">addl</a>	%r12d, %esi
	<a title="Compare operands">cmpl</a>	%esi, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Add">addl</a>	%r11d, %r8d
	<a title="Add">addl</a>	%ebp, %r8d
	<a title="Compare operands">cmpl</a>	%r8d, %ecx
	<a title="Jump if condition">jne</a>	.L13
	<a title="Move quadword">movq</a>	ideal_char_map(%rip), %rsi
	<a title="Move quadword">movq</a>	char_map_one(%rip), %r8
	<a title="Load Effective Address">leaq</a>	9(%rdx), %rdi
	<a title="Move quadword">movq</a>	%rdx, %rax
	.p2align 4,,10
	.p2align 3
.L4:
	<a title="Move">movsbl</a>	(%rax), %ecx
	<a title="Move quadword">movq</a>	%r8, %rdx
	<a title="Add">addq</a>	$1, %rax
	<a title="Shift Arithmetically left (signed shift left)">salq</a>	%cl, %rdx
	<a title="Exclusive OR">xorq</a>	%rdx, %rsi
	<a title="Compare operands">cmpq</a>	%rax, %rdi
	<a title="Jump if condition">jne</a>	.L4
	<a title="Logical compare (AND)">testq</a>	%rsi, %rsi
	<a title="Set byte to one on condition, zero otherwise">sete</a>	%al
	<a title="Jump">jmp</a>	.L13
	.cfi_endproc
	</pre>
	</td>
	<td>
	<pre>
_Z14check_if_magic ...
.LFB1711:
	.cfi_startproc
	<a title="Move quadword">movq</a>	(%rdi), %rdx
	<a title="Exclusive OR">xorl</a>	%eax, %eax
	<a title="Move">movsbl</a>	(%rdx), %esi
	<a title="Move">movsbl</a>	1(%rdx), %edi
	<a title="Move">movsbl</a>	2(%rdx), %r8d
	<a title="Load Effective Address">leal</a>	(%rsi,%rdi), %ecx
	<a title="Add">addl</a>	%r8d, %ecx
	<a title="Compare operands">cmpl</a>	$159, %ecx
	<a title="Jump if condition">je</a>	.L17
.L15:
	<a title="Return from procedure">ret</a>
	.p2align 4,,10
	.p2align 3
.L17:
	<a title="Move">movsbl</a>	3(%rdx), %r9d
	<a title="Move">movsbl</a>	4(%rdx), %r10d
	<a title="Move">movsbl</a>	5(%rdx), %r11d
	<a title="Load Effective Address">leal</a>	(%r9,%r10), %ecx
	<a title="Add">addl</a>	%r11d, %ecx
	<a title="Compare operands">cmpl</a>	$159, %ecx
	<a title="Jump if condition">jne</a>	.L15
	<a title="Push data onto stack">pushq</a>	%r12
	.cfi_def_cfa_offset 16
	.cfi_offset 12, -16
	<a title="Push data onto stack">pushq</a>	%rbp
	.cfi_def_cfa_offset 24
	.cfi_offset 6, -24
	<a title="Push data onto stack">pushq</a>	%rbx
	.cfi_def_cfa_offset 32
	.cfi_offset 3, -32
	<a title="Move">movsbl</a>	6(%rdx), %ebx
	<a title="Move">movsbl</a>	7(%rdx), %r12d
	<a title="Move">movsbl</a>	8(%rdx), %ebp
	<a title="Load Effective Address">leal</a>	(%rbx,%r12), %ecx
	<a title="Add">addl</a>	%ebp, %ecx
	<a title="Compare operands">cmpl</a>	$159, %ecx
	<a title="Jump if condition">je</a>	.L18
.L2:
	<a title="Pop data from stack">popq</a>	%rbx
	.cfi_remember_state
	.cfi_restore 3
	.cfi_def_cfa_offset 24
	<a title="Pop data from stack">popq</a>	%rbp
	.cfi_restore 6
	.cfi_def_cfa_offset 16
	<a title="Pop data from stack">popq</a>	%r12
	.cfi_restore 12
	.cfi_def_cfa_offset 8
	<a title="Return from procedure">ret</a>
.L18:
	.cfi_restore_state
	<a title="Load Effective Address">leal</a>	(%rsi,%r9), %ecx
	<a title="Add">addl</a>	%ebx, %ecx
	<a title="Compare operands">cmpl</a>	$159, %ecx
	<a title="Jump if condition">jne</a>	.L2
	<a title="Add">addl</a>	%r10d, %edi
	<a title="Add">addl</a>	%r12d, %edi
	<a title="Compare operands">cmpl</a>	$159, %edi
	<a title="Jump if condition">jne</a>	.L2
	<a title="Load Effective Address">leal</a>	(%r8,%r11), %ecx
	<a title="Add">addl</a>	%ebp, %ecx
	<a title="Compare operands">cmpl</a>	$159, %ecx
	<a title="Jump if condition">jne</a>	.L2
	<a title="Add">addl</a>	%r10d, %esi
	<a title="Add">addl</a>	%ebp, %esi
	<a title="Compare operands">cmpl</a>	$159, %esi
	<a title="Jump if condition">jne</a>	.L2
	<a title="Add">addl</a>	%r10d, %r8d
	<a title="Add">addl</a>	%ebx, %r8d
	<a title="Compare operands">cmpl</a>	$159, %r8d
	<a title="Jump if condition">jne</a>	.L2
	<a title="Move quadword">movq</a>	%rdx, %rax
	<a title="Load Effective Address">leaq</a>	9(%rdx), %rdi
	<a title="Move">movl</a>	$1, %esi
	<a title="Move">movabsq</a>	$287667426198290432, %rdx
	.p2align 4,,10
	.p2align 3
.L3:
	<a title="Move">movsbl</a>	(%rax), %ecx
	<a title="Move quadword">movq</a>	%rsi, %rbx
	<a title="Add">addq</a>	$1, %rax
	<a title="Shift Arithmetically left (signed shift left)">salq</a>	%cl, %rbx
	<a title="Exclusive OR">xorq</a>	%rbx, %rdx
	<a title="Compare operands">cmpq</a>	%rax, %rdi
	<a title="Jump if condition">jne</a>	.L3
	<a title="Logical compare (AND)">testq</a>	%rdx, %rdx
	<a title="Set byte to one on condition, zero otherwise">sete</a>	%al
	<a title="Jump">jmp</a>	.L2
	.cfi_endproc
	</pre>
	</td></tr></table>
	<p class="comment">
By the way, did you notice that mnemonics have little tooltips on them? I'm not sure if they help, but this wouldn't be words and buttons without any interactive stuff whatsoever.
	</p>
	<p>
How come they do not show the difference in the runtime? Let's take a look at what Valgrind has to say.
	</p>
	<table><tr>
	<td>
	<pre>
I   refs:      13,099,624,571
I1  misses:             1,846
LLi misses:             1,705
I1  miss rate:           0.00%
LLi miss rate:           0.00%

D   refs:       7,435,891,049
    (4,739,364,171 rd   + 2,696,526,878 wr)
D1  misses:            15,886
    (       13,670 rd   +         2,216 wr)
LLd misses:             9,155
    (        7,758 rd   +         1,397 wr)
D1  miss rate:            0.0%
    (          0.0%     +           0.0%  )
LLd miss rate:            0.0%
    (          0.0%     +           0.0%  )

LL refs:               17,732
    (       15,516 rd   +         2,216 wr)
LL misses:             10,860
    (        9,463 rd   +         1,397 wr)
LL miss rate:             0.0%
    (          0.0%     +           0.0%  )
    </pre>
	</td>
	<td>
	<pre>
I   refs:      12,856,556,965
I1  misses:             1,843
LLi misses:             1,703
I1  miss rate:           0.00%
LLi miss rate:           0.00%

D   refs:       6,805,402,908
    (4,230,409,813 rd   + 2,574,993,095 wr)
D1  misses:            15,882
    (       13,665 rd   +         2,217 wr)
LLd misses:             9,154
    (        7,758 rd   +         1,396 wr)
D1  miss rate:            0.0%
    (          0.0%     +           0.0%  )
LLd miss rate:            0.0%
    (          0.0%     +           0.0%  )

LL refs:               17,725
    (       15,508 rd   +         2,217 wr)
LL misses:             10,857
    (        9,461 rd   +         1,396 wr)
LL miss rate:             0.0%
    (          0.0%     +           0.0%  )
    </pre>
	</td></tr></table>
	<p>
There is a difference, and it shows up in larger numbers, it's just that the benchmark is too small to show it properly. Most of the time we don't even get to do this map thing, we fail earlier.
	</p>
	<p>
So yes, it is best to have your constants constant, even if it doesn't show immediately.
	</p>

	<h2>
Global vs. local
	</h2>
	<p>
<a href="https://twitter.com/FolwarcznyAdam">FolwarcznyAdam</a> from Twitter suggests that changing data locality might be a good thing.
	</p>
	<table><tr>
	<td>
	<pre>
const std::array&lt;uint64_t, 8&gt; magic_numbers
{
  3545515123101087289, 3690191062107239479,
  3544956562637535289, 3978984379655991859,
  3689073941180135479, 4123101758198592049,
  3977867258728887859, 4122543197735040049
};
bool check_if_magic(const std::string& sq)
{
  if(sq[4] != '5')
    return false;

  uint64_t magic_number =
    *(reinterpret_cast&lt;const uint32_t*&gt;
      (sq.data()));
  magic_number <<= 32;
  magic_number +=
    *(reinterpret_cast&lt;const uint32_t*&gt;
      (sq.data()+5));

  for(auto i = 0u; i &lt; 8; ++i)
    if(magic_number == magic_numbers[i])
      return true;
  return false;
}
    </pre>
	</td>
	<td>
	<pre>
bool check_if_magic(const std::string& sq)
{
  const std::array&lt;uint64_t, 8&gt; magic_numbers
  {
    3545515123101087289, 3690191062107239479,
    3544956562637535289, 3978984379655991859,
    3689073941180135479, 4123101758198592049,
    3977867258728887859, 4122543197735040049
  };

  if(sq[4] != '5')
    return false;

  uint64_t magic_number =
    *(reinterpret_cast&lt;const uint32_t*&gt;
      (sq.data()));
  magic_number <<= 32;
  magic_number +=
    *(reinterpret_cast&lt;const uint32_t*&gt;
      (sq.data()+5));

  for(auto i = 0u; i &lt; 8; ++i)
    if(magic_number == magic_numbers[i])
      return true;
  return false;
}
    </pre>
	</td></tr></table>
	<p>
It doesn't look rather relevant on the first glance, but GCC does produce quite a different code for global and local variables.
	</p>
	<table><tr>
	<td>
	<pre>
_Z14check_if_magic ...
.LFB1752:
	.cfi_startproc
	<a title="Move quadword">movq</a>	(%rdi), %rdx
	<a title="Exclusive OR">xorl</a>	%eax, %eax
	<a title="Compare operands">cmpb</a>	$53, 4(%rdx)
	<a title="Jump if condition">je</a>	.L8
	<a title="Repeat MOVS/STOS/CMPS/LODS/SCAS">rep ret</a>
	.p2align 4,,10
	.p2align 3
.L8:
	<a title="Move">movl</a>	(%rdx), %ecx
	<a title="Move">movl</a>	5(%rdx), %eax
	<a title="Move">movabsq</a>	$3545515123101087289, %rdx
	<a title="Shift Arithmetically left (signed shift left)">salq</a>	$32, %rcx
	<a title="Add">addq</a>	%rax, %rcx
	<a title="Move">movl</a>	$_ZL13magic_numbers+8, %eax
	<a title="Jump">jmp</a>	.L3
	.p2align 4,,10
	.p2align 3
.L9:
	<a title="Move quadword">movq</a>	(%rax), %rdx
	<a title="Add">addq</a>	$8, %rax
.L3:
	<a title="Compare operands">cmpq</a>	%rdx, %rcx
	<a title="Jump if condition">je</a>	.L5
	<a title="Compare operands">cmpq</a>	$_ZL13magic_numbers+64, %rax
	<a title="Jump if condition">jne</a>	.L9
	<a title="Exclusive OR">xorl</a>	%eax, %eax
	<a title="Return from procedure">ret</a>
	.p2align 4,,10
	.p2align 3
.L5:
	<a title="Move">movl</a>	$1, %eax
	<a title="Return from procedure">ret</a>
	.cfi_endproc
	</pre>
	</td>
	<td>
	<pre>
_Z14check_if_magic ...
.LFB1752:
	.cfi_startproc
	subq	$88, %rsp
	.cfi_def_cfa_offset 96
	<a title="Move quadword">movq</a>	(%rdi), %rdx
	<a title="Move quadword">movq</a>	%fs:40, %rax
	<a title="Move quadword">movq</a>	%rax, 72(%rsp)
	<a title="Exclusive OR">xorl</a>	%eax, %eax
	<a title="Move">movabsq</a>	$3545515123101087289, %rax
	<a title="Move quadword">movq</a>	%rax, (%rsp)
	<a title="Move">movabsq</a>	$3690191062107239479, %rax
	<a title="Move quadword">movq</a>	%rax, 8(%rsp)
	<a title="Move">movabsq</a>	$3544956562637535289, %rax
	<a title="Move quadword">movq</a>	%rax, 16(%rsp)
	<a title="Move">movabsq</a>	$3978984379655991859, %rax
	<a title="Move quadword">movq</a>	%rax, 24(%rsp)
	<a title="Move">movabsq</a>	$3689073941180135479, %rax
	<a title="Move quadword">movq</a>	%rax, 32(%rsp)
	<a title="Move">movabsq</a>	$4123101758198592049, %rax
	<a title="Move quadword">movq</a>	%rax, 40(%rsp)
	<a title="Move">movabsq</a>	$3977867258728887859, %rax
	<a title="Move quadword">movq</a>	%rax, 48(%rsp)
	<a title="Move">movabsq</a>	$4122543197735040049, %rax
	<a title="Move quadword">movq</a>	%rax, 56(%rsp)
	<a title="Exclusive OR">xorl</a>	%eax, %eax
	<a title="Compare operands">cmpb</a>	$53, 4(%rdx)
	<a title="Jump if condition">je</a>	.L10
.L2:
	<a title="Move quadword">movq</a>	72(%rsp), %rsi
	<a title="Exclusive OR">xorq</a>	%fs:40, %rsi
	<a title="Jump if condition">jne</a>	.L11
	<a title="Add">addq</a>	$88, %rsp
	.cfi_remember_state
	.cfi_def_cfa_offset 8
	<a title="Return from procedure">ret</a>
	.p2align 4,,10
	.p2align 3
.L10:
	.cfi_restore_state
	<a title="Move">movl</a>	(%rdx), %ecx
	<a title="Move">movl</a>	5(%rdx), %eax
	<a title="Load Effective Address">leaq</a>	64(%rsp), %rsi
	<a title="Move">movabsq</a>	$3545515123101087289, %rdx
	<a title="Shift Arithmetically left (signed shift left)">salq</a>	$32, %rcx
	<a title="Add">addq</a>	%rax, %rcx
	<a title="Load Effective Address">leaq</a>	8(%rsp), %rax
	<a title="Jump">jmp</a>	.L3
	.p2align 4,,10
	.p2align 3
.L12:
	<a title="Move quadword">movq</a>	(%rax), %rdx
	<a title="Add">addq</a>	$8, %rax
.L3:
	<a title="Compare operands">cmpq</a>	%rdx, %rcx
	<a title="Jump if condition">je</a>	.L6
	<a title="Compare operands">cmpq</a>	%rsi, %rax
	<a title="Jump if condition">jne</a>	.L12
	<a title="Exclusive OR">xorl</a>	%eax, %eax
	<a title="Jump">jmp</a>	.L2
	.p2align 4,,10
	.p2align 3
.L6:
	<a title="Move">movl</a>	$1, %eax
	<a title="Jump">jmp</a>	.L2
.L11:
	<a title="Call procedure">call</a>	__stack_chk_fail
	.cfi_endproc
	</pre>
	</td></tr></table>
	<p>
Well, you might think that the right one is obviously worse. It fills the stack with out values every time the function is called. And it kind of is worse, but that's only because it's not what Adam had in mind. His version actually looks like this: <a href="https://godbolt.org/g/swssJY">godbolt.org/g/swssJY</a> and it is, of course, much-much better than mine.
	</p>
	<p>
The reason for this difference is me using an outdated compiler. And the moral is — update your compiler often.
	</p>

	<h2>
Loop vs. binary search
	</h2>
	<p>
Some guys from Reddit, particularly <a href="https://www.reddit.com/user/bschindl">bschindl</a>, <a href="https://www.reddit.com/user/Veedrac">Veedrac</a>, and <a href="https://www.reddit.com/user/PhilipTrettner">PhilipTrettner</a> came up with the idea of doing binary search. It is a great idea, but once again it doesn't work very well in this case because ideally all 8 64-bit squares fit in a single cache line anyway.
	</p>
	<table><tr>
	<td>
	<pre>
const std::array&lt;uint64_t, 8&gt; magic_numbers
{
  3545515123101087289, 3690191062107239479,
  3544956562637535289, 3978984379655991859,
  3689073941180135479, 4123101758198592049,
  3977867258728887859, 4122543197735040049
};
bool check_if_magic(const std::string& sq)
{
  if(sq[4] != '5')
    return false;

  uint64_t magic_number =
    *(reinterpret_cast&lt;const uint32_t*&gt;
      (sq.data()));
  magic_number <<= 32;
  magic_number +=
    *(reinterpret_cast&lt;const uint32_t*&gt;
      (sq.data()+5));

  for(auto i = 0u; i &lt; 8; ++i)
    if(magic_number == magic_numbers[i])
      return true;
  return false;
}
    </pre>
	</td>
	<td>
	<pre>
const std::array&lt;uint64_t, 8&gt; magic_numbers
{
3545515123101087289, 3690191062107239479,
3544956562637535289, 3978984379655991859,
3689073941180135479, 4123101758198592049,
3977867258728887859, 4122543197735040049
};
bool check_if_magic(const std::string& sq)
{
  if(square[4] != '5')
    return false;

  uint64_t nr =
    *(reinterpret_cast&lt;const uint32_t*&gt;
      (sq.data()));
  nr &lt;&lt;= 32;
  nr +=
    *(reinterpret_cast&lt;const uint32_t*&gt;
      (sq.data()+5));

  if (nr &lt;= 3690191062107239479)
    if (nr &lt;= 3545515123101087289)
      if (nr &lt; 3545515123101087289)
        return nr == 3544956562637535289;
      else
        return nr == 3545515123101087289;
    else
      if (nr &lt; 3690191062107239479)
        return nr == 3689073941180135479;
      else
        return nr == 3690191062107239479;
  else
    if (nr &lt;= 3978984379655991859)
      if (nr &lt; 3978984379655991859)
        return nr == 3977867258728887859;
      else
        return nr == 3978984379655991859;
    else
      if (nr &lt; 4123101758198592049)
        return nr == 4122543197735040049;
      else
        return nr == 4123101758198592049;
}
    </pre>
	</td></tr></table>
	<p>
Valgrind may confirm that sequential reading of 64 bytes is cheap. No only the version on the left has less instruction reads, but the data reads as well, which seems nonsensical.
	</p>
	<table><tr>
	<td>
	<pre>
I   refs:      10,699,297,900
I1  misses:             1,838
LLi misses:             1,701
I1  miss rate:           0.00%
LLi miss rate:           0.00%

D   refs:       5,521,473,844
    (3,342,039,069 rd   + 2,179,434,775 wr)
D1  misses:            15,883
    (       13,668 rd   +         2,215 wr)
LLd misses:             9,154
    (        7,758 rd   +         1,396 wr)
D1  miss rate:            0.0%
    (          0.0%     +           0.0%  )
LLd miss rate:            0.0%
    (          0.0%     +           0.0%  )

LL refs:               17,721
    (       15,506 rd   +         2,215 wr)
LL misses:             10,855
    (        9,459 rd   +         1,396 wr)
LL miss rate:             0.0%
    (          0.0%     +           0.0%  )
    </pre>
	</td>
	<td>
	<pre>
I   refs:      11,323,056,252
I1  misses:             1,845
LLi misses:             1,705
I1  miss rate:           0.00%
LLi miss rate:           0.00%

D   refs:       5,994,987,820
    (3,428,132,553 rd   + 2,566,855,267 wr)
D1  misses:            15,883
    (       13,666 rd   +         2,217 wr)
LLd misses:             9,154
    (        7,758 rd   +         1,396 wr)
D1  miss rate:            0.0%
    (          0.0%     +           0.0%  )
LLd miss rate:            0.0%
    (          0.0%     +           0.0%  )

LL refs:               17,728
    (       15,511 rd   +         2,217 wr)
LL misses:             10,859
    (        9,463 rd   +         1,396 wr)
LL miss rate:             0.0%
    (          0.0%     +           0.0%  )
    </pre>
	</td></tr></table>
	<p>
So a binary search is a bit worse than a simple loop. It is still extremely effective though. It's just with the plain loop being so small it doesn't make sense to make it even better.
	</p>
	<p>
But the most amazing thing was found by <a href="https://www.reddit.com/user/adamf88">adamf88</a>. It turn out, Clang can do this by itself: <a href="https://godbolt.org/g/cXtdbB">https://godbolt.org/g/cXtdbB</a>! I'm astonished.
	</p>
	<h2>
Smart lookup
	</h2>
	<p>
One of the best ideas was proposed by <a href="https://www.reddit.com/user/Veedrac">Veedrac</a>. I'm not sure how it works exactly, the indexing thins looks a bit magical to me, but it goes like this:
	</p>
	<table><tr>
	<td style="width: 505pt;">
	<pre>
const char squares[] =
    "   " "   " "   "  // -/1

    "276" "951" "438"  // 1/2
    "294" "753" "618"  // 2/3

    "438" "951" "276"  // 3/4
    "492" "357" "816"  // 4/5

    "618" "753" "294"  // 5/6
    "672" "159" "834"  // 6/7

    "816" "357" "492"  // 7/8
    "834" "159" "672"  // 8/9

    "   " "   " "   "; // 9/-

// UB if sq contains characters [^1-9]
//    or is not at least 9 characters long.
bool check_if_magic(const std::string& square_as_string) {
    const auto* square = square_as_string.data();
    if (square[4] != '5') {
        return false;
    }

    const auto idx = (*square - '1') * 9;
    return
        (!memcmp(square, &squares[idx],   9)) ||
        (!memcmp(square, &squares[idx+9], 9));
}
    </pre>
	</td>
	</td></tr></table>
	<p>
Unfortunately, I had to change the function signature to match the benchmark and it lost quite a lot of speed because of that. It runs for 1.7 seconds that is a little bit slower than 64-bits hack. It does have nicer disassembly though.
	</p>
	<table><tr>
	<td style="width: 505pt;">
	<pre>
_Z14check_if_magic ...
.LFB1779:
	.cfi_startproc
	<a title="Push data onto stack">pushq</a>	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	<a title="Push data onto stack">pushq</a>	%rbx
	.cfi_def_cfa_offset 24
	.cfi_offset 3, -24
	<a title="Exclusive OR">xorl</a>	%eax, %eax
	subq	$8, %rsp
	.cfi_def_cfa_offset 32
	<a title="Move quadword">movq</a>	(%rdi), %rbx
	<a title="Compare operands">cmpb</a>	$53, 4(%rbx)
	<a title="Jump if condition">je</a>	.L8
.L2:
	<a title="Add">addq</a>	$8, %rsp
	.cfi_remember_state
	.cfi_def_cfa_offset 24
	<a title="Pop data from stack">popq</a>	%rbx
	.cfi_def_cfa_offset 16
	<a title="Pop data from stack">popq</a>	%rbp
	.cfi_def_cfa_offset 8
	<a title="Return from procedure">ret</a>
	.p2align 4,,10
	.p2align 3
.L8:
	.cfi_restore_state
	<a title="Move">movsbl</a>	(%rbx), %eax
	<a title="Move">movl</a>	$9, %edx
	<a title="Move quadword">movq</a>	%rbx, %rdi
	<a title="Load Effective Address">leal</a>	-441(%rax,%rax,8), %ebp
	<a title="Move">movslq</a>	%ebp, %rsi
	<a title="Add">addq</a>	$_ZL7squares, %rsi
	<a title="Call procedure">call</a>	memcmp
	<a title="Move">movl</a>	%eax, %edx
	<a title="Move">movl</a>	$1, %eax
	<a title="Logical compare (AND)">testl</a>	%edx, %edx
	<a title="Jump if condition">je</a>	.L2
	<a title="Load Effective Address">leal</a>	9(%rbp), %esi
	<a title="Move quadword">movq</a>	%rbx, %rdi
	<a title="Move">movl</a>	$9, %edx
	<a title="Move">movslq</a>	%esi, %rsi
	<a title="Add">addq</a>	$_ZL7squares, %rsi
	<a title="Call procedure">call</a>	memcmp
	<a title="Logical compare (AND)">testl</a>	%eax, %eax
	<a title="Set byte to one on condition, zero otherwise">sete</a>	%al
	<a title="Add">addq</a>	$8, %rsp
	.cfi_def_cfa_offset 24
	<a title="Pop data from stack">popq</a>	%rbx
	.cfi_def_cfa_offset 16
	<a title="Pop data from stack">popq</a>	%rbp
	.cfi_def_cfa_offset 8
	<a title="Return from procedure">ret</a>
	.cfi_endproc
	</pre>
	</td>
	</td></tr></table>
	<p>
On Valgrind it shows like this:
    </p>
    <table><tr>
    <td style="width: 505pt;">
    <pre>
I   refs:      16,045,605,063
I1  misses:             1,849
LLi misses:             1,713
I1  miss rate:           0.00%
LLi miss rate:           0.00%


D   refs:       8,018,184,251
    (4,590,394,457 rd   + 3,427,789,794 wr)

D1  misses:            15,896
    (       13,678 rd   +         2,218 wr)

LLd misses:             9,159
    (        7,764 rd   +         1,395 wr)

D1  miss rate:            0.0%
    (          0.0%     +           0.0%  )

LLd miss rate:            0.0%
    (          0.0%     +           0.0%  )


LL refs:               17,745
    (       15,527 rd   +         2,218 wr)
LL misses:             10,872
    (        9,477 rd   +         1,395 wr)
LL miss rate:             0.0%
    (          0.0%     +           0.0%  )
    </pre>
	</td>
	</td></tr></table>
	<p>
Data-wise it's absolutely splendid! But it is a bit fat on instruction reads. I would blame `memcmp`. I heard, with better compilers and better standard library implementation it might get properly inlined and optimized contextually, but with my GCC it only gets called twice which is, in such a tight piece of code, simply too expensive.
	</p>
	<h2>
Smart indexing
	</h2>
	<p>
But the absolutely magical is the version from <a href="https://www.reddit.com/user/kocsis1david">kocsis1david</a>.
	</p>
	<table><tr>
	<td style="width: 505pt;">
	<pre>
static uint64_t magic_numbers[8] = {
    0x3336313832393437,
    0x3134333832373639,
    0x3734393238313633,
    0x3936373238333431,
    0x3332393436313837,
    0x3938333436373231,
    0x3738313634393233,
    0x3132373634333839,
};

static uint64_t magic_number(const char sq[9]) {
    uint32_t a, b;
    memcpy(&a, sq, sizeof(uint32_t));
    memcpy(&b, sq + 5, sizeof(uint32_t));
    return ((uint64_t)a &lt;&lt; 32) + b;
}

bool check_if_magic(const std::string& square) {
    const auto* sq = square.data();
    if (sq[4] != '5')
        return false;

    int index = sq[0] & 7 | (sq[1] &gt;&gt; 1) & 1;
    return magic_numbers[index] == magic_number(sq);
}
    </pre>
	</td>
	</td></tr></table>
	<p>
It also exploits the same smart indexing idea, but it uses less instructions and no external calls whatsoever.
	</p>
	<p>
Its Valgrind report is impressive too!
	</p>
	<table><tr>
	<td style="width: 505pt;">
	<pre>
I   refs:      8,977,429,337
I1  misses:            1,842
LLi misses:            1,704
I1  miss rate:          0.00%
LLi miss rate:          0.00%


D   refs:      5,349,287,013
    (3,169,852,226 rd   + 2,179,434,787 wr)

D1  misses:           15,885
    (       13,668 rd   +         2,217 wr)

LLd misses:            9,155
    (        7,759 rd   +         1,396 wr)

D1  miss rate:           0.0%
    (          0.0%     +           0.0%  )

LLd miss rate:           0.0%
    (          0.0%     +           0.0%  )


LL refs:              17,727
    (       15,510 rd   +         2,217 wr)

LL misses:            10,859
    (        9,463 rd   +         1,396 wr)

LL miss rate:            0.0%
    (          0.0%     +           0.0%  )
    </pre>
	</td>
	</td></tr></table>
	<p>
<a title="Logical AND">And</a> it runs for little less than a second which, considering the generator takes some 0.8 of it, is almost 3 times faster than the best take I had to offer.
	</p>
	<p>
Excellent!
	</p>
	<h2>
Conclusion
	</h2>
	<p>
I don't know about you, but I learned from this idea exchange quite a lot. Way more than from tinkering with a toy problem all on my own.
	</p>
	<p>
We should do this again sometime. Probably, with better benchmark though. And a better problem. And Clang. I'm fascinated to try Clang at this point.
	</p>


	<table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
	<tr>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
		<a href="index.html">Index</a>
		<a href="index.html"><img src="favicon.svg"></a>
	</td>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
		&nbsp;&larr; there's more.
	</td>
	<td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
		+
		<a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
		<a href="https://twitter.com/wordsandbuttons">Twitter</a> &
		<a href="https://wordsandbuttons.online/rss"><span style="letter-spacing: 1pt;">RSS</span></a>
	</td>
	</tr>
	</table>
	</center>
</body>
</html>
