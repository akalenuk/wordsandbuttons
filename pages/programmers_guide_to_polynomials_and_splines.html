<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Programmer's guide to polynomials and splines</title>
	<meta name="description" content="This is a brief introduction into polynomials. From how to make a polynomial run through your set of points to how to make it into a spline.">
	<meta name="keywords" content="mathematics, tutorials">
	<link rel="shortcut icon" type="image/x-icon" href="favicon.svg" />
	<style>
body{
	margin: 0 0 0 0;
}

a{
	text-decoration: none;
}

h1 {
	padding-top: 36pt;
	font-size: 24pt;
	width: 600pt;
	text-align: left;
}

h2 {
	padding-top: 20pt;
	font-size: 20pt;
	width: 555pt;
	text-align: left;
}

p {
	line-height: 1.42;
	font-size: 16pt;
	width: 505pt;
	text-align: left;
}

.formula {
	font-family: sans-serif;
	font-size: 15pt;
	font-style: italic;
	text-align: center;
	padding-top: 6pt;
	padding-bottom: 6pt;
}

table.footer {
	padding: 64pt 0pt 32pt 0pt;
	background-color: transparent;
	width: 505pt;
}

td.footer {
	font-family: sans-serif;
	font-size: 16pt;
	font-style: normal;
	padding: 0;
	margin: 0;
	border: 0;
}

table {
	font-family: sans-serif;
	font-size: 13pt;
	font-style: italic;
	width: 505pt;
	text-align: center;
}

td {
	vertical-align: text-top;
	padding-top: 6pt;
	padding-bottom: 6pt;
}

li {
	font-size: 16pt;
	width: 505pt;
	text-align: left;
	padding-bottom: 6pt;
}

form {
	margin: 0 0 0 0;
	padding-top: 12pt;
	padding-left: 12pt;
	padding-right: 12pt;
	padding-bottom: 12pt;
	font-size: 16pt;
	text-align: left;
	width: 505pt;
	background-color: #eeee99;
	color: #000;
}

input[type="text"] {
	width: 100pt;
	height: 22pt;
	margin: 8pt 8pt 8pt 8pt;
	padding-left: 3pt;
	font-size: 16pt;
}

button {
	width: 108pt;
	height: 28pt;
	margin-left:4pt;
	margin-right:4pt;
	font-size: 16pt;
}

i {
	font-family: sans-serif;
	font-size: 15pt;
	font-style: italic;
}

u {
	border-bottom: 1px dotted #000;
	text-decoration: none;
	cursor: pointer;
}
	</style>
	<script language="JavaScript">

// client
var w = 640.0;
var h = 512.0;

// visible region
var x_min = -1.0;
var y_min = -1.0;
var x_max = 9.0;
var y_max = 7.0;

var client_x_center = w*(0-x_min)/(x_max-x_min);
var client_x_step = (w/(x_max-x_min));

var client_y_center = h - h*(0-y_min)/(y_max-y_min);
var client_y_step = (h/(y_max-y_min));

function client_to_x(client_x){
	return (client_x - client_x_center) / client_x_step;
}

function client_to_y(client_y){
	return (client_y_center - client_y) / client_y_step;
}

function x_to_client(x){
	return x * client_x_step + client_x_center;
}

function y_to_client(y){
	return client_y_center - y * client_y_step;
}

function sign_0_positive(x){ // Math.sign like with no 0 option
	if(x >= 0)
		return 1.0;
	return -1.0;
}

function underflow_padded(x){
	if(Math.abs(x) < 1.e-5) // pixel-size input error is ok, so we don't want much precision anyway
		return 1.e-5 * sign_0_positive(x);
	return x;
}

function solved_linear(A, B, n){
	var X = [];
	for (var i = 0; i < n; ++i)
		X[i] = 0.0;

	// triangulize
	for (var i = 0; i < n-1; ++i)
		for (var j = 0; j < i+1; ++j) {
			r = A[i+1][j] / underflow_padded(A[j][j]);
			A[i+1][j] = 0.;
			for (var b_j = j+1; b_j < n; ++b_j){
				A[i+1][b_j] -= A[j][b_j]*r;
			}
			B[i+1] -= B[j]*r;
		}

	// calculate xs
	X[n-1] = B[n-1] / underflow_padded(A[n-1][n-1]);
	for (var i = n-2; i >= 0; --i){
		var s = 0.0;
		for (var j = i; j < n; ++j){
			s = s + A[i][j]*X[j];
		}
		X[i] = (B[i] - s) / underflow_padded(A[i][i]);
	}
	return X;
}

function polynomial_in_x(A, x, n){
	var y = 0.0;
	for(var i = 0; i < n; ++i){
		y += A[i] * Math.pow(x, i);
	}
	return y;
}

function draw_grid_on(context){
	// grid
	context.beginPath();
	for(var i = x_min + 1; i <= x_max - 1; i++){
		if(i != 0) {
			context.moveTo(client_x_center + i*client_x_step + 0.5, 0);
			context.lineTo(client_x_center + i*client_x_step + 0.5, h+1);
		}
	}
	for(var i = y_min + 1; i <= y_max - 1; i++){
		if(i != 0) {
			context.moveTo(0, client_y_center - i*client_y_step + 0.5);
			context.lineTo(w+1, client_y_center - i*client_y_step + 0.5);
		}
	}
	context.strokeStyle="#999999";
	context.stroke();
	context.closePath();

	context.beginPath();
	context.moveTo(0, client_y_center + 0.5);
	context.lineTo(w, client_y_center + 0.5);
	context.lineTo(w - 12, client_y_center - 5 + 0.5);
	context.moveTo(w, client_y_center + 0.5);
	context.lineTo(w - 12, client_y_center + 5 + 0.5);
	context.moveTo(client_x_center + 0.5, h);
	context.lineTo(client_x_center + 0.5, 0);
	context.lineTo(client_x_center - 5 + 0.5, 12);
	context.moveTo(client_x_center + 0.5, 0);
	context.lineTo(client_x_center + 5 + 0.5, 12);
	context.fillStyle="#000000";
	for(var i = x_min + 1; i <= x_max - 1; i++){
		if(i != 0) {
			context.moveTo(client_x_center + i*client_x_step + 0.5, client_y_center);
			context.lineTo(client_x_center + i*client_x_step + 0.5, client_y_center - 5);
			context.fillText(i, client_x_center + i*client_x_step + 4, client_y_center + 16);
		}
	}
	for(var i = y_min + 1; i <= y_max - 1; i++){
		if(i != 0) {
			context.moveTo(client_x_center, client_y_center - i*client_y_step + 0.5);
			context.lineTo(client_x_center + 5, client_y_center - i*client_y_step + 0.5);
		}
		context.fillText(i, client_x_center + 5, client_y_center - i*client_y_step + 16);
	}
	context.strokeStyle="#000000";
	context.stroke();
	context.closePath();
}

// polynomial
var polynomial_xs = [1.0, 4.0, 7.0];
var polynomial_ys = [5.0, 2.0, 5.0];
var polynomial_n = 3;
var polynomial_i = 0;

function init_polynomial(){
	polynomial = document.getElementById("polynomial");
	var canvas_rect = polynomial.getBoundingClientRect();
	polynomial_draw(0, 0, false);

	polynomial.addEventListener('mousemove', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		polynomial_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		if(e.buttons == 1){
			polynomial_xs[polynomial_i] = client_to_x(e.clientX - canvas_rect.left);
			polynomial_ys[polynomial_i] = client_to_y(e.clientY - canvas_rect.top);
			polynomial_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
		}
	}, false);

	polynomial.addEventListener('mousedown', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		polynomial_xs[polynomial_i] = client_to_x(e.clientX - canvas_rect.left);
		polynomial_ys[polynomial_i] = client_to_y(e.clientY - canvas_rect.top);
		polynomial_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
	}, false);

	polynomial.addEventListener('mouseleave', function(e){
		polynomial_draw(0, 0, false);
	}, false);
}

function polynomial_draw(client_x, client_y, do_guides){
	polynomial = document.getElementById("polynomial");
	var polynomial_context = polynomial.getContext("2d");
	polynomial_context.font = "16px sans-serif";
	// background
	polynomial_context.fillStyle="#eeeeee";
	polynomial_context.fillRect(0, 0, w, h);

	// grid
	draw_grid_on(polynomial_context);

	// polynomial
	var A = [];
	var B = [];
	for(var i = 0; i < polynomial_n; ++i){
		A[i] = [];
		for(var j = 0; j < polynomial_n; ++j){
			A[i][j] = Math.pow(polynomial_xs[i], j);
		}
		B[i] = polynomial_ys[i];
	}

	X = solved_linear(A, B, polynomial_n);

	polynomial_system = document.getElementById("polynomial_system");
	polynomial_system.innerHTML = "P(x<sub>1</sub>) = "+polynomial_xs[0].toFixed(2)+"<sup>2</sup>a + "+polynomial_xs[0].toFixed(2)+" b + c = "+polynomial_ys[0].toFixed(2);
	polynomial_system.innerHTML += "<br>";
	polynomial_system.innerHTML += "P(x<sub>2</sub>) = "+polynomial_xs[1].toFixed(2)+"<sup>2</sup>a + "+polynomial_xs[1].toFixed(2)+" b + c = "+polynomial_ys[1].toFixed(2);
	polynomial_system.innerHTML += "<br>";
	polynomial_system.innerHTML += "P(x<sub>3</sub>) = "+polynomial_xs[2].toFixed(2)+"<sup>2</sup>a + "+polynomial_xs[2].toFixed(2)+" b + c = "+polynomial_ys[2].toFixed(2);
	polynomial_formula = document.getElementById("polynomial_formula");
	polynomial_formula.innerHTML = "a = " + X[2].toFixed(2) + ", b = " + X[1].toFixed(2) + ", c = " + X[0].toFixed(2);
	polynomial_formula.innerHTML += "<br>";
	polynomial_formula.innerHTML += "P(x) = " + X[2].toFixed(2) + "x<sup>2</sup> + " + X[1].toFixed(2) + "x + " + X[0].toFixed(2);

	polynomial_context.beginPath();
	polynomial_context.lineWidth = 2;
	polynomial_context.strokeStyle="#d64562";
	for(var j = 0; j < w; ++j){
		const x = client_to_x(j);
		const y = polynomial_in_x(X, x, polynomial_n);
		if(j == 0) {
			polynomial_context.moveTo(x_to_client(x), y_to_client(y));
		} else {
			polynomial_context.lineTo(x_to_client(x), y_to_client(y));
		}
	}
	polynomial_context.stroke();
	polynomial_context.closePath();
	polynomial_context.lineWidth = 1;

	// dots
	polynomial_context.fillStyle="#d64562";
	for(var i = 0; i < polynomial_n; ++i){
		const xi = x_to_client(polynomial_xs[i]) + 0.5;
		const yi = y_to_client(polynomial_ys[i]) + 0.5;
		polynomial_context.beginPath();
		polynomial_context.arc(xi, yi, 4, 0, 2*Math.PI);
		polynomial_context.stroke();
		polynomial_context.fill();
		polynomial_context.closePath();
	}

	// guides
	if(do_guides){
		min_d = Math.pow(polynomial_xs[0] - client_to_x(client_x), 2) + Math.pow(polynomial_ys[0] - client_to_y(client_y), 2);
		min_i = 0;
		for(var i = 1; i < polynomial_n; ++i){
			var di = Math.pow(polynomial_xs[i] - client_to_x(client_x), 2) + Math.pow(polynomial_ys[i] - client_to_y(client_y), 2);
			if(di < min_d){
				min_d = di;
				min_i = i;
			}
		}
		polynomial_i = min_i;
		polynomial_context.setLineDash([4, 4]);
		polynomial_context.beginPath();
		polynomial_context.moveTo(x_to_client(polynomial_xs[min_i]), y_to_client(polynomial_ys[min_i]));
		polynomial_context.lineTo(client_x, client_y);
		polynomial_context.strokeStyle="#d64562";
		polynomial_context.stroke();
		polynomial_context.closePath();
		polynomial_context.setLineDash([]);
	}
}


// synthesis
var synthesis_xs = [-0.5, 1.0, 7.0, 8.5];
var synthesis_ys = [ 2.0, 1.0, 6.0, 5.0];
var synthesis_n = 4;
var synthesis_i = 0;

function init_synthesis(){
	synthesis = document.getElementById("synthesis");
	var canvas_rect = synthesis.getBoundingClientRect();
	synthesis_draw(0, 0, false);

	synthesis.addEventListener('mousemove', function(e){
		var canvas_rect = synthesis.getBoundingClientRect();
		synthesis_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		if(e.buttons == 1){
			synthesis_xs[synthesis_i] = client_to_x(e.clientX - canvas_rect.left);
			synthesis_ys[synthesis_i] = client_to_y(e.clientY - canvas_rect.top);
			synthesis_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
		}
	}, false);

	synthesis.addEventListener('mousedown', function(e){
		var canvas_rect = synthesis.getBoundingClientRect();
		synthesis_xs[synthesis_i] = client_to_x(e.clientX - canvas_rect.left);
		synthesis_ys[synthesis_i] = client_to_y(e.clientY - canvas_rect.top);
		synthesis_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
	}, false);

	synthesis.addEventListener('mouseleave', function(e){
		synthesis_draw(0, 0, false);
	}, false);
}

function synthesis_draw(client_x, client_y, do_guides){
	synthesis = document.getElementById("synthesis");
	var synthesis_context = synthesis.getContext("2d");
	synthesis_context.font = "16px sans-serif";
	// background
	synthesis_context.fillStyle="#eeeeee";
	synthesis_context.fillRect(0, 0, w, h);

	// synthesis
	var A = [];
	var B = [];

	A[0] = [];
	for(var j = 0; j < synthesis_n-1; ++j)
		A[0][j+1] = Math.pow(synthesis_xs[1], j) * (j+1);
	A[0][0] = 0.0;
	B[0] = (synthesis_ys[1] - synthesis_ys[0]) / (synthesis_xs[1] - synthesis_xs[0]);

	for(var i = 1; i < synthesis_n-1; ++i){
		A[i] = [];
		for(var j = 0; j < synthesis_n; ++j){
			A[i][j] = Math.pow(synthesis_xs[i], j);
		}
		B[i] = synthesis_ys[i];
	}

	A[synthesis_n-1] = [];
	for(var j = 0; j < synthesis_n-1; ++j)
		A[synthesis_n-1][j+1] = Math.pow(synthesis_xs[synthesis_n-2], j) * (j+1);
	A[synthesis_n-1][0] = 0.0;
	B[synthesis_n-1] = (synthesis_ys[synthesis_n-1] - synthesis_ys[synthesis_n-2]) / (synthesis_xs[synthesis_n-1] - synthesis_xs[synthesis_n-2]);

	synthesis_system = document.getElementById("synthesis_system");
	synthesis_system.innerHTML = "P(x<sub>1</sub>)' = "+A[0][3].toFixed(1)+"a + "+A[0][2].toFixed(1)+"b + "+A[0][1].toFixed(1)+"c = "+B[0].toFixed(1);
	synthesis_system.innerHTML += "<br>";
	synthesis_system.innerHTML += "P(x<sub>1</sub>) = "+A[1][3].toFixed(1)+"a + "+A[1][2].toFixed(1)+"b + "+A[1][1].toFixed(1)+"c + "+A[1][0].toFixed(1)+"d = "+B[1].toFixed(1);
	synthesis_system.innerHTML += "<br>";
	synthesis_system.innerHTML += "P(x<sub>2</sub>) = "+A[2][3].toFixed(1)+"a + "+A[2][2].toFixed(1)+"b + "+A[2][1].toFixed(1)+"c + "+A[2][0].toFixed(1)+"d = "+B[2].toFixed(1);
	synthesis_system.innerHTML += "<br>";
	synthesis_system.innerHTML += "P(x<sub>2</sub>)' = "+A[3][3].toFixed(1)+"a + "+A[3][2].toFixed(1)+"b + "+A[3][1].toFixed(1)+"c = "+B[3].toFixed(1);

	X = solved_linear(A, B, synthesis_n);

	synthesis_formula = document.getElementById("synthesis_formula");
	synthesis_formula.innerHTML = "a = " + X[3].toFixed(2) + ", b = " + X[2].toFixed(2) + ", c = " + X[1].toFixed(2) + ", d = " + X[0].toFixed(2);
	synthesis_formula.innerHTML += "<br>";
	synthesis_formula.innerHTML += "P(x) = " + X[3].toFixed(2) + "x<sup>3</sup> + " + X[2].toFixed(2) + "x<sup>2</sup> + " + X[1].toFixed(2) + "x + " + X[0].toFixed(2);

	// grid
	draw_grid_on(synthesis_context);

	// back
	synthesis_context.beginPath();
	synthesis_context.lineWidth = 1;
	synthesis_context.strokeStyle="#de7e8d";
	for(var j = 0; j < w; ++j){
		const x = client_to_x(j);
		const y = polynomial_in_x(X, x, synthesis_n);
		if(j == 0) {
			synthesis_context.moveTo(x_to_client(x), y_to_client(y));
			first_back = false;
		} else {
			synthesis_context.lineTo(x_to_client(x), y_to_client(y));
		}
	}
	synthesis_context.stroke();
	synthesis_context.closePath();
	synthesis_context.lineWidth = 1;
	// front
	synthesis_context.beginPath();
	synthesis_context.lineWidth = 2;
	synthesis_context.strokeStyle="#d64562";
	var first_front = true;
	for(var j = 0; j < w; ++j){
		const x = client_to_x(j);
		const y = polynomial_in_x(X, x, synthesis_n);
		if(x >= synthesis_xs[1] && x <= synthesis_xs[2]){
			if(first_front) {
				synthesis_context.moveTo(x_to_client(x), y_to_client(y));
				first_front = false;
			} else {
				synthesis_context.lineTo(x_to_client(x), y_to_client(y));
			}
		}
	}
	synthesis_context.stroke();
	synthesis_context.closePath();
	synthesis_context.lineWidth = 1;

	// dots
	synthesis_context.fillStyle="#d64562";
	synthesis_context.strokeStyle="#d64562";
	for(var i = 0; i < synthesis_xs.length; ++i){
		const xi = x_to_client(synthesis_xs[i]) + 0.5;
		const yi = y_to_client(synthesis_ys[i]) + 0.5;
		synthesis_context.beginPath();
		synthesis_context.arc(xi, yi, 4, 0, 2*Math.PI);
		synthesis_context.stroke();
		synthesis_context.fill();
		synthesis_context.closePath();
	}

	// tangents
	synthesis_context.beginPath();
	synthesis_context.setLineDash([4, 4]);
	synthesis_context.moveTo(x_to_client(synthesis_xs[0]), y_to_client(synthesis_ys[0]));
	synthesis_context.lineTo(x_to_client(synthesis_xs[1]), y_to_client(synthesis_ys[1]));
	synthesis_context.moveTo(x_to_client(synthesis_xs[synthesis_n-2]), y_to_client(synthesis_ys[synthesis_n-2]));
	synthesis_context.lineTo(x_to_client(synthesis_xs[synthesis_n-1]), y_to_client(synthesis_ys[synthesis_n-1]));
	synthesis_context.strokeStyle="#d64562";
	synthesis_context.stroke();
	synthesis_context.setLineDash([]);
	synthesis_context.closePath();

	// guides
	if(do_guides){
		min_d = Math.pow(synthesis_xs[0] - client_to_x(client_x), 2) + Math.pow(synthesis_ys[0] - client_to_y(client_y), 2);
		min_i = 0;
		for(var i = 1; i < synthesis_n; ++i){
			var di = Math.pow(synthesis_xs[i] - client_to_x(client_x), 2) + Math.pow(synthesis_ys[i] - client_to_y(client_y), 2);
			if(di < min_d){
				min_d = di;
				min_i = i;
			}
		}
		synthesis_i = min_i;
		synthesis_context.setLineDash([4, 4]);
		synthesis_context.beginPath();
		synthesis_context.moveTo(x_to_client(synthesis_xs[min_i]), y_to_client(synthesis_ys[min_i]));
		synthesis_context.lineTo(client_x, client_y);
		synthesis_context.strokeStyle="#d64562";
		synthesis_context.stroke();
		synthesis_context.closePath();
		synthesis_context.setLineDash([]);
	}
}


// Runge
var runge_xs = [-1.0, 0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0];
var runge_ys = [ 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 5.0, 4.0, 3.0, 2.0, 1.0];
var runge_n = 11;
var runge_i = 0;

function init_runge(){
	runge = document.getElementById("runge");
	var canvas_rect = runge.getBoundingClientRect();
	runge_draw(0, 0, false);

	runge.addEventListener('mousemove', function(e){
		var canvas_rect = runge.getBoundingClientRect();
		runge_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		if(e.buttons == 1){
			runge_xs[runge_i] = client_to_x(e.clientX - canvas_rect.left);
			runge_ys[runge_i] = client_to_y(e.clientY - canvas_rect.top);
			runge_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
		}
	}, false);

	runge.addEventListener('mousedown', function(e){
		var canvas_rect = runge.getBoundingClientRect();
		runge_xs[runge_i] = client_to_x(e.clientX - canvas_rect.left);
		runge_ys[runge_i] = client_to_y(e.clientY - canvas_rect.top);
		runge_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
	}, false);

	runge.addEventListener('mouseleave', function(e){
		runge_draw(0, 0, false);
	}, false);
}

function runge_draw(client_x, client_y, do_guides){
	runge = document.getElementById("runge");
	var runge_context = runge.getContext("2d");
	runge_context.font = "16px sans-serif";
	// background
	runge_context.fillStyle="#eeeeee";
	runge_context.fillRect(0, 0, w, h);

	// grid
	draw_grid_on(runge_context);

	// runge
	var A = [];
	var B = [];
	for(var i = 0; i < runge_n; ++i){
		A[i] = [];
		for(var j = 0; j < runge_n; ++j){
			A[i][j] = Math.pow(runge_xs[i], j);
		}
		B[i] = runge_ys[i];
	}

	X = solved_linear(A, B, runge_n);

	runge_context.beginPath();
	runge_context.lineWidth = 2;
	runge_context.strokeStyle="#d64562";
	for(var j = 0; j < w; ++j){
		const x = client_to_x(j);
		const y = polynomial_in_x(X, x, runge_n);
		if(j == 0) {
			runge_context.moveTo(x_to_client(x), y_to_client(y));
		} else {
			runge_context.lineTo(x_to_client(x), y_to_client(y));
		}
	}
	runge_context.stroke();
	runge_context.closePath();
	runge_context.lineWidth = 1;

	// dots
	runge_context.fillStyle="#d64562";
	runge_context.strokeStyle="#d64562";
	for(var i = 0; i < runge_xs.length; ++i){
		const xi = x_to_client(runge_xs[i]) + 0.5;
		const yi = y_to_client(runge_ys[i]) + 0.5;
		runge_context.beginPath();
		runge_context.arc(xi, yi, 4, 0, 2*Math.PI);
		runge_context.stroke();
		runge_context.fill();
		runge_context.closePath();
	}

	// guides
	if(do_guides){
		min_d = Math.pow(runge_xs[0] - client_to_x(client_x), 2) + Math.pow(runge_ys[0] - client_to_y(client_y), 2);
		min_i = 0;
		for(var i = 1; i < runge_n; ++i){
			var di = Math.pow(runge_xs[i] - client_to_x(client_x), 2) + Math.pow(runge_ys[i] - client_to_y(client_y), 2);
			if(di < min_d){
				min_d = di;
				min_i = i;
			}
		}
		runge_i = min_i;
		runge_context.setLineDash([4, 4]);
		runge_context.beginPath();
		runge_context.moveTo(x_to_client(runge_xs[min_i]), y_to_client(runge_ys[min_i]));
		runge_context.lineTo(client_x, client_y);
		runge_context.strokeStyle="#d64562";
		runge_context.stroke();
		runge_context.closePath();
		runge_context.setLineDash([]);
	}
}


// Chebyshev
function chebyshev_node(k, n){
	return Math.cos(Math.PI*(2*k - 1)/(2*n));
}

// Chebyshev visible region
var chebyshev_x_min = -1.2;
var chebyshev_y_min = -0.2;
var chebyshev_x_max = 1.2;
var chebyshev_y_max = 1.2;

var chebyshev_client_x_center = w*(0-chebyshev_x_min)/(chebyshev_x_max-chebyshev_x_min);
var chebyshev_client_x_step = (w/(chebyshev_x_max-chebyshev_x_min));

var chebyshev_client_y_center = h - h*(0-chebyshev_y_min)/(chebyshev_y_max-chebyshev_y_min);
var chebyshev_client_y_step = (h/(chebyshev_y_max-chebyshev_y_min));

function chebyshev_client_to_x(client_x){
	return (client_x - chebyshev_client_x_center) / chebyshev_client_x_step;
}

function chebyshev_client_to_y(client_y){
	return (chebyshev_client_y_center - client_y) / chebyshev_client_y_step;
}

function chebyshev_x_to_client(x){
	return x * chebyshev_client_x_step + chebyshev_client_x_center;
}

function chebyshev_y_to_client(y){
	return chebyshev_client_y_center - y * chebyshev_client_y_step;
}

// Chebyshev points
var chebyshev_xs = [-1.0, -0.8, -0.6, -0.4, -0.2, 0.0, 0.2, 0.4, 0.6, 0.8, 1.0];
var chebyshev_ys = [ 0.1,  0.2,  0.3,  0.4,  0.5, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1];
var chebyshev_n = 11;
var chebyshev_i = 0;

function init_chebyshev(){
	for(var i = 0; i < chebyshev_n; ++i){
		chebyshev_xs[i] = chebyshev_node(i+1, chebyshev_n);
		chebyshev_ys[i] = Math.sqrt(1 - Math.pow(chebyshev_xs[i], 2))
	}
	chebyshev = document.getElementById("chebyshev");
	var canvas_rect = chebyshev.getBoundingClientRect();
	chebyshev_draw(0, 0, false);

	chebyshev.addEventListener('mousemove', function(e){
		var canvas_rect = chebyshev.getBoundingClientRect();
		chebyshev_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		if(e.buttons == 1){
			chebyshev_ys[chebyshev_i] = chebyshev_client_to_y(e.clientY - canvas_rect.top);
			chebyshev_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
		}
	}, false);

	chebyshev.addEventListener('mousedown', function(e){
		var canvas_rect = chebyshev.getBoundingClientRect();

		const client_x = e.clientX - canvas_rect.left;
		const client_y = e.clientY - canvas_rect.top;
		min_d = Math.abs(chebyshev_xs[0] - chebyshev_client_to_x(client_x));
		min_i = 0;
		for(var i = 1; i < chebyshev_n; ++i){
			var di = Math.abs(chebyshev_xs[i] - chebyshev_client_to_x(client_x));
			if(di < min_d){
				min_d = di;
				min_i = i;
			}
		}
		chebyshev_i = min_i;

		chebyshev_ys[chebyshev_i] = chebyshev_client_to_y(client_y);
		chebyshev_draw(client_x, client_y, false);


	}, false);

	chebyshev.addEventListener('mouseleave', function(e){
		chebyshev_draw(0, 0, false);
	}, false);
}

function chebyshev_draw(client_x, client_y, do_guides){
	chebyshev = document.getElementById("chebyshev");
	var chebyshev_context = chebyshev.getContext("2d");
	chebyshev_context.font = "16px sans-serif";
	// background
	chebyshev_context.fillStyle="#eeeeee";
	chebyshev_context.fillRect(0, 0, w, h);

	// grid
	chebyshev_context.beginPath();
	chebyshev_context.moveTo(0, chebyshev_client_y_center + 0.5);
	chebyshev_context.lineTo(w+1, chebyshev_client_y_center + 0.5);
	chebyshev_context.lineTo(w - 12, chebyshev_client_y_center - 5 + 0.5);
	chebyshev_context.moveTo(w, chebyshev_client_y_center + 0.5);
	chebyshev_context.lineTo(w - 12, chebyshev_client_y_center + 5 + 0.5);
	chebyshev_context.moveTo(chebyshev_client_x_center + 0.5, h+1);
	chebyshev_context.lineTo(chebyshev_client_x_center + 0.5, 0);
	chebyshev_context.lineTo(chebyshev_client_x_center - 5 + 0.5, 12);
	chebyshev_context.moveTo(chebyshev_client_x_center + 0.5, 0);
	chebyshev_context.lineTo(chebyshev_client_x_center + 5 + 0.5, 12);
	chebyshev_context.fillStyle="#000000";
	for(var i = x_min + 1; i <= x_max - 1; i++){
		if(i != 0) {
			chebyshev_context.moveTo(chebyshev_client_x_center + i*chebyshev_client_x_step, chebyshev_client_y_center);
			chebyshev_context.lineTo(chebyshev_client_x_center + i*chebyshev_client_x_step, chebyshev_client_y_center - 5);
			chebyshev_context.fillText(i, chebyshev_client_x_center + i*chebyshev_client_x_step + 4, chebyshev_client_y_center + 16);
		}
	}
	for(var i = y_min + 1; i <= y_max - 1; i++){
		if(i != 0) {
			chebyshev_context.moveTo(chebyshev_client_x_center, chebyshev_client_y_center - i*chebyshev_client_y_step);
			chebyshev_context.lineTo(chebyshev_client_x_center + 5, chebyshev_client_y_center - i*chebyshev_client_y_step);
		}
		chebyshev_context.fillText(i, chebyshev_client_x_center + 5, chebyshev_client_y_center - i*chebyshev_client_y_step + 16);
	}
	chebyshev_context.strokeStyle="#000000";
	chebyshev_context.stroke();
	chebyshev_context.closePath();

	// polynomial
	var A = [];
	var B = [];
	for(var i = 0; i < chebyshev_n; ++i){
		A[i] = [];
		for(var j = 0; j < chebyshev_n; ++j){
			A[i][j] = Math.pow(chebyshev_xs[i], j);
		}
		B[i] = chebyshev_ys[i];
	}

	X = solved_linear(A, B, chebyshev_n);

	chebyshev_context.beginPath();
	chebyshev_context.lineWidth = 2;
	chebyshev_context.strokeStyle="#d64562";
	for(var j = 0; j < w; ++j){
		const x = chebyshev_client_to_x(j);
		const y = polynomial_in_x(X, x, chebyshev_n);
		if(j == 0) {
			chebyshev_context.moveTo(chebyshev_x_to_client(x), chebyshev_y_to_client(y));
		} else {
			chebyshev_context.lineTo(chebyshev_x_to_client(x), chebyshev_y_to_client(y));
		}
	}
	chebyshev_context.stroke();
	chebyshev_context.closePath();
	chebyshev_context.lineWidth = 1;

	// dots
	chebyshev_context.fillStyle="#d64562";
	chebyshev_context.strokeStyle="#d64562";
	for(var i = 0; i < chebyshev_xs.length; ++i){
		const xi = chebyshev_x_to_client(chebyshev_xs[i]) + 0.5;
		const yi = chebyshev_y_to_client(chebyshev_ys[i]) + 0.5;
		chebyshev_context.beginPath();
		chebyshev_context.arc(xi, yi, 4, 0, 2*Math.PI);
		chebyshev_context.stroke();
		chebyshev_context.fill();
		chebyshev_context.closePath();
	}

	// guides
	chebyshev_context.setLineDash([4, 4]);
	chebyshev_context.beginPath();
	for(var i = 0; i < chebyshev_n; ++i){
		chebyshev_context.moveTo(chebyshev_x_to_client(chebyshev_xs[i]), h);
		chebyshev_context.lineTo(chebyshev_x_to_client(chebyshev_xs[i]), 0);
	}
	chebyshev_context.strokeStyle="#d64562";
	chebyshev_context.stroke();
	chebyshev_context.closePath();
	chebyshev_context.setLineDash([]);
}


// spline
var spline_xs = [-0.5, 0.5, 4.0, 3.0, 8.5, 7.5];
var spline_ys = [ 2.0, 1.0, 3.0, 4.0, 5.0, 6.0];
var spline_n = 6;
var spline_i = 0;

function init_spline(){
	spline = document.getElementById("spline");
	var canvas_rect = spline.getBoundingClientRect();
	spline_draw(0, 0, false);

	spline.addEventListener('mousemove', function(e){
		var canvas_rect = spline.getBoundingClientRect();
		spline_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		if(e.buttons == 1){
			spline_xs[spline_i] = client_to_x(e.clientX - canvas_rect.left);
			spline_ys[spline_i] = client_to_y(e.clientY - canvas_rect.top);
			spline_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
		}
	}, false);

	spline.addEventListener('mousedown', function(e){
		var canvas_rect = spline.getBoundingClientRect();
		spline_xs[spline_i] = client_to_x(e.clientX - canvas_rect.left);
		spline_ys[spline_i] = client_to_y(e.clientY - canvas_rect.top);
		spline_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
	}, false);

	spline.addEventListener('mouseleave', function(e){
		spline_draw(0, 0, false);
	}, false);
}

function spline_draw(client_x, client_y, do_guides){
	spline = document.getElementById("spline");
	var spline_context = spline.getContext("2d");
	spline_context.font = "16px sans-serif";
	// background
	spline_context.fillStyle="#eeeeee";
	spline_context.fillRect(0, 0, w, h);

	// grid
	draw_grid_on(spline_context);

	// spline1
	var A1 = [];
	var B1 = [];
	for(var i = 0; i < 4; i += 2) {
		A1[i] = [];
		for(var j = 0; j < 4; ++j){
			A1[i][j] = Math.pow(spline_xs[i], j);
		}
		B1[i] = spline_ys[i];

		A1[i+1] = [];
		for(var j = 0; j < 4-1; ++j)
			A1[i+1][j+1] = Math.pow(spline_xs[i], j) * (j+1);
		A1[i+1][0] = 0.0;
		B1[i+1] = (spline_ys[i+1] - spline_ys[i]) / (spline_xs[i+1] - spline_xs[i]);
	}
	X1 = solved_linear(A1, B1, 4);

	// spline2
	var A2 = [];
	var B2 = [];
	for(var i = 0; i < 4; i += 2) {
		A2[i] = [];
		for(var j = 0; j < 4; ++j){
			A2[i][j] = Math.pow(spline_xs[i+2], j);
		}
		B2[i] = spline_ys[i+2];

		A2[i+1] = [];
		for(var j = 0; j < 4-1; ++j)
			A2[i+1][j+1] = Math.pow(spline_xs[i+2], j) * (j+1);
		A2[i+1][0] = 0.0;
		B2[i+1] = (spline_ys[i+1+2] - spline_ys[i+2]) / (spline_xs[i+1+2] - spline_xs[i+2]);
	}
	X2 = solved_linear(A2, B2, 4);

	spline_context.beginPath();
	spline_context.lineWidth = 2;
	spline_context.strokeStyle="#d64562";
	var first_point = true;
	for(var j = 1; j < w; ++j){
		var x = client_to_x(j);
		var y = 0.0;
		if(x > spline_xs[0] && x < spline_xs[2]){
			y = polynomial_in_x(X1, x, 4);
			if(first_point) {
				spline_context.moveTo(x_to_client(x), y_to_client(y));
				first_point = false;
			} else {
				spline_context.lineTo(x_to_client(x), y_to_client(y));
			}
		}
		if(x > spline_xs[2] && x < spline_xs[4]){
			y = polynomial_in_x(X2, x, 4);
			if(first_point) {
				spline_context.moveTo(x_to_client(x), y_to_client(y));
				first_point = false;
			} else {
				spline_context.lineTo(x_to_client(x), y_to_client(y));
			}
		}
	}
	spline_context.stroke();
	spline_context.closePath();
	spline_context.lineWidth = 1;

	// dots
	spline_context.fillStyle="#d64562";
	spline_context.strokeStyle="#d64562";
	for(var i = 0; i < spline_xs.length; ++i){
		const xi = x_to_client(spline_xs[i]) + 0.5;
		const yi = y_to_client(spline_ys[i]) + 0.5;
		spline_context.beginPath();
		spline_context.arc(xi, yi, 4, 0, 2*Math.PI);
		spline_context.stroke();
		spline_context.fill();
		spline_context.closePath();
	}


	spline_context.beginPath();
	spline_context.setLineDash([4, 4]);
	for(var i = 0; i < spline_n/2; ++i){
		spline_context.moveTo(x_to_client(spline_xs[2*i]), y_to_client(spline_ys[2*i]));
		spline_context.lineTo(x_to_client(spline_xs[2*i+1]), y_to_client(spline_ys[2*i+1]));
	}
	spline_context.strokeStyle="#d64562";
	spline_context.stroke();
	spline_context.setLineDash([]);
	spline_context.closePath();

	// guides
	if(do_guides){
		min_d = Math.pow(spline_xs[0] - client_to_x(client_x), 2) + Math.pow(spline_ys[0] - client_to_y(client_y), 2);
		min_i = 0;
		for(var i = 1; i < spline_n; ++i){
			var di = Math.pow(spline_xs[i] - client_to_x(client_x), 2) + Math.pow(spline_ys[i] - client_to_y(client_y), 2);
			if(di < min_d){
				min_d = di;
				min_i = i;
			}
		}
		spline_i = min_i;
		spline_context.setLineDash([4, 4]);
		spline_context.beginPath();
		spline_context.moveTo(x_to_client(spline_xs[min_i]), y_to_client(spline_ys[min_i]));
		spline_context.lineTo(client_x, client_y);
		spline_context.strokeStyle="#d64562";
		spline_context.stroke();
		spline_context.closePath();
		spline_context.setLineDash([]);
	}
}

function show(n){
	document.getElementById("shown_" + n).style.display = "none";
	document.getElementById("hidden_" + n).style.display = "inline";
}

function hide(n){
	document.getElementById("shown_" + n).style.display = "inline";
	document.getElementById("hidden_" + n).style.display = "none";
}

	</script>
</head>
<body>
	<center>
	<h1>
Programmer's guide to polynomials and splines
	</h1>
	<p>
<a href="https://wordsandbuttons.online/mathematical_analysis_explained_with_python_blood_and_tnt.html">Mathematical analysis explained with Python, blood, and TNT</a> shows how you can analyze and synthesize arbitrary functions as polynomials. But you can synthesize polynomials from different inputs, too. You can put a spline through some points, make it sharp at one point and smooth at another, or make it flat near some point and explicitly curvy near another. Polynomials are your digital clay.
	</p>
	<p>
Polynomials or even polynomial splines might not always be the best tool for the job, but they possess some traits that programmers value. They are inherently simple, versatile, and, most noticeably, highly effective in terms of performance.
	</p>
	<p>
Let's say we have a <span id="index_polynomial">polynomial</span> written like this:
	</p>
	<p class="formula">
P(x) = ax<sup>3</sup> + bx<sup>2</sup> + cx + d
	</p>
	<p>
This polynomial is defined for every <i>x</i>, it has a local minimum, a local maximum, and it covers all the numbers with its image too. It only takes 6 multiplications and 3 additions to calculate, and you can already describe non-trivial things with it. But even this can be reduced by using Horner's method. The same polynomial may be written as:
	</p>
	<p class="formula">
P(x) = ((ax+ b)x + c)x + d
	</p>
	<p>
And now it's only 3 multiplications and 3 additions. See, we barely started, and you already learned how to speed things up.
	</p>

	<h2>
Polynomial interpolation
	</h2>
	<p>
Fitting an <i>n-</i>degree polynomial in exactly <i>n+1</i> points is called polynomial interpolation. There are several ways to do that. You can use <a href="https://en.wikipedia.org/wiki/Newton_polynomial">Newton polynomials</a> or <a href="https://en.wikipedia.org/wiki/Lagrange_polynomial">Lagrange polynomials</a>. But the very basic way you can get an interpolating polynomial is by solving <a href="https://en.wikipedia.org/wiki/Vandermonde_matrix">a linear system</a>.
	</p>
	<p>
If a polynomial <i>P(x)</i> goes through the point <i>(x<sub>i</sub>, y<sub>i</sub>)</i> then, obviously enough, we can claim that <i>P(x<sub>i</sub>) = y<sub>i</sub></i>. Say we want to fit a polynomial into a set of three points. This means that:
	</p>
	<p class="formula">
P(x<sub>1</sub>) = y<sub>1</sub>
<br>
P(x<sub>2</sub>) = y<sub>2</sub>
<br>
P(x<sub>3</sub>) = y<sub>3</sub>
	</p>
	<p>
Generally, we can not fit a straight line into three arbitrary points. We would have to bend it forming a parabola. Or, put in other words, 2-nd degree polynomial also known as quadric.
	</p>
	<p class="formula">
P(x<sub>1</sub>) = ax<sub>1</sub><sup>2</sup> + bx<sub>1</sub> + c = y<sub>1</sub>
<br>
P(x<sub>2</sub>) = ax<sub>2</sub><sup>2</sup> + bx<sub>2</sub> + c = y<sub>2</sub>
<br>
P(x<sub>3</sub>) = ax<sub>3</sub><sup>2</sup> + bx<sub>3</sub> + c = y<sub>3</sub>
	</p>
	<p>
Since we know <i>x</i>s and <i>y</i>s, we only have to solve the system for <i>(a, b, c)</i> coefficients and since it's a three-equation system with three variables, it should generally give us one and only one solution.
	</p>
	<p>
Here, try it yourself. This is a canvas with three points on and a parabola that runs through them. You can drag them around to see what happens.
	</p>
	<canvas id="polynomial" width=640 height=512></canvas>
	<table>
	<tr><td rowspan="2">
<b>P(x) = ax<sup>2</sup> + bx + c</b>
	</td><td id="polynomial_system">

	</td>
	</tr><tr><td id="polynomial_formula">

	</td></tr></table>
	<script language="JavaScript">
	init_polynomial();
	</script>

	<p>
This interplation method is also a good mental model for understanding linear systems. Generally, you can't fit a straight line into three points just like you can't find a solution for <i>(n-1)</i> variables for n-equations system. But sometimes you can. It's when some of the points coincide or they all deliberately lie on a straight line.
	</p>
	<p>
And the vise versa, we can fit an infinite number of parabolas into a set of only two points. We just can't choose between them, that's why we can't unambiguously solve an n-equations system for <i>(n+1)</i> variables although there is an infinite number of solutions that fit.
	</p>
	<p>
But if the problem is in choosing the right function, maybe we can add some additional criteria to make the choise unambiguous?
	</p>

	<h2>
Synthesis
	</h2>
	<p>
And this brings us to polynomial synthesis. It is a crossover between the polynomial series and polynomial interpolation. With polynomial series, we can model a function based on its derivatives at some point, and with synthesis, we can use both points and derivatives. And even more than that actually, but that's a whole different story.
	</p>
	<p>
Function's derivative is closely related to the geometric properties of its plot. The first derivative sets a tangent, and the second one sets a curvature.
	</p>
	<p>
Let than say we want a function that goes through a pair of points and has a specific tangent in both points. We can easily synthesize this function as a polynomial.
	</p>
	<p>
Just like before, we should prepare a system of equations. Now we want four conditions, so we should pick a 3-rd degree polynomial — a <span id="index_cubic_polynomial">cubic polynomial</span>.
	</p>
	<p class="formula">
P(x<sub>1</sub>)' = 3ax<sub>1</sub><sup>2</sup> + 2bx<sub>1</sub> + c = dy<sub>1</sub>/dx
<br>
P(x<sub>1</sub>) = ax<sub>1</sub><sup>3</sup> + bx<sub>1</sub><sup>2</sup> + cx<sub>1</sub> + d = y<sub>1</sub>
<br>
P(x<sub>2</sub>) = ax<sub>2</sub><sup>3</sup> + bx<sub>2</sub><sup>2</sup> + cx<sub>2</sub> + d = y<sub>2</sub>
<br>
P(x<sub>2</sub>)' = 3ax<sub>2</sub><sup>2</sup> + 2bx<sub>2</sub> + c = dy<sub>2</sub>/dx
	</p>
	<p>
You see, some of the equations are formed from points and some from derivatives. You can even add integrals into the mix if you want to constraint some integral properties. This is a rather powerful technique.
	</p>
	<p>
Our four equations form a smooth continuous function between two points with <span id="index_tangential_constraints">tangential constraints</span> at these points.
	</p>
	<canvas id="synthesis" width=640 height=512></canvas>
	<table>
	<tr><td rowspan="2">
<b>P(x) = ax<sup>3</sup> + bx<sup>2</sup> + cx + d</b>
	</td><td id="synthesis_system">

	</td>
	</tr><tr><td id="synthesis_formula">

	</td></tr></table>
	<script language="JavaScript">
	init_synthesis();
	</script>
	<p>
Now you have a nice obedient function between two points. But what if you have to fit a polynomial into many more points?
	</p>

	<h2>
<Span id="index_runge_s_phenomenon">Runge's phenomenon</Span>
	</h2>
	<p>
One unpleasant property of polynomial interpolation is that the function tends to oscillate at both ends of the interval more and more with adding more points. This is called <a href="https://en.wikipedia.org/wiki/Runge%27s_phenomenon">Runge's phenomenon</a>.
	</p>
	<p>
The other thing is that the interpolating polynomials are global, meaning that touching a single point causes the whole function to change. Now combine this with the oscillations, and you have yourself a recipe for chaos.
	</p>

	<canvas id="runge" width=640 height=512></canvas>
	<script language="JavaScript">
	init_runge();
	</script>

	<h2>
<Span id="index_chebyshev_nodes">Chebyshev nodes</Span>
	</h2>
	<p>
One way to mitigate this chaos would be to select a special grid for an interpolation: <a href="https://en.wikipedia.org/wiki/Chebyshev_nodes">Chebyshev nodes</a>. These are specially calculated <i>x</i> values that represent a projection of equidistant intervals from a semicircle with radius 1 onto the x-axis.
	</p>
	<p>
There is some mathematical magic behind this; pragmatically this disposition minimizes the Runge's phenomenon. In the range <i>(-1; 1)</i> the interpolation now works more or less predictable.
	</p>

	<canvas id="chebyshev" width=640 height=512></canvas>
	<script language="JavaScript">
	init_chebyshev();
	</script>

	<p>
Of course, you can translate this range to any other range on x-axis. It doesn't have to be always <i>(-1; 1)</i>.
	</p>
	<p>
But the interpolation is still global. The change in the first point still affects the function near the last one, although not so drastically.
	</p>

	<h2>
<span id="index_spline">Spline</span>s
	</h2>
	<p>
There are quite a lot of different types of splines, but they all share the common motivation. When, for some reason, global interpolation doesn't work for us, we can divide our domain into pieces, and we can then define separate interpolating functions for each of them. We only have to make sure they conjoin in their ends so the function appears continuous. If we guarantee continuity not only for our resulting piecewise function but for its first derivative as well, then the tangents of every piece would match, and the function will become smooth, too.
	</p>
	<p>
There is a definite classification for <a href="https://en.wikipedia.org/wiki/Spline_(mathematics)#Representations_and_Names">the types of splines</a>. For instance, here is a 2-piece polynomial spline. It is <b>cubic</b>, meaning that the polynomial in every piece is of the third degree. It has <b>1-st derivative continuity</b> since we make the pieces conjoint along with their tangents. It is <b>non-uniform</b> since the length of the pieces' intervals is variable. It is <b>not natural</b> since you can rule the derivatives at the end. And it is, of course, an <b>interpolating</b> spline since it goes exactly through the grid points we set up.
	</p>
	<canvas id="spline" width=640 height=512></canvas>
	<script language="JavaScript">
	init_spline();
	</script>

	<h2>
Conclusion
	</h2>
	<p>
It is highly unlikely that you would ever have to implement your own interpolation. There are a lot of ready-made solutions out there, most of the time you would only have to pick the right tool for the job. It's not that hard, but the amount of unknown words and names like Runge or Chebyshev&hairsp;<span id="shown_sidenote_1" onclick="show('sidenote_1')"><u>*</u></span><span id="hidden_sidenote_1" style="display:none; color:#555555;"> (fun fact, Chebyshev's real name is <a href="https://en.wikipedia.org/wiki/Pafnuty_Chebyshev">Chebyshóv</a>. The confusion comes from that weird Russian letter &laquo;ё&raquo; that, unlike in other languages, doesn't preserve the sound “e” but rather <a href="https://en.wikipedia.org/wiki/Yo_(Cyrillic)#Pronunciation">changes it to “o” and softens the previous consonant</a>. Russians don't like this letter very much themselves and tend to omit it when possible. But they substitute it with &laquo;е&raquo; not &laquo;о&raquo; thus breeding confusion)<span onclick="hide('sidenote_1')"><u>&larr;</u></span></span> may be overwhelming.
	</p>
	<p>
The purpose of this guide is to provide a very basic understanding of polynomials and splines. It is not at all comprehensive, in fact, there are whole books being written on every small piece of this guide. I hope, however, that it gives enough introduction to practicing programmers so they could choose the best solution for a problem without reading all those books.
	</p>

	<table class="footer" style="width: 555pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
	<tr>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
		<a href="index.html"><img src="favicon.svg"></a>
	</td>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
		&nbsp;&larr; there's more.
	</td>
	<td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
		+
		<a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &
		<a href="https://wordsandbuttons.online/rss"><span style="letter-spacing: 1pt;">RSS</span></a>
	</td>
	</tr>
	</table>
	</center>
</body>
</html>
