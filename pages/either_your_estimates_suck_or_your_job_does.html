<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Either your estimates suck or your job does</title>
	<meta name="description" content="This page uses polynomial modeling to show why software engineering tasks are often impossible to estimate.">
	<meta name="keywords" content="mathematics, programming">
	<link rel="shortcut icon" type="image/x-icon" href="favicon.svg" />
	<style>
body {
	margin: 12pt;
}

a {
	text-decoration: none;
}

a:link, a:visited {
	color: blue;
}

h1 {
	padding-top: 36pt;
	font-size: 24pt;
	width: 600pt;
	text-align: left;
}

h2 {
	padding-top: 20pt;
	font-size: 20pt;
	width: 600pt;
	text-align: left;
}

p {
	line-height: 1.42;
	font-size: 16pt;
	width: 600pt;
	text-align: left;
}

.comment {
	font-size: 12pt;
	text-align:center;
	font-family: sans-serif;
	padding-bottom: 24pt;
}

table.footer {
	padding: 64pt 0pt 32pt 0pt;
	background-color: transparent;
	width: 600pt;
}

td.footer {
	font-family: sans-serif;
	font-size: 16pt;
	font-style: normal;
	padding: 0;
	margin: 0;
	border: 0;
}

table {
	font-family: sans-serif;
	font-size: 13pt;
	font-style: italic;
	width: 600pt;
	text-align: center;
}

td {
	vertical-align: text-top;
	padding-top: 6pt;
	padding-bottom: 6pt;
}

li {
	font-size: 16pt;
	width: 600pt;
	text-align: left;
	padding-bottom: 6pt;
}

form {
	margin: 0 0 0 0;
	padding-top: 12pt;
	padding-left: 12pt;
	padding-right: 12pt;
	padding-bottom: 12pt;
	font-size: 16pt;
	text-align: left;
	width: 600pt;
	background-color: #eeee99;
	color: #000;
}

input[type="text"] {
	width: 100pt;
	height: 22pt;
	margin: 8pt 8pt 8pt 8pt;
	padding-left: 3pt;
	font-size: 16pt;
}

button {
	width: 108pt;
	height: 28pt;
	margin-left:4pt;
	margin-right:4pt;
	font-size: 16pt;
}

i {
	font-family: sans-serif;
	font-size: 15pt;
	font-style: italic;
}

u {
	border-bottom: 1px dotted #000;
	text-decoration: none;
	cursor: pointer;
}

canvas { touch-action: none; }
	</style>
	<script language="JavaScript">

// client
var w = 640.0;
var h = 640.0;

// visible region
var x_min = -1.0;
var y_min = -1.0;
var x_max = 9.0;
var y_max = 9.0;

var client_x_center = w*(0-x_min)/(x_max-x_min);
var client_x_step = (w/(x_max-x_min));

var client_y_center = h - h*(0-y_min)/(y_max-y_min);
var client_y_step = (h/(y_max-y_min));

function client_to_x(client_x){
	return (client_x - client_x_center) / client_x_step;
}

function client_to_y(client_y){
	return (client_y_center - client_y) / client_y_step;
}

function x_to_client(x){
	return x * client_x_step + client_x_center;
}

function y_to_client(y){
	return client_y_center - y * client_y_step;
}

function sign_0_positive(x){ // Math.sign like with no 0 option
	if(x >= 0)
		return 1.0;
	return -1.0;
}

function underflow_padded(x){
	if(Math.abs(x) < 1.e-5) // pixel-size input error is ok, so we don't want much precision anyway
		return 1.e-5 * sign_0_positive(x);
	return x;
}

function solved_linear(A, B, n){
	var X = [];
	for (var i = 0; i < n; ++i)
		X[i] = 0.0;

	// triangulize
	for (var i = 0; i < n-1; ++i)
		for (var j = 0; j < i+1; ++j) {
			r = A[i+1][j] / underflow_padded(A[j][j]);
			A[i+1][j] = 0.;
			for (var b_j = j+1; b_j < n; ++b_j){
				A[i+1][b_j] -= A[j][b_j]*r;
			}
			B[i+1] -= B[j]*r;
		}

	// calculate xs
	X[n-1] = B[n-1] / underflow_padded(A[n-1][n-1]);
	for (var i = n-2; i >= 0; --i){
		var s = 0.0;
		for (var j = i; j < n; ++j){
			s = s + A[i][j]*X[j];
		}
		X[i] = (B[i] - s) / underflow_padded(A[i][i]);
	}
	return X;
}

function polynomial_in_x(A, x, n){
	var y = 0.0;
	for(var i = 0; i < n; ++i){
		y += A[i] * Math.pow(x, i);
	}
	return y;
}

function draw_grid_on(context){
	// grid
	context.beginPath();
	for(var i = x_min + 1; i <= x_max - 1; i++){
		if(i != 0) {
			context.moveTo(client_x_center + i*client_x_step + 0.5, 0);
			context.lineTo(client_x_center + i*client_x_step + 0.5, h+1);
		}
	}
	for(var i = y_min + 1; i <= y_max - 1; i++){
		if(i != 0) {
			context.moveTo(0, client_y_center - i*client_y_step + 0.5);
			context.lineTo(w+1, client_y_center - i*client_y_step + 0.5);
		}
	}
	context.strokeStyle="#B8B8B8";
	context.stroke();
	context.closePath();

	context.beginPath();
	context.moveTo(0, client_y_center + 0.5);
	context.lineTo(w, client_y_center + 0.5);
	context.lineTo(w - 12, client_y_center - 5 + 0.5);
	context.moveTo(w, client_y_center + 0.5);
	context.lineTo(w - 12, client_y_center + 5 + 0.5);
	context.moveTo(client_x_center + 0.5, h);
	context.lineTo(client_x_center + 0.5, 0);
	context.lineTo(client_x_center - 5 + 0.5, 12);
	context.moveTo(client_x_center + 0.5, 0);
	context.lineTo(client_x_center + 5 + 0.5, 12);
	context.fillStyle="#000000";
	for(var i = x_min + 1; i <= x_max - 1; i++){
		if(i != 0) {
			context.moveTo(client_x_center + i*client_x_step + 0.5, client_y_center);
			context.lineTo(client_x_center + i*client_x_step + 0.5, client_y_center - 5);
			context.fillText(i, client_x_center + i*client_x_step + 4, client_y_center + 16);
		}
	}
	for(var i = y_min + 1; i <= y_max - 1; i++){
		if(i != 0) {
			context.moveTo(client_x_center, client_y_center - i*client_y_step + 0.5);
			context.lineTo(client_x_center + 5, client_y_center - i*client_y_step + 0.5);
		}
		context.fillText(i, client_x_center + 5, client_y_center - i*client_y_step + 16);
	}
	context.fillText("time (hours)", 544, 564);
	context.fillText("length (meters)", 76, 24);
	context.strokeStyle="#000000";
	context.stroke();
	context.closePath();
}

// polynomial2
var polynomial2_xs = [0.0, 1.0];
var polynomial2_ys = [0.0, 1.0];
var polynomial2_n = 2;
var polynomial2_i = 0;

function init_polynomial2(){
	polynomial = document.getElementById("polynomial2");
	var canvas_rect = polynomial.getBoundingClientRect();
	polynomial2_draw(0, 0, false);

	polynomial.addEventListener('pointermove', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		polynomial2_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		if(e.buttons == 1){
			polynomial2_xs[polynomial2_i] = client_to_x(e.clientX - canvas_rect.left);
			polynomial2_ys[polynomial2_i] = client_to_y(e.clientY - canvas_rect.top);
			polynomial2_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
		}
	}, false);

	polynomial.addEventListener('pointerdown', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		polynomial2_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		polynomial2_xs[polynomial2_i] = client_to_x(e.clientX - canvas_rect.left);
		polynomial2_ys[polynomial2_i] = client_to_y(e.clientY - canvas_rect.top);
		polynomial2_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
		polynomial.releasePointerCapture(e.pointerId);
	}, false);

	polynomial.addEventListener('pointerleave', function(e){
		polynomial2_draw(0, 0, false);
	}, false);
}

function polynomial2_draw(client_x, client_y, do_guides){
	polynomial = document.getElementById("polynomial2");
	var context = polynomial.getContext("2d");
	context.font = "16px sans-serif";
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	// grid
	draw_grid_on(context);

	// polynomial
	var A = [];
	var B = [];
	for(var i = 0; i < polynomial2_n; ++i){
		A[i] = [];
		for(var j = 0; j < polynomial2_n; ++j){
			A[i][j] = Math.pow(polynomial2_xs[i], j);
		}
		B[i] = polynomial2_ys[i];
	}

	X = solved_linear(A, B, polynomial2_n);

	context.beginPath();
	context.lineWidth = 2;
	context.strokeStyle="#d64562";
	for(var j = 0; j < w; ++j){
		const x = client_to_x(j);
		const y = polynomial_in_x(X, x, polynomial2_n);
		if(j == 0) {
			context.moveTo(x_to_client(x), y_to_client(y));
		} else {
			context.lineTo(x_to_client(x), y_to_client(y));
		}
	}
	context.stroke();
	context.closePath();
	context.lineWidth = 1;

	// dots
	context.fillStyle="#d64562";
	for(var i = 0; i < polynomial2_n; ++i){
		const xi = x_to_client(polynomial2_xs[i]) + 0.5;
		const yi = y_to_client(polynomial2_ys[i]) + 0.5;
		context.beginPath();
		context.arc(xi, yi, 4, 0, 2*Math.PI);
		context.stroke();
		context.fill();
		context.closePath();
	}

	// guides
	if(do_guides){
		min_d = Math.pow(polynomial2_xs[0] - client_to_x(client_x), 2) + Math.pow(polynomial2_ys[0] - client_to_y(client_y), 2);
		min_i = 0;
		for(var i = 1; i < polynomial2_n; ++i){
			var di = Math.pow(polynomial2_xs[i] - client_to_x(client_x), 2) + Math.pow(polynomial2_ys[i] - client_to_y(client_y), 2);
			if(di < min_d){
				min_d = di;
				min_i = i;
			}
		}
		polynomial2_i = min_i;
		context.setLineDash([4, 4]);
		context.beginPath();
		context.moveTo(x_to_client(polynomial2_xs[min_i]), y_to_client(polynomial2_ys[min_i]));
		context.lineTo(client_x, client_y);
		context.strokeStyle="#d64562";
		context.stroke();
		context.closePath();
		context.setLineDash([]);
	}
}

// polynomial3
var polynomial3_xs = [0.0, 1.0, 4.0];
var polynomial3_ys = [0.0, 1.0, 3.0];
var polynomial3_n = 3;
var polynomial3_i = 0;

function init_polynomial3(){
	polynomial = document.getElementById("polynomial3");
	var canvas_rect = polynomial.getBoundingClientRect();
	polynomial3_draw(0, 0, false);

	polynomial.addEventListener('pointermove', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		polynomial3_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		if(e.buttons == 1){
			polynomial3_xs[polynomial3_i] = client_to_x(e.clientX - canvas_rect.left);
			polynomial3_ys[polynomial3_i] = client_to_y(e.clientY - canvas_rect.top);
			polynomial3_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
		}
	}, false);

	polynomial.addEventListener('pointerdown', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		polynomial3_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		polynomial3_xs[polynomial3_i] = client_to_x(e.clientX - canvas_rect.left);
		polynomial3_ys[polynomial3_i] = client_to_y(e.clientY - canvas_rect.top);
		polynomial3_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
		polynomial.releasePointerCapture(e.pointerId);
	}, false);

	polynomial.addEventListener('pointerleave', function(e){
		polynomial3_draw(0, 0, false);
	}, false);
}

function polynomial3_draw(client_x, client_y, do_guides){
	polynomial = document.getElementById("polynomial3");
	var context = polynomial.getContext("2d");
	context.font = "16px sans-serif";
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	// grid
	draw_grid_on(context);

	// polynomial
	var A = [];
	var B = [];
	for(var i = 0; i < polynomial3_n; ++i){
		A[i] = [];
		for(var j = 0; j < polynomial3_n; ++j){
			A[i][j] = Math.pow(polynomial3_xs[i], j);
		}
		B[i] = polynomial3_ys[i];
	}

	X = solved_linear(A, B, polynomial3_n);

	context.beginPath();
	context.lineWidth = 2;
	context.strokeStyle="#d64562";
	for(var j = 0; j < w; ++j){
		const x = client_to_x(j);
		const y = polynomial_in_x(X, x, polynomial3_n);
		if(j == 0) {
			context.moveTo(x_to_client(x), y_to_client(y));
		} else {
			context.lineTo(x_to_client(x), y_to_client(y));
		}
	}
	context.stroke();
	context.closePath();
	context.lineWidth = 1;

	// dots
	context.fillStyle="#d64562";
	for(var i = 0; i < polynomial3_n; ++i){
		const xi = x_to_client(polynomial3_xs[i]) + 0.5;
		const yi = y_to_client(polynomial3_ys[i]) + 0.5;
		context.beginPath();
		context.arc(xi, yi, 4, 0, 2*Math.PI);
		context.stroke();
		context.fill();
		context.closePath();
	}

	// guides
	if(do_guides){
		min_d = Math.pow(polynomial3_xs[0] - client_to_x(client_x), 2) + Math.pow(polynomial3_ys[0] - client_to_y(client_y), 2);
		min_i = 0;
		for(var i = 1; i < polynomial3_n; ++i){
			var di = Math.pow(polynomial3_xs[i] - client_to_x(client_x), 2) + Math.pow(polynomial3_ys[i] - client_to_y(client_y), 2);
			if(di < min_d){
				min_d = di;
				min_i = i;
			}
		}
		polynomial3_i = min_i;
		context.setLineDash([4, 4]);
		context.beginPath();
		context.moveTo(x_to_client(polynomial3_xs[min_i]), y_to_client(polynomial3_ys[min_i]));
		context.lineTo(client_x, client_y);
		context.strokeStyle="#d64562";
		context.stroke();
		context.closePath();
		context.setLineDash([]);
	}
}

// polynomial4
var polynomial4_xs = [0.0, 1.0, 4.0, 3.0];
var polynomial4_ys = [0.0, 1.0, 3.0, 2.48];
var polynomial4_n = 4;
var polynomial4_i = 0;

function init_polynomial4(){
	polynomial = document.getElementById("polynomial4");
	var canvas_rect = polynomial.getBoundingClientRect();
	polynomial4_draw(0, 0, false);

	polynomial.addEventListener('pointermove', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		polynomial4_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		if(e.buttons == 1){
			polynomial4_xs[polynomial4_i] = client_to_x(e.clientX - canvas_rect.left);
			polynomial4_ys[polynomial4_i] = client_to_y(e.clientY - canvas_rect.top);
			polynomial4_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
		}
	}, false);

	polynomial.addEventListener('pointerdown', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		polynomial4_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		polynomial4_xs[polynomial4_i] = client_to_x(e.clientX - canvas_rect.left);
		polynomial4_ys[polynomial4_i] = client_to_y(e.clientY - canvas_rect.top);
		polynomial4_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
		polynomial.releasePointerCapture(e.pointerId);
	}, false);

	polynomial.addEventListener('pointerleave', function(e){
		polynomial4_draw(0, 0, false);
	}, false);
}

function polynomial4_draw(client_x, client_y, do_guides){
	polynomial = document.getElementById("polynomial4");
	var context = polynomial.getContext("2d");
	context.font = "16px sans-serif";
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	// grid
	draw_grid_on(context);

	// polynomial
	var A = [];
	var B = [];
	for(var i = 0; i < polynomial4_n; ++i){
		A[i] = [];
		for(var j = 0; j < polynomial4_n; ++j){
			A[i][j] = Math.pow(polynomial4_xs[i], j);
		}
		B[i] = polynomial4_ys[i];
	}

	X = solved_linear(A, B, polynomial4_n);

	context.beginPath();
	context.lineWidth = 2;
	context.strokeStyle="#d64562";
	for(var j = 0; j < w; ++j){
		const x = client_to_x(j);
		const y = polynomial_in_x(X, x, polynomial4_n);
		if(j == 0) {
			context.moveTo(x_to_client(x), y_to_client(y));
		} else {
			context.lineTo(x_to_client(x), y_to_client(y));
		}
	}
	context.stroke();
	context.closePath();
	context.lineWidth = 1;

	// dots
	context.fillStyle="#d64562";
	for(var i = 0; i < polynomial4_n; ++i){
		const xi = x_to_client(polynomial4_xs[i]) + 0.5;
		const yi = y_to_client(polynomial4_ys[i]) + 0.5;
		context.beginPath();
		context.arc(xi, yi, 4, 0, 2*Math.PI);
		context.stroke();
		context.fill();
		context.closePath();
	}

	// guides
	if(do_guides){
		min_d = Math.pow(polynomial4_xs[0] - client_to_x(client_x), 2) + Math.pow(polynomial4_ys[0] - client_to_y(client_y), 2);
		min_i = 0;
		for(var i = 1; i < polynomial4_n; ++i){
			var di = Math.pow(polynomial4_xs[i] - client_to_x(client_x), 2) + Math.pow(polynomial4_ys[i] - client_to_y(client_y), 2);
			if(di < min_d){
				min_d = di;
				min_i = i;
			}
		}
		polynomial4_i = min_i;
		context.setLineDash([4, 4]);
		context.beginPath();
		context.moveTo(x_to_client(polynomial4_xs[min_i]), y_to_client(polynomial4_ys[min_i]));
		context.lineTo(client_x, client_y);
		context.strokeStyle="#d64562";
		context.stroke();
		context.closePath();
		context.setLineDash([]);
	}
}

// factor1
function punkt(context, x, y, color) {
	context.fillStyle=color;
	context.beginPath();
	context.arc(x, y, 32, 0, 2*Math.PI);
	context.stroke();
	context.fill();
	context.closePath();
}

function factor1_draw(client_x, client_y, do_guides){
	polynomial = document.getElementById("factor1");
	var context = polynomial.getContext("2d");
	context.font = "16px sans-serif";
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	punkt(context, 160, 320, "#d64562");
	punkt(context, 320, 320, "#d64562");
	punkt(context, 480, 320, "#d64562");
}

// factor2
function factor2_draw(client_x, client_y, do_guides){
	polynomial = document.getElementById("factor2");
	var context = polynomial.getContext("2d");
	context.font = "16px sans-serif";
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	punkt(context, 160, 200, "#d64562");
	punkt(context, 320, 200, "#d64562");
	punkt(context, 480, 200, "#d64562");
	punkt(context, 160, 440, "#ABD645");
	punkt(context, 320, 440, "#ABD645");
	punkt(context, 480, 440, "#ABD645");
}

// factor3
function factor3_draw(client_x, client_y, do_guides){
	polynomial = document.getElementById("factor3");
	var context = polynomial.getContext("2d");
	context.font = "16px sans-serif";
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	punkt(context,  80, 200, "#d64562");
	punkt(context, 160, 200, "#d64562");
	punkt(context, 240, 200, "#d64562");
	punkt(context,  80, 440, "#ABD645");
	punkt(context, 160, 440, "#ABD645");
	punkt(context, 240, 440, "#ABD645");

	punkt(context, 320+ 80, 200, "#45D6B9");
	punkt(context, 320+160, 200, "#45D6B9");
	punkt(context, 320+240, 200, "#45D6B9");
	punkt(context, 320+ 80, 440, "#7045D6");
	punkt(context, 320+160, 440, "#7045D6");
	punkt(context, 320+240, 440, "#7045D6");
}

// factor3
function factor4_draw(client_x, client_y, do_guides){
	polynomial = document.getElementById("factor4");
	var context = polynomial.getContext("2d");
	context.font = "16px sans-serif";
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	punkt(context,  80, 100, "#d64562");
	punkt(context, 160, 100, "#d64562");
	punkt(context, 240, 100, "#d64562");
	punkt(context,  80, 220, "#ABD645");
	punkt(context, 160, 220, "#ABD645");
	punkt(context, 240, 220, "#ABD645");

	punkt(context, 320+ 80, 100, "#45D6B9");
	punkt(context, 320+160, 100, "#45D6B9");
	punkt(context, 320+240, 100, "#45D6B9");
	punkt(context, 320+ 80, 220, "#7045D6");
	punkt(context, 320+160, 220, "#7045D6");
	punkt(context, 320+240, 220, "#7045D6");

	punkt(context,  80, 320+100, "#CC7133");
	punkt(context, 160, 320+100, "#CC7133");
	punkt(context, 240, 320+100, "#CC7133");
	punkt(context,  80, 320+220, "#42CC33");
	punkt(context, 160, 320+220, "#42CC33");
	punkt(context, 240, 320+220, "#42CC33");

	punkt(context, 320+ 80, 320+100, "#338ECC");
	punkt(context, 320+160, 320+100, "#338ECC");
	punkt(context, 320+240, 320+100, "#338ECC");
	punkt(context, 320+ 80, 320+220, "#BD33CC");
	punkt(context, 320+160, 320+220, "#BD33CC");
	punkt(context, 320+240, 320+220, "#BD33CC");
}

// uncertain2
var uncertain2_xs = [0.0, 1.0];
var uncertain2_ys = [0.0, 1.0];
var uncertain2_ds = [1e-5, 0.1];
var uncertain2_n = 2;
var uncertain2_i = 0;

function init_uncertain2(){
	polynomial = document.getElementById("uncertain2");
	var canvas_rect = polynomial.getBoundingClientRect();
	uncertain2_draw(0, 0, false);

	polynomial.addEventListener('pointermove', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		uncertain2_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		if(e.buttons == 1){
			uncertain2_xs[uncertain2_i] = client_to_x(e.clientX - canvas_rect.left);
			uncertain2_ys[uncertain2_i] = client_to_y(e.clientY - canvas_rect.top);
			uncertain2_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
		}
	}, false);

	polynomial.addEventListener('pointerdown', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		uncertain2_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		uncertain2_xs[uncertain2_i] = client_to_x(e.clientX - canvas_rect.left);
		uncertain2_ys[uncertain2_i] = client_to_y(e.clientY - canvas_rect.top);
		uncertain2_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
		polynomial.releasePointerCapture(e.pointerId);
	}, false);

	polynomial.addEventListener('pointerleave', function(e){
		uncertain2_draw(0, 0, false);
	}, false);
}

function uncertain2_draw(client_x, client_y, do_guides){
	polynomial = document.getElementById("uncertain2");
	var context = polynomial.getContext("2d");
	context.font = "16px sans-serif";
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	// grid
	draw_grid_on(context);



	// uncertain polynomials
	for(var d1 = -uncertain2_ds[0]; d1 <= uncertain2_ds[0]; d1 += uncertain2_ds[0]) {
		for(var d2 = -uncertain2_ds[1]; d2 <= uncertain2_ds[1]; d2 += uncertain2_ds[1]) {
			var ds = [d1, d2];
			var A = [];
			var B = [];
			for(var i = 0; i < uncertain2_n; ++i){
				A[i] = [];
				for(var j = 0; j < uncertain2_n; ++j){
					A[i][j] = Math.pow(uncertain2_xs[i], j);
				}
				B[i] = uncertain2_ys[i] + ds[i];
			}
			X = solved_linear(A, B, uncertain2_n);

			context.beginPath();
			context.lineWidth = 1;
			context.strokeStyle="#EDACB9";
			for(var j = 0; j < w; ++j){
				const x = client_to_x(j);
				const y = polynomial_in_x(X, x, uncertain2_n);
				if(j == 0) {
					context.moveTo(x_to_client(x), y_to_client(y));
				} else {
					context.lineTo(x_to_client(x), y_to_client(y));
				}
			}
			context.stroke();
			context.closePath();
			context.lineWidth = 1;
		}
	}

	// the certain polynomial
	var A = [];
	var B = [];
	for(var i = 0; i < uncertain2_n; ++i){
		A[i] = [];
		for(var j = 0; j < uncertain2_n; ++j){
			A[i][j] = Math.pow(uncertain2_xs[i], j);
		}
		B[i] = uncertain2_ys[i];
	}
	X = solved_linear(A, B, uncertain2_n);

	context.beginPath();
	context.lineWidth = 2;
	context.strokeStyle="#d64562";
	for(var j = 0; j < w; ++j){
		const x = client_to_x(j);
		const y = polynomial_in_x(X, x, uncertain2_n);
		if(j == 0) {
			context.moveTo(x_to_client(x), y_to_client(y));
		} else {
			context.lineTo(x_to_client(x), y_to_client(y));
		}
	}
	context.stroke();
	context.closePath();
	context.lineWidth = 1;

	// dots
	context.fillStyle="#d64562";
	for(var i = 0; i < uncertain2_n; ++i){
		const xi = x_to_client(uncertain2_xs[i]) + 0.5;
		const yi = y_to_client(uncertain2_ys[i]) + 0.5;
		context.beginPath();
		context.lineWidth = 1;
		context.arc(xi, yi, 4, 0, 2*Math.PI);
		context.stroke();
		context.fill();
		context.closePath();
		context.beginPath();
		context.lineWidth = 4;
		const x1 = x_to_client(uncertain2_xs[i]) + 0.5;
		const y1 = y_to_client(uncertain2_ys[i] - uncertain2_ds[i]) + 0.5;
		const x2 = x_to_client(uncertain2_xs[i]) + 0.5;
		const y2 = y_to_client(uncertain2_ys[i] + uncertain2_ds[i]) + 0.5;
		context.moveTo(x1, y1);
		context.lineTo(x2, y2);
		context.stroke();
		context.lineWidth = 1;
		context.closePath();
	}

	// guides
	if(do_guides){
		min_d = Math.pow(uncertain2_xs[0] - client_to_x(client_x), 2) + Math.pow(uncertain2_ys[0] - client_to_y(client_y), 2);
		min_i = 0;
		for(var i = 1; i < uncertain2_n; ++i){
			var di = Math.pow(uncertain2_xs[i] - client_to_x(client_x), 2) + Math.pow(uncertain2_ys[i] - client_to_y(client_y), 2);
			if(di < min_d){
				min_d = di;
				min_i = i;
			}
		}
		uncertain2_i = min_i;
		context.setLineDash([4, 4]);
		context.beginPath();
		context.moveTo(x_to_client(uncertain2_xs[min_i]), y_to_client(uncertain2_ys[min_i]));
		context.lineTo(client_x, client_y);
		context.strokeStyle="#d64562";
		context.stroke();
		context.closePath();
		context.setLineDash([]);
	}
}

// uncertain3
var uncertain3_xs = [0.0, 1.0, 4.0];
var uncertain3_ys = [0.0, 1.0, 3.0];
var uncertain3_ds = [1e-5, 0.1, 0.1];
var uncertain3_n = 3;
var uncertain3_i = 0;

function init_uncertain3(){
	polynomial = document.getElementById("uncertain3");
	var canvas_rect = polynomial.getBoundingClientRect();
	uncertain3_draw(0, 0, false);

	polynomial.addEventListener('pointermove', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		uncertain3_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		if(e.buttons == 1){
			uncertain3_xs[uncertain3_i] = client_to_x(e.clientX - canvas_rect.left);
			uncertain3_ys[uncertain3_i] = client_to_y(e.clientY - canvas_rect.top);
			uncertain3_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
		}
	}, false);

	polynomial.addEventListener('pointerdown', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		uncertain3_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		uncertain3_xs[uncertain3_i] = client_to_x(e.clientX - canvas_rect.left);
		uncertain3_ys[uncertain3_i] = client_to_y(e.clientY - canvas_rect.top);
		uncertain3_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
		polynomial.releasePointerCapture(e.pointerId);
	}, false);

	polynomial.addEventListener('pointerleave', function(e){
		uncertain3_draw(0, 0, false);
	}, false);
}

function uncertain3_draw(client_x, client_y, do_guides){
	polynomial = document.getElementById("uncertain3");
	var context = polynomial.getContext("2d");
	context.font = "16px sans-serif";
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	// grid
	draw_grid_on(context);



	// uncertain polynomials
	for(var d1 = -uncertain3_ds[0]; d1 <= uncertain3_ds[0]; d1 += uncertain3_ds[0]) {
		for(var d2 = -uncertain3_ds[1]; d2 <= uncertain3_ds[1]; d2 += uncertain3_ds[1]) {
			for(var d3 = -uncertain3_ds[2]; d3 <= uncertain3_ds[2]; d3 += uncertain3_ds[2]) {
				var ds = [d1, d2, d3];
				var A = [];
				var B = [];
				for(var i = 0; i < uncertain3_n; ++i){
					A[i] = [];
					for(var j = 0; j < uncertain3_n; ++j){
						A[i][j] = Math.pow(uncertain3_xs[i], j);
					}
					B[i] = uncertain3_ys[i] + ds[i];
				}
				X = solved_linear(A, B, uncertain3_n);

				context.beginPath();
				context.lineWidth = 1;
				context.strokeStyle="#EDACB9";
				for(var j = 0; j < w; ++j){
					const x = client_to_x(j);
					const y = polynomial_in_x(X, x, uncertain3_n);
					if(j == 0) {
						context.moveTo(x_to_client(x), y_to_client(y));
					} else {
						context.lineTo(x_to_client(x), y_to_client(y));
					}
				}
				context.stroke();
				context.closePath();
				context.lineWidth = 1;
			}
		}
	}

	// the certain polynomial
	var A = [];
	var B = [];
	for(var i = 0; i < uncertain3_n; ++i){
		A[i] = [];
		for(var j = 0; j < uncertain3_n; ++j){
			A[i][j] = Math.pow(uncertain3_xs[i], j);
		}
		B[i] = uncertain3_ys[i];
	}
	X = solved_linear(A, B, uncertain3_n);

	context.beginPath();
	context.lineWidth = 2;
	context.strokeStyle="#d64562";
	for(var j = 0; j < w; ++j){
		const x = client_to_x(j);
		const y = polynomial_in_x(X, x, uncertain3_n);
		if(j == 0) {
			context.moveTo(x_to_client(x), y_to_client(y));
		} else {
			context.lineTo(x_to_client(x), y_to_client(y));
		}
	}
	context.stroke();
	context.closePath();
	context.lineWidth = 1;

	// dots
	context.fillStyle="#d64562";
	for(var i = 0; i < uncertain3_n; ++i){
		const xi = x_to_client(uncertain3_xs[i]) + 0.5;
		const yi = y_to_client(uncertain3_ys[i]) + 0.5;
		context.beginPath();
		context.lineWidth = 1;
		context.arc(xi, yi, 4, 0, 2*Math.PI);
		context.stroke();
		context.fill();
		context.closePath();
		context.beginPath();
		context.lineWidth = 4;
		const x1 = x_to_client(uncertain3_xs[i]) + 0.5;
		const y1 = y_to_client(uncertain3_ys[i] - uncertain3_ds[i]) + 0.5;
		const x2 = x_to_client(uncertain3_xs[i]) + 0.5;
		const y2 = y_to_client(uncertain3_ys[i] + uncertain3_ds[i]) + 0.5;
		context.moveTo(x1, y1);
		context.lineTo(x2, y2);
		context.stroke();
		context.lineWidth = 1;
		context.closePath();
	}

	// guides
	if(do_guides){
		min_d = Math.pow(uncertain3_xs[0] - client_to_x(client_x), 2) + Math.pow(uncertain3_ys[0] - client_to_y(client_y), 2);
		min_i = 0;
		for(var i = 1; i < uncertain3_n; ++i){
			var di = Math.pow(uncertain3_xs[i] - client_to_x(client_x), 2) + Math.pow(uncertain3_ys[i] - client_to_y(client_y), 2);
			if(di < min_d){
				min_d = di;
				min_i = i;
			}
		}
		uncertain3_i = min_i;
		context.setLineDash([4, 4]);
		context.beginPath();
		context.moveTo(x_to_client(uncertain3_xs[min_i]), y_to_client(uncertain3_ys[min_i]));
		context.lineTo(client_x, client_y);
		context.strokeStyle="#d64562";
		context.stroke();
		context.closePath();
		context.setLineDash([]);
	}
}

// uncertain4
var uncertain4_xs = [0.0, 1.0, 4.0, 3.0];
var uncertain4_ys = [0.0, 1.0, 3.0, 2.48];
var uncertain4_ds = [1e-5, 0.1, 0.1, 0.1];
var uncertain4_n = 4;
var uncertain4_i = 0;

function init_uncertain4(){
	polynomial = document.getElementById("uncertain4");
	var canvas_rect = polynomial.getBoundingClientRect();
	uncertain4_draw(0, 0, false);

	polynomial.addEventListener('pointermove', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		uncertain4_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		if(e.buttons == 1){
			uncertain4_xs[uncertain4_i] = client_to_x(e.clientX - canvas_rect.left);
			uncertain4_ys[uncertain4_i] = client_to_y(e.clientY - canvas_rect.top);
			uncertain4_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false); // double work
		}
	}, false);

	polynomial.addEventListener('pointerdown', function(e){
		var canvas_rect = polynomial.getBoundingClientRect();
		uncertain4_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, true);
		uncertain4_xs[uncertain4_i] = client_to_x(e.clientX - canvas_rect.left);
		uncertain4_ys[uncertain4_i] = client_to_y(e.clientY - canvas_rect.top);
		uncertain4_draw(e.clientX - canvas_rect.left, e.clientY - canvas_rect.top, false);
		polynomial.releasePointerCapture(e.pointerId);
	}, false);

	polynomial.addEventListener('pointerleave', function(e){
		uncertain4_draw(0, 0, false);
	}, false);
}

function uncertain4_draw(client_x, client_y, do_guides){
	polynomial = document.getElementById("uncertain4");
	var context = polynomial.getContext("2d");
	context.font = "16px sans-serif";
	// background
	context.fillStyle="#eeeeee";
	context.fillRect(0, 0, w, h);

	// grid
	draw_grid_on(context);

	// uncertain polynomials
	for(var d1 = -uncertain4_ds[0]; d1 <= uncertain4_ds[0]; d1 += uncertain4_ds[0]) {
		for(var d2 = -uncertain4_ds[1]; d2 <= uncertain4_ds[1]; d2 += uncertain4_ds[1]) {
			for(var d3 = -uncertain4_ds[2]; d3 <= uncertain4_ds[2]; d3 += uncertain4_ds[2]) {
				for(var d4 = -uncertain4_ds[3]; d4 <= uncertain4_ds[3]; d4 += uncertain4_ds[3]) {
					var ds = [d1, d2, d3, d4];
					var A = [];
					var B = [];
					for(var i = 0; i < uncertain4_n; ++i){
						A[i] = [];
						for(var j = 0; j < uncertain4_n; ++j){
							A[i][j] = Math.pow(uncertain4_xs[i], j);
						}
						B[i] = uncertain4_ys[i] + ds[i];
					}
					X = solved_linear(A, B, uncertain4_n);

					context.beginPath();
					context.lineWidth = 1;
					context.strokeStyle="#EDACB9";
					for(var j = 0; j < w; ++j){
						const x = client_to_x(j);
						const y = polynomial_in_x(X, x, uncertain4_n);
						if(j == 0) {
							context.moveTo(x_to_client(x), y_to_client(y));
						} else {
							context.lineTo(x_to_client(x), y_to_client(y));
						}
					}
					context.stroke();
					context.closePath();
					context.lineWidth = 1;
				}
			}
		}
	}

	// the certain polynomial
	var A = [];
	var B = [];
	for(var i = 0; i < uncertain4_n; ++i){
		A[i] = [];
		for(var j = 0; j < uncertain4_n; ++j){
			A[i][j] = Math.pow(uncertain4_xs[i], j);
		}
		B[i] = uncertain4_ys[i];
	}
	X = solved_linear(A, B, uncertain4_n);

	context.beginPath();
	context.lineWidth = 2;
	context.strokeStyle="#d64562";
	for(var j = 0; j < w; ++j){
		const x = client_to_x(j);
		const y = polynomial_in_x(X, x, uncertain4_n);
		if(j == 0) {
			context.moveTo(x_to_client(x), y_to_client(y));
		} else {
			context.lineTo(x_to_client(x), y_to_client(y));
		}
	}
	context.stroke();
	context.closePath();
	context.lineWidth = 1;

	// dots
	context.fillStyle="#d64562";
	for(var i = 0; i < uncertain4_n; ++i){
		const xi = x_to_client(uncertain4_xs[i]) + 0.5;
		const yi = y_to_client(uncertain4_ys[i]) + 0.5;
		context.beginPath();
		context.lineWidth = 1;
		context.arc(xi, yi, 4, 0, 2*Math.PI);
		context.stroke();
		context.fill();
		context.closePath();
		context.beginPath();
		context.lineWidth = 4;
		const x1 = x_to_client(uncertain4_xs[i]) + 0.5;
		const y1 = y_to_client(uncertain4_ys[i] - uncertain4_ds[i]) + 0.5;
		const x2 = x_to_client(uncertain4_xs[i]) + 0.5;
		const y2 = y_to_client(uncertain4_ys[i] + uncertain4_ds[i]) + 0.5;
		context.moveTo(x1, y1);
		context.lineTo(x2, y2);
		context.stroke();
		context.lineWidth = 1;
		context.closePath();
	}

	// guides
	if(do_guides){
		min_d = Math.pow(uncertain4_xs[0] - client_to_x(client_x), 2) + Math.pow(uncertain4_ys[0] - client_to_y(client_y), 2);
		min_i = 0;
		for(var i = 1; i < uncertain4_n; ++i){
			var di = Math.pow(uncertain4_xs[i] - client_to_x(client_x), 2) + Math.pow(uncertain4_ys[i] - client_to_y(client_y), 2);
			if(di < min_d){
				min_d = di;
				min_i = i;
			}
		}
		uncertain4_i = min_i;
		context.setLineDash([4, 4]);
		context.beginPath();
		context.moveTo(x_to_client(uncertain4_xs[min_i]), y_to_client(uncertain4_ys[min_i]));
		context.lineTo(client_x, client_y);
		context.strokeStyle="#d64562";
		context.stroke();
		context.closePath();
		context.setLineDash([]);
	}
}

	</script>
</head>
<body>
	<center>
	<p style="width: 600pt; padding: 36pt 0pt 64pt 0pt;">This is <a href="index.html">Words and Buttons Online</a> — a collection of&nbsp;interactive <a href="all_tutorials.html">#tutorials</a>, <a href="all_demos.html">#demos<a/>, and <a href="all_quizzes.html">#quizzes</a> about <a href="all_mathematics.html">#mathematics</a>, <a href="all_algorithms.html">#algorithms</a> and <a href="all_programming.html">#programming</a>.</p>
	<h1>
Either your <span id="index_estimates">estimates</span> suck or your job does
	</h1>
	<p>
I hate when estimates come true consistently. As an engineer, I believe that if a job is reliably predictable, then it can also be easily automated. And as a project manager, I also believe that no one should spend time on a problem that a computer can solve for them. We all have roughly 80x365x24 = 700800 hours on this Earth, so making someone spend an hour of their life on some monkey work is a little more than a micro-murder.
	</p>
	<p>
Luckily, most estimates never come true, and I have a dozen polynomial models to show you why.
	</p>
	<h2>
The problem
	</h2>
	<p>
A ditch digger digs a one-meter ditch in one hour. How many meters a ditch digger will dig in eight hours?
	</p>
	<canvas id="polynomial2" width=640 height=640></canvas>
	<script language="JavaScript">
	init_polynomial2();
	</script>
	<p class="comment">&uarr; The plots on this page are interactive.</p>
	<p>
Eight, right? If you believe that actual people act like ditch diggers from a third-grade mathematical problem, read no further. Seriously, don’t bother. Just enjoy your C-level management position.
	</p>
	<p>
But you chose to read further after all. This means that you know a thing or two about people, mathematical modeling, or actual digging. Yes, small efforts don’t scale. Nobody can dig for eight hours straight without rest, people get tired. There is also heat and rain, there are tree roots, rocks, clay. The shovel can break. There could be a power cable underneath. This all makes work estimation hard and, at some point, impossible.
	</p>
	<h2>
Non-linearity of the predictive model
	</h2>
	<p>
Obviously, ditch digging is not an entirely linear process. Intuitively, an eight-hour ditch should be somewhat shorter than eight one-hour ditches. But how shorter exactly? Let’s gather some data and build a better model.
	</p>
	<p>
So let’s say we know that a three-meter-long ditch takes four hours to finish. Good! This gives us a new data point and allows us to promote our model from linear to quadratic.
	</p>
	<canvas id="polynomial3" width=640 height=640></canvas>
	<script language="JavaScript">
	init_polynomial3();
	</script>
	<p>
Hold on! But now, when we have tiredness accounted for, it looks like, after the seventh hour, a digger starts putting dirt back into the ditch for some reason. This doesn’t seem right. Perhaps, tiredness in itself is not a linear process either. You can’t get into negative efficiency just by getting tired.
	</p>
	<p>
Well, of course, this happens all the time in software engineering. Well-rested people write code, tired people write bugs. But in ditch digging, you don’t just undo your work when you’re tired, so looks like we need a better model still.
	</p>
	<p>
We can’t constrain a polynomial from going down, but we can dig one more ditch, add another data point,  and make the polynomial model look more like a process we want to copy. Let’s say we made an experiment, worked for 3 hours straight, and dug ourselves a 2.5-meter ditch. Good!
	</p>
	<canvas id="polynomial4" width=640 height=640></canvas>
	<script language="JavaScript">
	init_polynomial4();
	</script>
	<p>
So to build a convincing polynomial model of a ditch digger, we need at least three data points. This means that the estimating person should have dug at least three ditches in their life.
	</p>
	<p>
Intermediate conclusion: <b>to build a predictive model, you need data.</b>
	</p>
	<h2>
Multiple factors
	</h2>
	<p>
Ditch digging is impacted by multiple factors. Is the ground rocky or sandy? Are there tree roots? Are we digging with shovels, or do we have a digging machine? Introducing each new factor effectively introduces a new variable, a new dimension to the problem.
	</p>
	<p>
So to build a ditch digger’s model with one variable – time – you need three data points. That’s three ditches.
	</p>
	<canvas id="factor1" width=640 height=640></canvas>
	<script language="JavaScript">
	factor1_draw();
	</script>
	<p>
Now to account for two different types of soil, you need six data points. Three for rocks, and three for sand.
	</p>
	<canvas id="factor2" width=640 height=640></canvas>
	<script language="JavaScript">
	factor2_draw();
	</script>
	<p>
To add tree roots into the equation, you need, once again, to duplicate your data set, because roots can grow between rocks and in the sand too.
	</p>
	<canvas id="factor3" width=640 height=640></canvas>
	<script language="JavaScript">
	factor3_draw();
	</script>
	<p>
And, of course, having a digging machine is a game changer, so, once again, you have to duplicate your data set just to build a comprehensive model.
	</p>
	<canvas id="factor4" width=640 height=640></canvas>
	<script language="JavaScript">
	factor4_draw();
	</script>
	<p>
So the three points from before now become 24, which means that the estimating person should have dug at least 24 ditches before they could build a good enough model in their head. That’s a lot of digging.
	</p>
	<p>
Also, factor-wise, we barely scratched the surface. Some factors are not entirely accountable and not even measurable. They just contribute to the general unpredictability.
	</p>
	<p>
Intermediate conclusion: <b>the more factors the model accounts for, the more data you need. Not just more but exponentially more.</b>
	</p>
	<h2>
Input error
	</h2>
	<p>
When we say, a meter takes an hour to dig, we don’t mean exactly 100 centimeters and exactly 3,600,000 milliseconds. It’s roughly an hour for roughly a meter. This roughness means that when we dig a ditch, the result fluctuates from time to time, and instead of a specific meter per time function, we have a range of plausible functions. Our model is not a curve but a bundle of them.
	</p>
	<p>
For a linear model, this is not that bad. We allow a 10% error on the data point, and with this error, the model starts to diverge with time but it still retains some predictive power.
	</p>
	<canvas id="uncertain2" width=640 height=640></canvas>
	<script language="JavaScript">
	init_uncertain2();
	</script>
	<p>
But we already know that digging is non-linear so let’s try a two-point model, a quadratic one.
	</p>
	<canvas id="uncertain3" width=640 height=640></canvas>
	<script language="JavaScript">
	init_uncertain3();
	</script>
	<p>
Well, this is worse. The same 10% error on input results in a +/- 2 meters at the end of the time scale. But wait! As we add points, it gets better!
	</p>
	<canvas id="uncertain4" width=640 height=640></canvas>
	<script language="JavaScript">
	init_uncertain4();
	</script>
	<p>
Sorry, I meant “worse”. The model gets worse still. The effect of non-linear models being vulnerable to small input errors is pronounced much better though, and that’s what I meant to say. With a three-point or cubic model, a modest 10% input inaccuracy results in the model being completely useless.
	</p>
	<p>
We can mitigate this effect by narrowing down the input error ranges. We can do several measurements at each point, and then do some statistical analysis: weed out the outliers and compute the real confidence interval instead of some hypothetical 10%. We have math to do so. But! Once again, we need more data.
	</p>
	<p>
Intermediate conclusion: <b>we need even more data given that the input for our model is inherently inaccurate.</b>
	</p>
	<h2>
What’s my point?
	</h2>
	<p>
There is a notion that estimation is a skill. To develop this skill, you need to build some kind of model in your head. You need data. And non-linearity, multiple factors, and flimsy measurement make this modelling difficult and, now this is my point: <b>in most and not just a few exceptional cases, impossible.</b>
	</p>
	<p>
You can say that by adding more data, we can make every model better. Sure, that’s true. That’s what we do in machine learning as well. But we need tons of data. And every data point – is a job done in the past. How many user stories can you close, how many bugs can you possibly fix in your lifetime?  Remember, 700800 hours, and that’s it.
	</p>
	<p>
And that’s why your estimates suck. Just like everybody else’s. None of us have enough experience to develop a plausible model for generic software engineering work. To do that, we need way more data than we can possibly gather in our lifetime. Unless the work we’re trying to model is somehow linear and isolated from all the possible impacting factors. And if it is, it can and should be automated.
	</p>


	<table class="footer" style="width: 600pt; padding: 64pt 0pt 32pt 0pt; background-color: transparent; font-family: sans-serif; font-size: 16pt; font-style: normal;">
	<tr>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 64px; padding: 0; margin: 0; border: 0;">
		<a href="index.html">Index</a>
		<a href="all_mathematics.html">#mathematics</a> <a href="all_tutorials.html">#tutorials</a>
	</td>
	<td class="footer" style="vertical-align: middle; text-align: left; width: 200pt; padding: 0; margin: 0; border: 0;">
		&nbsp;&larr; there's more.
	</td>
	<td class="footer" style="vertical-align: middle; text-align: right; width: 300pt; padding: 0; margin: 0; border: 0;">
			<nobr>+
		<a href="https://wordsandbuttons.online/SYTYKC.pdf">So You Think You Know C</a> <span style="color:#888; font-size: 12pt;">(free book)</span></nobr><br>
			<nobr>+
		<a href="https://www.amazon.com/Geometry-Programmers-Oleksandr-Kaleniuk/dp/1633439607">Geometry for Programmers</a> <span style="color:#888; font-size: 12pt;">(paid book)</span></nobr><br>
			+
		<a href="https://github.com/akalenuk/wordsandbuttons">Github</a> &

		<a href="https://wordsandbuttons.online/rss"><span style="letter-spacing: 1pt;">RSS</span></a>
	</td>
	</tr>
	</table>
	</center>
</body>
</html>
